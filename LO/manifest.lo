lo.repo.manifest{
  import lo.
  import lo.resources.
  import lo.uri.
  import lo.repo.
  import lo.json.

  public type manifest ::= manifest(map[string,manifestEntry]).

  type manifestEntry ::= manifestEntry(string,list[(version,map[string,string])]).

  public readManifest:(uri) => manifest.
  readManifest(u) => m :- parseJson(j) %% explode(getResource(u)),
    jsonManifest(j,m).

  public flushManifest:(uri,manifest){}.
  flushManifest(Root,M) :-
    putResource(Root,formatSS(disp(manifestJson(M)))).

  jsonManifest:(json,manifest){}.
  jsonManifest(jColl(L),manifest(L///jsonPkgEntry)).

  jsonPkgEntry:(string,json) => manifestEntry.
  jsonPkgEntry(Pk,jColl(Vs)) => manifestEntry(Pk,pairs(Vs)//jsonVersion).

  jsonVersion:((string,json)) => (version,map[string,string]).
  jsonVersion(("*",jColl(Dtl))) => (defltVersion, Dtl///resourceEntry).
  jsonVersion((V,jColl(Dtl))) => (vers(V),Dtl///resourceEntry).

  resourceEntry:(string,json) => string.
  resourceEntry(_,jTxt(S)) => S.

  manifestJson:(manifest)=>json.
  manifestJson(manifest(E)) => jColl(E///entryJson).

  entryJson:(string,manifestEntry) => json.
  entryJson(P,manifestEntry(_,V)) => jColl(foldLeft(versionJson,[],V)).

  versionJson:(map[string,json],(version,map[string,string])) => map[string,json].
  versionJson(M,(defltVersion,R)) => M["*"->jColl(R///((_,S)=>jTxt(S)))].
  versionJson(M,(vers(V),R)) => M[V->jColl(R///((_,S)=>jTxt(S)))].

  -- Displaying a manifest
  public implementation display[manifest] <= {
    disp(manifest(E)) => ssSeq([ss("manifest"),ss("{\n"),ssSeq(showEntries(E)),ss("}\n")]).
  }

  showEntries:(map[string,manifestEntry]) => list[ss].
  showEntries(M) => values(M)//showEntry.

  public implementation display[manifestEntry] <= {
    disp(E) => showEntry(E).
  }

  showEntry:(manifestEntry) => ss.
  showEntry(manifestEntry(Pk,Versions)) => ssSeq([ss("  "),ss(Pk),ss(":{\n"),ssSeq(showVersions(Versions)),ss("  }\n")]).

  showVersions:(list[(version,map[string,string])]) => list[ss].
  showVersions([]) => [].
  showVersions([V,..M]) => [showVersion(V),..showVersions(M)].

  showVersion:((version,map[string,string])) => ss.
  showVersion((V,R)) => ssSeq([ss("    "),disp(V),ss("="),disp(R),ss("\n")]).

  public locateInManifest:(manifest,pkg,string,string){}.
  locateInManifest(manifest(Entries),pkg(Pkg,Vers),Kind,URI) :-
    -- _logmsg(_stringOf(Pkg,0,0)),
    present(Entries,Pkg,manifestEntry(Pkg,V)),
    -- _logmsg(_stringOf(V,0,0)),
    getVersion(Vers,_,V,Map),
    -- _logmsg("\(Pkg) has kinds \(Map)"),
    present(Map,Kind,URI).
    -- _logmsg("\(Pkg) : \(Kind) at \(URI)").

  getVersion:(version,version,list[(version,map[string,string])],map[string,string]){}.
  getVersion(Vers,Vers,V,Map) :- (Vers,Map) in V!.
  getVersion(defltVersion,Act,V,Map) :- (Act,Map) in V!.

  public addToManifest:(manifest,pkg,string,string) => manifest.
  addToManifest(manifest(M),pkg(P,V),Kind,Uri) => manifest(MM) :-
    present(M,P,Entry),
    MM = M[P->addVersion(Entry,V,Kind,Uri)].
--    _logmsg("added version to \(MM)").
  addToManifest(manifest(M),pkg(P,V),Kind,Uri) => manifest(MM) :-
    MM = M[P->addVersion(manifestEntry(P,[]),V,Kind,Uri)].
--    _logmsg("new package \(MM)").

  addVersion:(manifestEntry,version,string,string) => manifestEntry.
  addVersion(manifestEntry(P,Vs),V,K,U) => manifestEntry(P,addToVersion(Vs,V,K,U)).

  addToVersion:(list[(version,map[string,string])],version,string,string) => list[(version,map[string,string])].
  addToVersion([],V,K,U) => [(V,[K->U])].
  addToVersion([(V,M),..Vs],V,K,U) => [(V,M[K->U]),..Vs].
  addToVersion([Vr,..Vs],V,K,U) => [Vr,..addToVersion(Vs,V,K,U)].
}
