lo.options{
  import lo.
  import lo.either.

  -- Process command line list of strings to produce a set of Options
  public type optionsProcessor <~ {
    shortForm : string.
    alternatives : list[string].
    usage : string.
    validator : option[(string){}].
  }

  public processOptions:(list[string],list[optionsProcessor]) =>
    either[(list[(string,option[string])],list[string]),string].
  processOptions(Raw,Opts) => processAll(Raw,Opts,[]).

  processAll:(list[string],list[optionsProcessor],list[(string,option[string])]) =>
    either[(list[(string,option[string])],list[string]),string].
  processAll([],_,SoFar) => either((SoFar,[])).
  processAll(["--",..A],_,SoFar) => either((SoFar,A)).
  processAll([A,..L],Opts,SoFar) =>
    processOption(A,L,Opts,SoFar).

  processOption:(string,list[string],list[optionsProcessor],list[(string,option[string])]) => either[(list[(string,option[string])],list[string]),string].
  processOption(A,L,Opts,SoFar) => checkOption(L,O.shortForm,O.validator,Opts,SoFar) :-
    (O in Opts, (A==O.shortForm | A in O.alternatives))!.
  processOption(A,L,_,SoFar) => either((SoFar,[A,..L])).

  checkOption:(list[string],string,option[(string){}],list[optionsProcessor],list[(string,option[string])]) =>
    either[(list[(string,option[string])],list[string]),string].
  checkOption(Args,O,none,Opts,SoFar) =>
        processAll(Args,Opts,[(O,none),..SoFar]).
  checkOption([A,..Args],O,some(V),Opts,SoFar) =>
        processAll(Args,Opts,[(O,some(A)),..SoFar]) :- V(A).
  checkOption(_,_,_,Opts,_) => alternate(collectUsage(Opts)).

  collectUsage:(list[optionsProcessor]) => string.
  collectUsage(Opts) => foldRight(((O:optionsProcessor),S)=>S+O.usage,"",Opts).
}
