lo.core{
  -- Core definitions of types and interfaces that are really part of the language

  public type thing ::= thing.

  public contract all x ~~ equality[x] <~ {
    (==): (x,x){}.
    hash:(x)=>integer.
  }

  public (\==):all x ~~ equality[x] |: (x,x){}.
  x \== y :- \+ x==y.

  public
  contract all x ~~ /*equality[x] |: */ comp[x] <~ {
    (<): (x,x){}.
    (>=): (x,x){}.
  }

  public
  type all t ~~ option[t] ::= none | some(t).

  public
  contract all x ~~ additive[x] <~ {
    (+): (x,x)=>x.
    (-): (x,x)=>x.
    zero: x.
  }

  public
  contract all x ~~ /* additive[x] |: */ arith[x] <~ {
    (*): (x,x)=>x.
    (/): (x,x)=>x.
    (%): (x,x)=>x.
    one:x.
  }

  public contract all c ~~ sizeable[c] <~ {
    size:(c) => integer.
    isEmpty:(c){}.
  }

  -- Structured string.
  public type ss ::= ss(string) | sc(integer) | ssSeq(list[ss]).

  -- Displayable contract
  public contract all t ~~ display[t] <~ {
    disp:(t)=>ss.
  }

  -- stream contract
  public
  contract all S,E ~~ stream[S ->> E] <~ {
    _eof:(S){}.
    _hdtl:(S,E,S){}.
  }

  -- implement standard contracts for integers

  public implementation additive[integer] <= {
    X+Y => _int_plus(X,Y).
    X-Y => _int_minus(X,Y).
    zero = 0.
  }

  public implementation arith[integer] <= {
    X*Y => _int_times(X,Y).
    X/Y => _int_div(X,Y).
    X%Y => _int_mod(X,Y).
    one = 1.
  }

  public implementation equality[integer] <= {
    X == X.
    hash(X) => X.
  }

  public
  implementation comp[integer] <= {
    X<Y :- _int_lt(X,Y).
    X>=Y :- _int_ge(X,Y).
  }

  public
  implementation display[integer] <= {
    disp(X) => ss(_int2str(X,10,0,0c )).
  }

  -- implement standard contracts for floats
  public implementation additive[float] <= {
    X+Y => _flt_plus(X,Y).
    X-Y => _flt_minus(X,Y).

    zero = 0.0.
  }

  public implementation arith[float] <= {
    X*Y => _flt_times(X,Y).
    X/Y => _flt_div(X,Y).
    X%Y => _flt_mod(X,Y).

    one = 1.0.
  }

  public implementation equality[float] <= {
    X == X.
    hash(X) => _flt_hash(X).
  }

  public implementation comp[float] <= {
    X<Y :- _flt_lt(X,Y).
    X>=Y :- _flt_ge(X,Y).
  }

  public
  (>) : all t ~~ comp[t] |: (t,t){}.
  X > Y :- Y<X.

  public
  (=<): all t ~~ comp[t] |: (t,t){}.
  X =< Y :- Y>=X.

  public
  min: all t ~~ comp[t] |: (t,t)=>t.
  min(X,Y) => X :- X<Y.
  min(_,Y) => Y.

  public
  max: all t ~~ comp[t] |: (t,t)=>t.
  max(X,Y)  => X:- X>Y.
  max(_,Y) => Y.

  public implementation display[float] <= {
    disp(X) => ss(_flt2str(X,0,8,0cg,false)).
  }

  -- and strings ...
  public implementation additive[string] <= {
    X+Y => _str_concat(X,Y).
    X-Y => "".

    zero = "".
  }

  public implementation equality[string] <= {
    X == X.
    hash(X) => _str_hash(X).
  }

  public implementation comp[string] <= {
    X<Y :- _str_lt(X,Y).
    X>=Y :- _str_ge(X,Y).
  }

  public implementation display[string] <= {
    disp(X) => displayString(X).
  }

  public displayString:(string) => ss.
  displayString(S) => ssSeq([sc(0c\"),ssSeq(quoteStr(explode(S))),sc(0c\")]).

  private quoteStr:(list[integer]) => list[ss].
  quoteStr([])=>[].
  quoteStr([c,..l]) => qtChr(c,quoteStr(l)).

  private qtChr:(integer,list[ss]) => list[ss].
  qtChr(0c",l) => [sc(0c\\),sc(0c"),..l].
  qtChr(0c\\,l) => [sc(0c\\),sc(0c\\),..l].
  qtChr(c,l) => [sc(c),..l].

  public implementation sizeable[string] <= {
    size(S) => _str_len(S).
    isEmpty("").
  }

  -- Not strictly necessary, but makes for better symmetry.
  public
  type logical ::= true | false.

  -- We need the list type in the core
  public
  type all t ~~ list[t] ::= '[]' | ',..'(t,list[t]).

  -- Implement equality for lists
  public
  implementation all x ~~ equality[x] |: equality[list[x]] <= {
    L1 == L2 :- listEq(L1,L2).
    hash(L) => listHash(L).
  }

  private
  listEq:all x ~~ equality[x] |: (list[x],list[x]){}.
  listEq([],[]).
  listEq([E1,..L1],[E2,..L2]) :- E1==E2, listEq(L1,L2).

  private
  listHash:all x ~~ equality[x] |: (list[x])=>integer.
  listHash([]) => 0.
  listHash([E,..L]) => hash(E)*37+listHash(L).

  -- stream contract
  public
  implementation all x ~~ stream[list[x] ->> x] <= {
    _eof([]).
    _hdtl([E,..L],E,L).
  }

  -- display contract for lists
  public
  implementation all x ~~ display[x] |: display[list[x]] <= {
    disp(L) => ssSeq([ss("["),..listDisp(L,"")]).
  }

  private
  listDisp:all x ~~ display[x] |: (list[x],string) => list[ss].
  listDisp(X,_) => [ss(",.."),disp(X),ss("]")] :- var(X).
  listDisp([],_) => [ss("]")].
  listDisp([E,..L],Sep) => [ss(Sep),disp(E),..listDisp(L,",")].

  -- display optional values
  public implementation all x ~~ display[x] |: display[option[x]] <= {
    disp(O) => dispOptional(O).
  }

  private dispOptional:all x ~~ display[x] |: (option[x]) => ss.
  dispOptional(none) => ss("none").
  dispOptional(some(X)) => ssSeq([ss("some("),disp(X),ss(")")]).

  public implementation all x ~~ equality[x] |: equality[option[x]] <= {
    X == Y :- optionEqual(X,Y).
    hash(X) => optionHash(X).
  }

  private optionEqual:all x ~~ equality[x] |: (option[x],option[x]){}.
  optionEqual(some(A),some(B)) :- A==B.
  optionEqual(none,none).

  private optionHash:all x ~~ equality[x] |: (option[x]) => integer.
  optionHash(some(X)) => hash("some")*37+hash(X).
  optionHash(none) => hash("none").

  -- Display 2-tuples
  public implementation all x,y ~~ display[x], display[y] |: display[(x,y)] <= {
    disp(T) => dispPair(T).
  }

  private dispPair:all x,y ~~ display[x], display[y] |: ((x,y)) => ss.
  dispPair((a,b)) => ssSeq([ss("("),disp(a),ss(" , "),disp(b),ss(")")]).

  public implementation all x,y ~~ equality[x], equality[y] |: equality[(x,y)] <= {
    X == Y :- pairEquals(X,Y).
    hash(X) => pairHash(X).
  }

  pairEquals:all x,y ~~ equality[x], equality[y] |: ((x,y),(x,y)){}.
  pairEquals((A1,A2),(B1,B2)) :- A1==B1, A2==B2.

  pairHash:all x,y ~~ equality[x],equality[y] |: ((x,y))=>integer.
  pairHash((A,B)) => hash(A)*37+hash(B).
}
