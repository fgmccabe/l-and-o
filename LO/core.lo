lo.core{
  -- Core definitions of types and interfaces that are really part of the language

  public type thing ::= thing.

  public 
  contract all x ~~ equality[x] <~ {
    (==): (x,x){}.
    hash:(x)=>integer.
  }

  public 
  contract all x ~~ /*equality[x] |: */ comp[x] <~ {
    (<): (x,x){}.
    (>=): (x,x){}.
  }
  
  public
  type all t ~~ option[t] ::= none | some(t).
  
  public 
  contract all x ~~ additive[x] <~ {
    (+): (x,x)=>x.
    (-): (x,x)=>x.
    zero: x.
  }

  public
  contract all x ~~ /* additive[x] |: */ arith[x] <~ {
    (*): (x,x)=>x.
    (/): (x,x)=>x.
    (%): (x,x)=>x.
    one:x.
  }

  -- Structured string. This is only part of the type ..
  public type ss ::= ss(string) | sc(integer) | ssSeq(list[ss]).

  -- Displayable contract
  public  
  contract all t ~~ display[t] <~ {
    disp:(t)=>ss.
  }

  -- stream contract
  public
  contract all S,E ~~ stream[S ->> E] <~ {
    _eof:(S){}.
    _hdtl:(S,E,S){}.
    _cons:(E,S)=>S.
  }

  -- implement standard contracts for integers

  public
  implementation additive[integer] .. {
    X+Y => _int_plus(X,Y).
    X-Y => _int_minus(X,Y).
    zero = 0.
  }

  public
  implementation arith[integer] .. {
    X*Y => _int_times(X,Y).
    X/Y => _int_div(X,Y).
    X%Y => _int_mod(X,Y).
    one = 1.
  }

  public
  implementation equality[integer] .. {
    X == X.
    hash(X) => X.
  }

  public
  implementation comp[integer] .. {
    X<Y :- _int_lt(X,Y).
    X>=Y :- _int_ge(X,Y).
  }

  public
  implementation display[integer] .. {
    disp(X) => ss(_int2str(X,10,0,0c )).
  }

  -- implement standard contracts for floats
  public
  implementation additive[float] .. {
    X+Y => _flt_plus(X,Y).
    X-Y => _flt_minus(X,Y).

    zero = 0.0.
  }

  public
  implementation arith[float] .. {
    X*Y => _flt_times(X,Y).
    X/Y => _flt_div(X,Y).
    X%Y => _flt_mod(X,Y).

    one = 1.0.
  }

  public 
  implementation equality[float] .. {
    X == X.
    hash(X) => _flt_hash(X).
  }

  public 
  implementation comp[float] .. {
    X<Y :- _flt_lt(X,Y).
    X>=Y :- _flt_ge(X,Y).
  }

  public
  (>) : all t ~~ comp[t] |: (t,t){}.
  X > Y :- Y<X.

  public
  (=<): all t ~~ comp[t] |: (t,t){}.
  X =< Y :- Y>=X.

  public
  min: all t ~~ comp[t] |: (t,t)=>t.
  min(X,Y) => X :- X<Y.
  min(_,Y) => Y.

  public 
  max: all t ~~ comp[t] |: (t,t)=>t.
  max(X,Y)  => X:- X>Y.
  max(_,Y) => Y.

  public
  implementation display[float] .. {
    disp(X) => ss(_flt2str(this,0,8,true,false)).
  }

  -- and strings ...
  public
  implementation additive[string] .. {
    X+Y => _str_concat(X,Y).
    X-Y => "".

    zero = "".
  }

  public
  implementation equality[string] .. {
    X == X.
    hash(X) => _str_hash(X).
  }

  public
  implementation comp[string] .. {
    X<Y :- _str_lt(X,Y).
    X>=Y :- _str_ge(X,Y).
  }

  public
  implementation display[string] .. {
    disp(X) => displayString(X).
  }

  public displayString:(string) => ss.
  displayString(S) => ssSeq([sc(0c\"),ssSeq(quoteStr(explode(S))),sc(0c\")]).

  private quoteStr:(list[integer]) => list[ss].
  quoteStr([])=>[].
  quoteStr([c,..l]) => qtChr(c,quoteStr(l)).

  private qtChr:(integer,list[ss]) => list[ss].
  qtChr(0c",l) => [sc(0c\\),sc(0c"),..l].
  qtChr(0c\\,l) => [sc(0c\\),sc(0c\\),..l].
  qtChr(c,l) => [sc(c),..l].

  -- Not strictly necessary, but makes for better symmetry.
  public
  type logical ::= true | false.

  -- We need the list type in the core
  public
  type all t ~~ list[t] ::= '[]' | ',..'(t,list[t]).

  -- Implement equality for lists
  public
  implementation all x ~~ equality[x] |: equality[list[x]] .. {
    L1 == L2 :- listEq(L1,L2).
    hash(L) => listHash(L).
  }

  private
  listEq:all x ~~ equality[x] |: (list[x],list[x]){}.
  listEq([],[]).
  listEq([E1,..L1],[E2,..L2]) :- E1==E2, listEq(L1,L2).

  private
  listHash:all x ~~ equality[x] |: (list[x])=>integer.
  listHash([]) => 0.
  listHash([E,..L]) => hash(E)*37+listHash(L).

  -- stream contract
  public
  implementation all x ~~ stream[list[x] ->> x] .. {
    _eof([]).
    _hdtl([E,..L],E,L).
    _cons(E,L) => [E,..L].
  }

  -- display contract for lists
  public
  implementation all x ~~ display[x] |: display[list[x]] .. {
    disp(L) => ssSeq([ss("["),..listDisp(L,"")]).
  }

  private
  listDisp:all x ~~ display[x] |: (list[x],string) => list[ss].
  listDisp(X,_) => [ss(",.."),disp(X),ss("]")] :- var(X).
  listDisp([],_) => [ss("]")].
  listDisp([E,..L],Sep) => [ss(Sep),disp(E),..listDisp(L,",")].
}