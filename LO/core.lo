lo.core{
  -- Core definitions of types and interfaces that are really part of the language

  public type thing ::= thing.

  public 
  contract all x ~~ equality[x] .. {
    eq: (x,x){}.
    hash:(x)=>integer.
  }

  public 
  contract all x ~~ equality[x] |: comp[x] .. {
    lt: (x,x){}.
    ge: (x,x){}.
  }
  
  public
  type all t ~~ option[t] ::= none | some(t).
  
  public 
  contract all x ~~ additive[x] .. {
    pl:  (x,x)=>x.
    mns: (x,x)=>x.
  }

  public  
  contract all x ~~ additive[x] |: arith[x] .. {
    tms: (x,x)=>x.
    dv:  (x,x)=>x.
    md: (x,x)=>x.
  }

  -- Structured string. This is only part of the type ..
  public type ss ::= ss(string) | ssSeq(list[ss]).

  -- Displayable contract
  public  
  contract all t ~~ display[t] .. {
    disp:(t)=>ss.
  }

  -- stream contract
  public
  contract all S,E ~~ stream[S ->> E] .. {
    eof:(S){}.
    hdtl:(S,E,S){}.
    cons:(E,S)=>S.
  }

  -- implement standard contracts for integers

  public
  implementation arith[integer] .. {
    pl(X,Y) => _int_plus(X,Y).
    tms(X,Y) => _int_times(X,Y).
    mns(X,Y) => _int_minus(X,Y).
    dv(X,Y) => _int_div(X,Y).
    md(X,Y) => _int_mod(X,Y).
  }

  public
  implementation comp[integer] .. {
    eq(X,X).
    hash(X) => X.

    lt(X,Y) :- _int_lt(X,Y).
    ge(X,Y) :- _int_ge(X,Y).
  }

  public
  implementation display[integer] .. {
    disp(X) => ss(_int2str(X,10,0,0c )).
  }

  -- implement standard contracts for floats
  public
  implementation arith[float] .. {
    pl(X,Y) => _flt_plus(X,Y).
    tms(X,Y) => _flt_times(X,Y).
    mns(X,Y) => _flt_minus(X,Y).
    dv(X,Y) => _flt_div(X,Y).
    md(X,Y) => _flt_mod(X,Y).
  }

  public 
  implementation comp[float] .. {
    eq(X,X).
    hash(X) => _flt_hash(X).

    lt(X,Y) :- _flt_lt(X,Y).
    ge(X,Y) :- _flt_ge(X,Y).
  }

  public
  implementation display[float] .. {
    disp(X) => ss(_flt2str(this,0,8,true,false)).
  }

  -- and strings ...

  public
  implementation comp[string] .. {
    eq(X,X).
    hash(X) => _str_hash(X).

    lt(X,Y) :- _str_lt(X,Y).
    ge(X,Y) :- _str_ge(X,Y).
  }


  public
  implementation display[string] .. {
    disp(X) => ss(X).
  }

  -- Not strictly necessary, but makes for better symmetry.
  public
  type logical ::= true | false.

  -- We need the list type in the core
  public
  type all t ~~ list[t] ::= '[]' | ',..'(t,list[t]).

  -- Implement equality for lists
  public
  implementation all x ~~ equality[x] |: equality[list[x]] .. {
    eq(L1,L2) :- listEq(L1,L2).
    hash(L) => listHash(L).
  }

  private
  listEq:all x ~~ equality[x] |: (list[x],list[x]){}.
  listEq([],[]).
  listEq([E1,..L1],[E2,..L2]) :- eq(E1,E2), listEq(L1,L2).

  private
  listHash:all x ~~ equality[x] |: (list[x])=>integer.
  listHash([]) => 0.
  listHash([E,..L]) => hash(E)*37+listHash(L).

  -- stream contract
  public
  implementation all x ~~ stream[list[x] ->> x] .. {
    eof([]).

    hdtl([E,..L],E,L).

    cons(E,L) => [E,..L].
  }

  -- display contract for lists
  public
  implementation all x ~~ display[x] |: display[list[x]] .. {
    disp(L) => ssSeq([ss("["),..listDisp(L,"")]).
  }

  private
  listDisp:all x ~~ display[x] |: (list[x],string) => list[ss].
  listDisp(X,_) :: var(X) => [ss(",.."),disp(X),ss("]")].
  listDisp([],_) => [ss("]")].
  listDisp([E,..L],Sep) => [ss(Sep),disp(E),..listDisp(L,",")].
}