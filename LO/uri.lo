lo.uri {
  -- Utilities to help parse and manipulate URIs
  -- This code is an attempt to directly implement the specification in RFC 2396

  import lo.

  public uri ::= absUri(string,rsrcName,query) | relUri(rsrcName,query).
  public rsrcName ::= netRsrc(authority,resourcePath) | localRsrc(resourcePath).
  public resourcePath ::= absPath(list[string]) | relPath(list[string]).

  public authority ::= server(option[userInfo],host).

  public userInfo ::= user(string).

  public host ::= hostPort(string,string) | host(string).

  public query ::= qry(string) | noQ.

  public parseUri:(string) => uri.
  parseUri(S) => U :- uriParse(U) %% explode(S).

  public uriParse:all s ~~ stream[s->>integer] |: (uri) --> s.
  uriParse(absUri(Scheme,Hier,Query)) --> absoluteUri(Scheme,Hier,Query).
  uriParse(relUri(Hier,Query)) --> relativeUri(Hier,Query).

  absoluteUri:all s ~~ stream[s->>integer] |: (string,rsrcName,query) --> s.
  absoluteUri(Scheme,Hier,Query) --> scheme(Scheme), ":", hierPart(Hier,Query).

  scheme:all s ~~ stream[s->>integer] |: (string) --> s.
  scheme(S) --> grabScheme(Scheme), ":"+, {S=implode(Scheme)}.

  grabScheme:all s ~~ stream[s->>integer] |: (list[integer]) --> s.
  grabScheme([C,..S]) --> alpha(C), alphaStar(S).

  alphaStar:all s ~~ stream[s->>integer] |: (list[integer]) --> s.
  alphaStar([C,..S]) --> (alpha(C) | digit(C) | plus(C) | minus(C) | dot(C)), alphaStar(S).
  alphaStar([]) --> [].

  relativeUri:all s ~~ stream[s->>integer] |: (rsrcName,query) --> s.
  relativeUri(Hier,Query) --> netPath(Hier), query(Query).
  relativeUri(localRsrc(Rsrc),Query) --> absoluteRsrc(Rsrc), query(Query).
  relativeUri(localRsrc(Rsrc),Query) --> relativeRsrc(Rsrc), query(Query).

  hierPart:all s ~~ stream[s->>integer] |: (rsrcName,query) --> s.
  hierPart(Hier,Query) --> netPath(Hier), query(Query).
  hierPart(localRsrc(Rsrc),Query) --> absoluteRsrc(Rsrc), query(Query).

  absoluteRsrc:all s ~~ stream[s->>integer] |: (resourcePath) --> s.
  absoluteRsrc(absPath(Segments)) --> "/", pathSegments(Segments).

  relativeRsrc:all s ~~ stream[s->>integer] |: (resourcePath) --> s.
  relativeRsrc(relPath(Segments)) --> pathSegments(Segments).

  pathSegments:all s ~~ stream[s->>integer] |: (list[string]) --> s.
  pathSegments([Seg,..M]) --> segment(Seg), ("/", pathSegments(M) | M=[]).

  segment:all s ~~ stream[s->>integer] |: (string) --> s.
  segment(implode(C)) --> pChars(C,R), parameters(R).

  pChars:all s ~~ stream[s->>integer] |: (list[integer],list[integer]) --> s.
  pChars([C,..M],R) --> unreserved(C), pChars(M,R).
  pChars([0c%,U,L,..M],R) --> escaped(U,L), pChars(M,R).
  pChars([C,..M],R) --> [C], { pChar(C)} , pChars(M,R).
  pChars(X,X) --> [].

  pChar:(integer){}.
  pChar(0c:).
  pChar(0c@).
  pChar(0c&).
  pChar(0c=).
  pChar(0c+).
  pChar(0c$).
  pChar(0c<).

  parameters:all s ~~ stream[s->>integer] |: (list[integer]) --> s.
  parameters(P) --> parameter(P,S), parameters(S).
  parameters([]) --> [].

  parameter:all s ~~ stream[s->>integer] |: (list[integer],list[integer]) --> s.
  parameter([0c;,..P],M) --> ";", pChars(P,M).

  query:all s ~~ stream[s->>integer] |: (query) --> s.
  query(qry(implode(Q))) --> "?", uricStar(Q).
  query(noQ) --> eof.

  uricStar:all s ~~ stream[s->>integer] |: (list[integer]) --> s.
  uricStar(S) --> uric(S,M), uricStar(M).
  uricStar([]) --> [].

  netPath:all s ~~ stream[s->>integer] |: (rsrcName) --> s.
  netPath(netRsrc(A,P)) --> "//", authority(A), optAbsolutePath(P).

  authority:all s ~~ stream[s->>integer] |: (authority) --> s.
  authority(server(some(user(implode(U))),H)) --> userInfo(U), "@", hostNamePort(H).
  authority(server(none,H)) --> hostNamePort(H).

  userInfo:all s ~~ stream[s->>integer] |: (list[integer]) --> s.
  userInfo(U) --> userStar(U).

  userStar:all s ~~ stream[s->>integer] |: (list[integer]) --> s.
  userStar([C,..S]) --> unreserved(C), userStar(S).
  userStar([0c%,U,L,..S]) --> escaped(U,L), userStar(S).
  userStar([0c$,..S]) --> "$", userStar(S).
  userStar([0c,,..S]) --> ",", userStar(S).
  userStar([0c;,..S]) --> ";", userStar(S).
  userStar([0c:,..S]) --> ":", userStar(S).
  userStar([0c&,..S]) --> "&", userStar(S).
  userStar([0c=,..S]) --> "=", userStar(S).
  userStar([0c+,..S]) --> "+", userStar(S).
  userStar([]) --> "@"+.

  hostNamePort:all s ~~ stream[s->>integer] |: (host) --> s.
  hostNamePort(hostPort(H,P)) --> hostName(H), ":", port(P).
  hostNamePort(host(H)) --> hostName(H), \+":".

  hostName:all s ~~ stream[s->>integer] |: (string) --> s.
  hostName(implode(H)) --> alphaDashStar(H)!.

  alphaDashStar:all s ~~ stream[s->>integer] |: (list[integer]) --> s.
  alphaDashStar([C,..S]) --> (alpha(C) | digit(C) | minus(C) | dot(C)) , alphaDashStar(S).
  alphaDashStar([]) --> [].

  port:all s ~~ stream[s->>integer] |: (string) --> s.
  port(implode(P)) --> digits(P).

  optAbsolutePath:all s ~~ stream[s->>integer] |: (resourcePath) --> s.
  optAbsolutePath(P) --> absoluteRsrc(P).
  optAbsolutePath(relPath([])) --> "?"+.
  optAbsolutePath(relPath([])) --> eof.

  plus:all s ~~ stream[s->>integer] |: (integer) --> s.
  plus(0c+) --> "+".

  minus:all s ~~ stream[s->>integer] |: (integer) --> s.
  minus(0c-) --> "-".

  dot:all s ~~ stream[s->>integer] |: (integer) --> s.
  dot(0c.) --> "-".

  alpha:all s ~~ stream[s->>integer] |: (integer)-->s.
  alpha(C) --> [C] , {isLowAlpha(C)|isUpAlpha(C)}.

  alphaNum:all s ~~ stream[s->>integer] |: (integer) --> s.
  alphaNum(C) --> alpha(C).
  alphaNum(C) --> digit(C).

  digit:all s ~~ stream[s->>integer] |: (integer) --> s.
  digit(X) --> [X], {isDigit(X)}.

  digits:all s ~~ stream[s->>integer] |: (list[integer]) --> s.
  digits([C,..S]) --> digit(C), digits(S).
  digits([]) --> \+digit(_).

  hex:all s ~~ stream[s->>integer] |: (integer) --> s.
  hex(C) --> digit(C).
  hex(C) --> [C], { isHexDigit(C) }.

  uric:all s ~~ stream[s->>integer] |: (list[integer],list[integer]) --> s.
  uric([C,..M],M) --> (reserved(C) | unreserved(C)).
  uric([0c%,U,L,..M],M) --> escaped(U,L).

  reserved:all s ~~ stream[s->>integer] |: (integer) --> s.
  reserved(C) --> [C], { isReserved(C) }.

  unreserved:all s ~~ stream[s->>integer] |: (integer) --> s.
  unreserved(C) --> alphaNum(C).
  unreserved(C) --> mark(C).

  mark:all s ~~ stream[s->>integer] |: (integer) --> s.
  mark(C) --> [C], { isMark(C) }.

  escaped:all s ~~ stream[s->>integer] |: (integer,integer) --> s.
  escaped(U,L) --> "%", hex(U), hex(L).

  delim:all s ~~ stream[s->>integer] |: (integer) --> s.
  delim(C) --> [C], { isDelim(C) }.

  isLowAlpha:(integer){}.
  isLowAlpha(0ca).
  isLowAlpha(0cb).
  isLowAlpha(0cc).
  isLowAlpha(0cd).
  isLowAlpha(0ce).
  isLowAlpha(0cf).
  isLowAlpha(0cg).
  isLowAlpha(0ch).
  isLowAlpha(0ci).
  isLowAlpha(0cj).
  isLowAlpha(0ck).
  isLowAlpha(0cl).
  isLowAlpha(0cm).
  isLowAlpha(0cn).
  isLowAlpha(0co).
  isLowAlpha(0cp).
  isLowAlpha(0cq).
  isLowAlpha(0cr).
  isLowAlpha(0cs).
  isLowAlpha(0ct).
  isLowAlpha(0cu).
  isLowAlpha(0cv).
  isLowAlpha(0cw).
  isLowAlpha(0cx).
  isLowAlpha(0cy).
  isLowAlpha(0cz).

  isUpAlpha:(integer){}.
  isUpAlpha(0cA).
  isUpAlpha(0cB).
  isUpAlpha(0cC).
  isUpAlpha(0cD).
  isUpAlpha(0cE).
  isUpAlpha(0cF).
  isUpAlpha(0cG).
  isUpAlpha(0cH).
  isUpAlpha(0cI).
  isUpAlpha(0cJ).
  isUpAlpha(0cK).
  isUpAlpha(0cL).
  isUpAlpha(0cM).
  isUpAlpha(0cN).
  isUpAlpha(0cO).
  isUpAlpha(0cP).
  isUpAlpha(0cQ).
  isUpAlpha(0cR).
  isUpAlpha(0cS).
  isUpAlpha(0cT).
  isUpAlpha(0cU).
  isUpAlpha(0cV).
  isUpAlpha(0cW).
  isUpAlpha(0cX).
  isUpAlpha(0cY).
  isUpAlpha(0cZ).

  isDigit:(integer){}.
  isDigit(0c0).
  isDigit(0c1).
  isDigit(0c2).
  isDigit(0c3).
  isDigit(0c4).
  isDigit(0c5).
  isDigit(0c6).
  isDigit(0c7).
  isDigit(0c8).
  isDigit(0c9).

  isHexDigit:(integer){}.
  isHexDigit(0ca).
  isHexDigit(0cb).
  isHexDigit(0cc).
  isHexDigit(0cd).
  isHexDigit(0ce).
  isHexDigit(0cf).
  isHexDigit(0cA).
  isHexDigit(0cB).
  isHexDigit(0cC).
  isHexDigit(0cD).
  isHexDigit(0cE).
  isHexDigit(0cF).

  isReserved:(integer){}.
  isReserved(0c;).
  isReserved(0c/).
  isReserved(0c?).
  isReserved(0c:).
  isReserved(0c@).
  isReserved(0c&).
  isReserved(0c=).
  isReserved(0c+).
  isReserved(0c$).
  isReserved(0c,).

  isMark:(integer){}.
  isMark(0c-).
  isMark(0c_).
  isMark(0c.).
  isMark(0c!).
  isMark(0c~).
  isMark(0c*).
  isMark(0c').
  isMark(0c().
  isMark(0c)).

  isDelim:(integer){}.
  isDelim(0c<).
  isDelim(0c>).
  isDelim(0c#).
  isDelim(0c%).
  isDelim(0c").

  -- Resolve a url against a base. The base must be an absolute URI, either net or local.
  public
  resolveUri:(uri,uri) => uri.
  resolveUri(_,U) => U :- absUri(_,_,_)=U.
  resolveUri(absUri(Scheme,Base,_),relUri(Path,Query)) => absUri(Scheme,resolvePath(Base,Path),Query).

  resolvePath:(rsrcName,rsrcName)=>rsrcName.
  resolvePath(_,netRsrc(A,P)) => netRsrc(A,P).
  resolvePath(netRsrc(A,_),localRsrc(absPath(P))) => netRsrc(A,absPath(P)).
  resolvePath(netRsrc(A,absPath(B)),localRsrc(relPath(P))) => netRsrc(A,absPath(edit(P,drop(reverse(B))))).
  resolvePath(localRsrc(_),localRsrc(absPath(P))) => localRsrc(absPath(P)).
  resolvePath(localRsrc(absPath(B)),localRsrc(relPath(P))) => localRsrc(absPath(edit(P,drop(reverse(B))))).

  edit: (list[string],list[string]) => list[string].
  edit([".",..Segs],R) => edit(Segs,R).
  edit(["..",..Segs],[_,..R]) => edit(Segs,R).
  edit(Segs,R) => reverse(R)<>Segs.

  public
  implementation display[uri] => {
    disp(absUri(Scheme,Rsrc,Query)) => ssSeq([ss(Scheme),ss(":"),dispRsrc(Rsrc),dispQuery(Query)]).
    disp(relUri(Rsrc,Query)) => ssSeq([dispRsrc(Rsrc),dispQuery(Query)]).

    private dispQuery:(query)=>ss.
    dispQuery(noQ) => ssSeq([]).
    dispQuery(qry(Q)) => ssSeq([ss("?"),ss(Q)]).
  }

  dispRsrc:(rsrcName)=>ss.
  dispRsrc(netRsrc(H,P)) => ssSeq([dispAuthority(H),dispPath(P)]).
  dispRsrc(localRsrc(P)) => dispPath(P).

  dispAuthority:(authority)=>ss.
  dispAuthority(server(none,H)) => dispHost(H).
  dispAuthority(server(some(U),H)) => ssSeq([dispUser(U),ss("@"),dispHost(H)]).

  dispUser:(userInfo)=>ss.
  dispUser(user(U)) => ss(U).

  dispHost:(host) => ss.
  dispHost(hostPort(H,P)) => ssSeq([ss(H),ss(":"),ss(P)]).
  dispHost(host(H)) => ss(H).

  dispPath:(resourcePath)=>ss.
  dispPath(absPath(Segs)) => ssSeq([ss("/"),..dispSegs(Segs)]).
  dispPath(relPath(Segs)) => ssSeq(dispSegs(Segs)).

  dispSegs:(list[string]) => list[ss].
  dispSegs([]) => [].
  dispSegs([S]) => [ss(S)].
  dispSegs([S,..M]) => [ss(S),ss("/"),..dispSegs(M)].

  public
  getUriPath:(uri)=>string.
  getUriPath(absUri(_,Pth,_)) => formatSS(dispRsrc(Pth)).
  getUriPath(relUri(Pth,_)) => formatSS(dispRsrc(Pth)).

  public implementation coercion[uri,string] => {
    _coerce(U) => formatSS(disp(U)).
  }
}
