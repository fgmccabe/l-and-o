lo.sets {
  import lo.core.
  import lo.index.
  import lo.list.
  import lo.collection.
  import lo.coerce.

  public type all e ~~ /* equality[k] |: */ set[e] ::= set(map[e,()]).

  public nullSet:all e ~~ equality[e] |: set[e].
  nullSet = set([]).

  public implementation all e ~~ equality[e] |: membership[set[e]->>e] <= {
    empty = nullSet.
    addMem(set(S),E) => set(S[E->()]).
    delMem(set(S),E) => set(S[\+E]).
    pick(set(M1),k) :- k in keys(M1).
  }

  public implementation all e ~~ equality[e] |: setops[set[e]->>e] <= {
    union(set(M1),set(M2)) => set(M1+M2).
    intersect(set(M1),set(M2)) => set(foldMap(M1,binApp(M2),[])).
    difference(set(M1),set(M2)) => set(M1-M2).
  }

  private type all k ~~ equality[k] |: binApp[k] <~ { apply:(k,(),map[k,()])=>map[k,()] }.
  private binApp:all k ~~ equality[k] |: (map[k,()]) <=> binApp[k].
  binApp(O) <= {
    apply(k,_,S) => S[k->()] :- present(O,k,_).
    apply(_,_,S) => S.
  }

  public implementation all e ~~ equality[e] |: coercion[set[e],list[e]] <= {
    _coerce(set(Els)) => keys(Els).
  }
}