lo.sets {
  import lo.core.
  import lo.index.
  import lo.list.
  import lo.collection.
  import lo.coerce.

  public type all e ~~ /* equality[k] |: */ set[e] ::= set(map[e,()]).

  public nullSet:all e ~~ equality[e] |: set[e].
  nullSet = set([]).

  public implementation all e ~~ equality[e] |: membership[set[e]->>e] <= {
    empty = nullSet.
    addMem(set(S),E) => set(S[E->()]).
    delMem(set(S),E) => set(S[\+E]).
    pick(set(M1),k) :- k in keys(M1).
  }

  public implementation all e ~~ equality[e] |: setops[set[e]->>e] <= {
    union(S1,S2) => setUnion(S1,S2).
    intersect(S1,S2) => setIntersection(S1,S2).
    difference(S1,S2) => setDifference(S1,S2).
  }

  private type all k ~~ equality[k] |: binApp[k] <~ { apply:(k,(),map[k,()])=>map[k,()] }.
  private binApp:all k ~~ equality[k] |: (map[k,()]) <=> binApp[k].
  binApp(O) <= {
    apply(k,_,S) => S[k->()] :- present(O,k,_).
    apply(_,_,S) => S.
  }

  public implementation all e ~~ equality[e] |: coercion[set[e],list[e]] <= {
    _coerce(set(Els)) => keys(Els).
  }

  public implementation all e ~~ equality[e] |: additive[set[e]] <= {
    S1+S2 => setUnion(S1,S2).
    S1-S2 => setDifference(S1,S2).
  }

  private setUnion:all e ~~ equality[e] |: (set[e],set[e]) => set[e].
  setUnion(set(M1),set(M2)) => set(M1+M2).

  private setDifference:all e ~~ equality[e] |: (set[e],set[e]) => set[e].
  setDifference(set(M1),set(M2)) => set(M1-M2).

  private setIntersection:all e ~~ equality[e] |: (set[e],set[e]) => set[e].
  setIntersection(set(M1),set(M2)) =>  set(foldMap(M1,binApp(M2),[])).

  public implementation all e,f ~~ equality[e], equality[f] |: mapping[set->>e,f] <= {
    S // F => setMap(S,F).
  }

  public setMap:all e,f ~~ equality[e],equality[f] |: (set[e],(e)=>f)=>set[f].
  setMap(set(Els),F) => foldF(F,nullSet,keys(Els)). -- not elegant without lambdas

  private foldF:all e,f ~~ equality[e], equality[f] |: ((e)=>f,set[f],list[e]) => set[f].
  foldF(_,S,[]) => S.
  foldF(F,S,[e,..l]) => foldF(F,addMem(S,F(e)),l).

  public implementation all e ~~ folding[set[e]->>e] <= {
    foldRight(F,X,S) => foldRightEls(F,X,S::list[e]).
    foldLeft(F,X,S) => foldLeftEls(F,X,S::list[e]).
  }

  private foldLeftEls:all f,e,x ~~ ((x,e)=>x,x,list[e]) => x.
  foldLeftEls(F,X,S) => foldLeft(F,X,S).

  private foldRightEls:all f,e,x ~~ ((e,x)=>x,x,list[e]) => x.
  foldRightEls(F,X,S) => foldRight(F,X,S).

}
