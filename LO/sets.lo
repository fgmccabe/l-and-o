lo.sets {
  import lo.index.
  import lo.collection.

  public contract all k,e ~~ setops[k->>e] .. {
    union : (k,k)=>k.
    intersect : (k,k)=>k.
    difference : (k,k)=>k.
    pick: (k,e){}.
    empty: k.
  }.

  public type all e ~~ /* equality[k] |: */ set[e] ::= set(map[e,()]).

  public implementation all e ~~ equality[e] |: setops[set[e]] .. {
    union(set(M1),set(M2)) => set(M1+M2).
    intersect(set[M1],set[M2]) => set(foldMap(M1,binApp(M2),{})).
  }

  private type all k ~~ equality[k] |: binApp[k] <~ { apply:(k,(),map[k,()])=>map[k,()] }.
  private binApp:all k,u ~~ equality[k] |: (map[k,()]) <=> binApp[k];
  binApp(O) .. {
    apply(k,_,S) => S+{k->()} :- present(O,k,_).
    apply(_,_,S) => S.
  }
}