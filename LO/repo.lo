lo.repo {
  import lo.

  /*
   * Public contract and API for repository access
   */

  public type pkg ::= pkg(string,version).

  public type version ::= defltVersion | vers(string).

  public contract all r ~~ repository[r] <~ {
    packagePresent:(r,pkg,string){}.

    addToRepo:(r,pkg,string,list[integer]) => r.

    loadFromRepo:(r,pkg,string,version,list[integer]){}.
  }

  public implementation equality[pkg] <= {
    P1 == P2 :- samePackage(P1,P2).
    hash(P) => packageHash(P).
  }

  public implementation display[pkg] <= {
    disp(pkg(P,defltVersion)) => ss(P).
    disp(pkg(P,vers(V))) => ssSeq([ss(P),ss("#"),ss(V)]).
  }

  public implementation display[version] <= {
    disp(defltVersion) => ss("*").
    disp(vers(V)) => ss(V).
  }

  public implementation coercion[pkg,string] <= {
    _coerce(pkg(P,defltVersion)) => P.
    _coerce(pkg(P,vers(V))) => P+"#"+V.
  }

  samePackage:(pkg,pkg){}.
  samePackage(pkg(P1,V1),pkg(P2,V2)) :- P1=P2, V1=V2.

  packageHash:(pkg)=>integer.
  packageHash(pkg(P,defltVersion)) => hash(P).
  packageHash(pkg(P,vers(V))) => hash(P)*47+hash(V).
}
