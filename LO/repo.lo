lo.repo {
  import lo.
  import lo.json.

  /*
   * Public contract and API for repository access
   */

  public type pkg ::= pkg(string,version).

  public type version ::= defltVersion | vers(string).

  public contract all r ~~ repository[r] <~ {
    packagePresent:(r,pkg,string){}.

    loadFromRepo:(r,pkg,string,string){}.
  }

  public implementation all a,b ~~ repository[a], repository[b] |: repository[(a,b)] <= {
    packagePresent(C,P,K) :- comboPkgPrsnt(C,P,K).

    loadFromRepo(C,P,K,Txt) :- comboLoad(C,P,K,Txt).
  }

  comboPkgPrsnt:all a,b ~~ repository[a], repository[b] |: ((a,b),pkg,string){}.
  comboPkgPrsnt((A,_),P,K) :- packagePresent(A,P,K).
  comboPkgPrsnt((_,B),P,K) :- packagePresent(B,P,K).

  comboLoad:all a,b ~~ repository[a], repository[b] |: ((a,b),pkg,string,string){}.
  comboLoad((A,B),P,K,Txt) :- (packagePresent(A,P,K) ?
    loadFromRepo(A,P,K,Txt) |
    loadFromRepo(B,P,K,Txt)).

  public type coreRepo <~ {}.

  public coreRepo:coreRepo.

  public implementation repository[coreRepo] <= {
    packagePresent(_,pkg(P,defltVersion),K) :- _pkg_is_present(P,"*",K,_).
    packagePresent(_,pkg(P,vers(V)),K) :- _pkg_is_present(P,V,K,_).

    loadFromRepo(_,pkg(P,defltVersion),K,V,_get_file(Fn)) :-
      _pkg_is_present(P,"*",K,Txt,Fn).
    loadFromRepo(_,pkg(P,vers(V)),K,V,_get_file(Fn)) :-
      _pkg_is_present(P,V,K,Fn).
  }

  public implementation equality[pkg] <= {
    P1 == P2 :- samePackage(P1,P2).
    hash(P) => packageHash(P).
  }

  public implementation display[pkg] <= {
    disp(pkg(P,defltVersion)) => ss(P).
    disp(pkg(P,vers(V))) => ssSeq([ss(P),ss("#"),ss(V)]).
  }

  public implementation display[version] <= {
    disp(defltVersion) => ss("*").
    disp(vers(V)) => ss(V).
  }

  public implementation coercion[pkg,string] <= {
    _coerce(pkg(P,defltVersion)) => P.
    _coerce(pkg(P,vers(V))) => P+"#"+V.
  }

  samePackage:(pkg,pkg){}.
  samePackage(pkg(P1,V1),pkg(P2,V2)) :- P1=P2, V1=V2.

  packageHash:(pkg)=>integer.
  packageHash(pkg(P,defltVersion)) => hash(P).
  packageHash(pkg(P,vers(V))) => hash(P)*47+hash(V).

  public parsePkgName:(string)=>pkg.
  parsePkgName(P) => pkg(Nm,vers(V)) :-
    _str_find(P,"#",0,Pos),
    _str_split(P,Pos,Nm,_),
    _str_split(P,Pos+1,_,V).
  parsePkgName(P) => pkg(P,defltVersion).
}
