lo.arith{
  import lo.core.
  import lo.display.

  -- Implement regular arithmetic functions

  public (+):all t<~additive ~~ (t+,t+)=>t.
  x+y => x.pl(y).

  public (*):all t<~arith ~~ (t+,t+)=>t.
  x*y => x.tms(y).

  public (-):all t<~additive ~~ (t+,t+)=>t.
  x-y => x.mns(y).

  public (/):all t<~arith ~~ (t+,t+)=>t.
  x/y => x.dv(y).

  public (%):all t<~arith ~~ (t+,t+)=>t.
  x%y => x.md(y).

  -- Implement regular comparison predicates

  public (<):all t<~comp ~~ (t+,t+){}.
  X < Y :- X.lt(Y).

  public (=<):all t<~comp ~~ (t+,t+){}.
  X =< Y :- Y.ge(X).

  public (>):all t<~comp ~~ (t+,t+){}.
  X > Y :- Y.lt(X).

  public (>=):all t<~comp ~~ (t+,t+){}.
  X >= Y :- X.ge(Y).

  public min:all t<~comp ~~ (t+,t+)=>t.
  min(X,Y)::X<Y => X.
  min(_,Y) => Y.

  public (==):all t<~equality ~~ (t+,t+){}.
  X == Y :- X.eq(Y).

  public (\==):all t<~equality ~~ (t+,t+){}.
  X \== Y :- \+X.eq(Y).

  -- bitewise operators
  public (.|.) : (integer,integer) => integer.
  X .|. Y => _bor(X,Y).

  public (.&.) : (integer,integer) => integer.
  X .&. Y => _band(X,Y).

  public (.^.) : (integer,integer) => integer.
  X .^. Y => _bxor(X,Y).

  public (.<<.) : (integer,integer) => integer.
  X .<<. Y => _blsl(X,Y).

  public (.>>.) : (integer,integer) => integer.
  X .>>. Y => _blsr(X,Y).

  public (.>>>.) : (integer,integer) => integer.
  X .>>>. Y => _basr(X,Y).

  public (.~.) : (integer) => integer.
  .~. X => _bnot(X).

  public intDisp : display[integer].
  intDisp .. {
    display(Ix) => Ix.disp().
  }.

  public fltDisp : display[float].
  fltDisp .. {
    display(Dx) => Dx.disp().
  }
}