lo.index{
  -- Implement an index tree structure

  import lo.core.
  import lo.list.
  import lo.collection.

  public
  contract all m,k,v ~~ /*equality[k] |: */ map[m ->> k,v] <~ {
      present:(m,k,v){}.
      remove:(m,k) => m.
      _put:(m,k,v) => m.
      keys:(m) => list[k].
      pairs:(m) => list[(k,v)].
      _empty:m.
    }.

  public
  type all k,v ~~ /* equality[k] |: */map[k,v] ::= 
      trEmpty
    | trLeaf(integer,list[(k,v)])
    | trNode(integer,integer,map[k,v],map[k,v]).

  public
  implementation all k,v ~~ equality[k] |: map[map[k,v] ->> k,v] .. {
    present(M,K,V) :- lookIn(hash(K),M,K,V).
    remove(M,K) => rmve(hash(K),K,M).
    _put(M,K,V) => insrt(K,V,M).
    keys(M) => keyMap(M,[]).
    pairs(M) => mapPairs(M,[]).
    _empty = trEmpty.
  }

  public
  implementation all k,v ~~ equality[k] |: additive[map[k,v]] .. {
    M1+M2 => mergeTree(M1,M2).
    M1-M2 => subtractTree(M1,M2).
  }

  public find:all m,k,v ~~ equality[k], map[m->>k,v] |: (m,k) => v.
  find(M,K) => V :- present(M,K,V).

  public foldMap:all m,k,v,f,u ~~ f <~ { apply:(k,v,u)=>u} |: (map[k,v],f,u) => u.
  foldMap(trLeaf(_,Els),f,u) => foldLeafs(Els,f,u).
  foldMap(trNode(_,_,Left,Right),f,u) => foldMap(Right,f,foldMap(Right,f,u)).

  foldLeafs:all m,k,v,f,u ~~ f <~ { apply:(k,v,u)=>u} |: (list[(k,v)],f,u) => u.
  foldLeafs([],_,u)=>u.
  foldLeafs([(k,v),..l],f,u) => foldLeafs(l,f,f.apply(k,v,u)).

  lookIn: all k,v ~~ equality[k] |: (integer,map[k,v],k,v){}.
  lookIn(H,trLeaf(H,Els),K,V) :- findMember(K,Els,V).
  lookIn(H,trNode(Msk,Ln,Left,Right),K,V) :- 
    commonMask(H,Ln)==Msk,
    (nthBit(H,Ln) ? lookIn(H,Right,K,V) | lookIn(H,Left,K,V)).

  look: all k,v ~~ equality[k] |: (k,map[k,v]) => option[v].
  look(K,T) => some(V) :- lookIn(hash(K),T,K,V).
  look(_,_) => none.

  findMember:all k,v ~~ equality[k] |: (k,list[(k,v)],v){}.
  findMember(K,[(Ky,V),.._],V) :- K==Ky.
  findMember(K,[_,..L],V) :- findMember(K,L,V).

  insrt:all k,v ~~ equality[k] |: (k,v,map[k,v])=>map[k,v].
  insrt(K,V,T) => mergeTree(T,trLeaf(hash(K),[(K,V)])).

  mergeTree:all k,v ~~ equality[k] |: (map[k,v],map[k,v])=>map[k,v].
  mergeTree(trEmpty,T) => T.
  mergeTree(T,trEmpty) => T.
  mergeTree(T1,T2) => mergeNodes(T1,T2).

  mergeLeafs:all k,v ~~ equality[k] |: (map[k,v],map[k,v])=>map[k,v].
  mergeLeafs(trLeaf(H,L1),trLeaf(H,L2)) => trLeaf(H,merge(L1,L2)).
  mergeLeafs(T1,T2) =>
      (nthBit(H1,CML) ? trNode(CM,CML,T2,T1) | trNode(CM,CML,T1,T2)) :-
      T1 = trLeaf(H1,L1),
      T2=trLeaf(H2,L2),
      CML = commonMaskLen(H1,H2,HashLen),
      CM = commonMask(H1,CML).

  merge: all k,v ~~ equality[k] |: (list[(k,v)],list[(k,v)])=>list[(k,v)].
  merge([],L) => L.
  merge([(K,V),..L1],L) => merge(L1,L) :- isMember((K,_),L).
  merge([E,..L],L1) => [E,..merge(L,L1)].

  mergeNodes:all k,v ~~ equality[k] |: (map[k,v],map[k,v])=>map[k,v].
  mergeNodes(T1,T2) => mergeLeafs(T1,T2) :- T1=trLeaf(_,_), T2=trLeaf(_,_).
  mergeNodes(T1,T2) =>
      (CML<Ln1 ?
        ( nthBit(Msk2,CML) ?
          trNode(CM,CML,T1,T2) |
          trNode(CM,CML,T2,T1))  |
        ( nthBit(Msk2,CML) ?
          trNode(CM,CML,L1,mergeNodes(R1,T2)) |
          trNode(CM,CML,mergeNodes(L1,T2),R1))) :-
      T1=trNode(Msk1,Ln1,L1,R1),
      T2=trLeaf(Msk2,_),
      CML = min(commonMaskLen(Msk1,Msk2,HashLen),Ln1),
      CM = commonMask(Msk1,CML).
  mergeNodes(T1, T2) =>
      (CML < Ln2 ?
        ( nthBit(Msk1,CML) ?
          trNode(CM,CML,T1,T2) |
          trNode(CM,CML,T2,T1))  |
        ( nthBit(Msk1,CML) ?
          trNode(CM,CML,L2,mergeNodes(R2,T1)) |
          trNode(CM,CML,mergeNodes(L2,T1),R2)
          )) :-  
      T1=trLeaf(Msk1,_),
      T2=trNode(Msk2,Ln2,L2,R2),
      CML = min(commonMaskLen(Msk1,Msk2,HashLen),Ln2),
      CM = commonMask(Msk2,CML).
  mergeNodes(T1,T2) =>
      (CML < Ln1 ?
        (nthBit(Msk2,CML) ?
          trNode(CM,CML,L1,mergeNodes(R1,T2)) |
          trNode(CM,CML,mergeNodes(L1,T2),R1))  |
      CML < Ln2 ?
        (nthBit(Msk1,CML) ?
          trNode(CM,CML,L2,mergeNodes(T1,R2)) |
          trNode(CM,CML,mergeNodes(L2,T1),R2))  |
        trNode(CM,CML,mergeNodes(L1,L2),mergeNodes(R1,R2))
      ) :-
      T1=trNode(Msk1,Ln1,L1,R1),
      T2=trNode(Msk2,Ln2,L2,R2),
      CML = min(min(commonMaskLen(Msk1,Msk2,HashLen),Ln1),Ln2),
      CM = commonMask(Msk1,CML).

  rmve:all k,v ~~ equality[k] |: (integer,k,map[k,v]) => map[k,v].
  rmve(_,_,trEmpty) => trEmpty.
  rmve(H,K,trLeaf(H,L)) => reformLeaf(H,subtract((K,_),L)).
  rmve(H,K,T) =>
    ( CM = M ?
      ( nthBit(H,Ln) ?
        reformNode(trNode(M,Ln,L,rmve(H,K,R))) |
        reformNode(trNode(M,Ln,rmve(H,K,L),R))
      ) |  -- not present
      T) :-
    T=trNode(M,Ln,L,R),
    CM = commonMask(H,Ln).

  reformLeaf:all  k,v ~~ equality[k] |: (integer,list[(k,v)]) => map[k,v].
  reformLeaf(H,[]) => trEmpty.
  reformLeaf(H,L) => trLeaf(H,L).

  reformNode:all k,v ~~ equality[k] |: (map[k,v]) => map[k,v].
  reformNode(trNode(_,_,trEmpty,R)) => R.
  reformNode(trNode(_,_,L,trEmpty)) => L.
  reformNode(N) => N.

  subtractTree:all k,v ~~ equality[k] |: (map[k,v],map[k,v])=>map[k,v].
  subtractTree(trEmpty,T) => T.
  subtractTree(T,trEmpty) => T.
  subtractTree(T1,T2) => subtractNodes(T1,T2).

  subtractNodes:all k,v ~~ equality[k] |: (map[k,v],map[k,v])=>map[k,v].
  subtractNodes(T1,trLeaf(_,Leaves)) => subtractLeafs(T1,Leaves).
  subtractNodes(T1,trNode(Msk2,Ln2,L2,R2)) =>
    subtractNodes(subtractNodes(T1,L2),R2).

  subtractLeafs:all k,v ~~ equality[k] |: (map[k,v],list[(k,v)])=>map[k,v].
  subtractLeafs(T,[]) => T.
  subtractLeafs(T,[(K,_),..Lvs]) =>
    subtractLeafs(rmve(hash(K),K,T),Lvs).

  private keyMap:all k,v ~~ (map[k,v],list[k]) => list[k].
  keyMap(trEmpty,L) => L.
  keyMap(trLeaf(_,Leaves),L) => leafKeys(Leaves,L).
  keyMap(trNode(_,_,Lf,Rg),L) => keyMap(Rg,keyMap(Lf,L)).

  private leafKeys:all k,v ~~ (list[(k,v)],list[k]) => list[k].
  leafKeys([],L) => L.
  leafKeys([(K1,V1),..M],L) => leafKeys(M,[K1,..L]).

  private mapPairs:all k,v ~~ (map[k,v],list[(k,v)]) => list[(k,v)].
  mapPairs(trEmpty,L) => L.
  mapPairs(trLeaf(_,Lf),L) => Lf<>L.
  mapPairs(trNode(_,_,Lf,Rg),L) => mapPairs(Rg,mapPairs(Lf,L)).

  public
  implementation all k,v ~~ display[k], display[v] |: display[map[k,v]] .. {
    disp(Tree) => ssSeq([ss("{"),displayElements(Tree),ss("}")]).
  }

  displayElements:all k,v ~~ display[k], display[v] |: (map[k,v]) => ss.
  displayElements(trEmpty) => ssSeq([]).
  displayElements(trLeaf(_,Lvs)) => ssSeq(displayLeaves(Lvs)).
  displayElements(trNode(_,_,Lft,Rgt)) => ssSeq([displayElements(Lft),displayElements(Rgt)]).

  displayLeaves:all k,v ~~ display[k], display[v] |: (list[(k,v)]) => list[ss].
  displayLeaves([]) => [].
  displayLeaves([(K,V),..More]) => [disp(K),ss("->"),disp(V),ss(". "),..displayLeaves(More)].

  HashLen:integer.
  HashLen = 64.
      
  commonMaskLen:(integer,integer,integer) => integer.
  commonMaskLen(H1,H2,C) => commonMaskLen(_blsr(H1,1),_blsr(H2,1),C-1) :- 
    C>0, \+H1==H2.
  commonMaskLen(_,_,C) => C.

  commonMask:(integer,integer)=>integer.
  commonMask(_,0) => 0.
  commonMask(M1,ML) => _band(_blsl(_blsr(-1,CML),CML),M1) :-
     CML=HashLen-ML.

  nthBit:(integer,integer){}.
  nthBit(X,N) :- _nthb(X,63-N).
}