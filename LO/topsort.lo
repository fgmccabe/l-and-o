lo.topsort{
  import lo.

  public contract all e,t ~~ depends[t ->> e] .. {
    defines:(t,e){}.
    references:(t) => list[e].
  }

  public
  topsort:all e,t ~~ depends[t->>e] |: (list[t]) => list[list[t]].
  topsort(Defs) => reverse(analyseDefs(Defs,[])).

  analyseDefs:all e,t ~~ depends[t->>e] |: (list[t],list[list[t]]) => list[list[t]].
  analyseDefs([],Groups) => Groups.
  analyseDefs([Def,..Defs],Grps) => analyseDefs(IDefs,G0) :- 
    analyseDef(Def,Defs,IDefs,[],_,Grps,G0,_).

  analyseDef:all e,t ~~ depends[t->>e] |: 
      (t,list[t],list[t],list[(t,integer)],list[(t,integer)],list[list[t]],list[list[t]],integer){}.
  analyseDef(Df,Defs,ODefs,Stack,OStack,G,OG,Pt) :-
    pushDef(Df,Stack,S0,SPt),
    analyseRefs(references(Df),Defs,ODefs,S0,S1,G,G1,SPt,Pt),
    popGroups(S1,OStack,G1,OG,SPt,Pt).

  analyseRefs:all e,t ~~ depends[t->>e] |: 
      (list[e],list[t],list[t],list[(t,integer)],list[(t,integer)],list[list[t]],list[list[t]],integer,integer){}.
  analyseRefs([],Defs,Defs,Stk,Stk,Grp,Grp,Pt,Pt).
  analyseRefs([R,..Refs],Defs,ODefs,Stk,OStk,G,G1,Low,Pt) :-
    analyse(R,Defs,IDefs,Stk,S1,G,G0,Low,Low1),
    analyseRefs(Refs,IDefs,ODefs,S1,OStk,G0,G1,Low1,Pt).

  analyse:all e,t ~~ depends[t->>e] |: 
      (e,list[t],list[t],list[(t,integer)],list[(t,integer)],list[list[t]],list[list[t]],integer,integer){}.
  analyse(Rf,Defs,Defs,Stk,Stk,G,G,Low,Pt) :-
    inStack(Rf,Stk,X),
    minPoint(X,Low,Pt).
  analyse(Rf,Defs,ODefs,Stack,OStack,G,OG,Low,Pt) :- 
    pickDef(Rf,Defs,RDefs,Df), 
    analyseDef(Df,RDefs,ODefs,Stack,OStack,G,OG,DfPt),
    minPoint(Low,DfPt,Pt).
  analyse(_,Defs,Defs,Stack,Stack,Groups,Groups,Low,Low).

  pushDef:all e,t ~~ depends[t->>e] |: (t,list[(t,integer)],list[(t,integer)],integer){}.
  pushDef(D,Stk,[(D,Pt),..Stk],Pt) :-
    Pt = length(Stk).

  inStack:all e,t ~~ depends[t->>e] |: (e,list[(t,integer)],integer){}.
  inStack(Rf,[(D,Pt),.._],Pt) :-
    defines(D,Rf).
  inStack(Rf,[_,..Stk],Pt) :-
    inStack(Rf,Stk,Pt).

  pickDef:all e,t ~~ depends[t->>e] |: (e,list[t],list[t],t){}.
  pickDef(R,[D,..Dfs],Dfs,D) :- defines(D,R).
  pickDef(R,[D,..Dfs],[D,..ODfs],Df) :- pickDef(R,Dfs,ODfs,Df).

  popGroups:all e,t ~~ depends[t->>e] |: 
      (list[(t,integer)],list[(t,integer)],list[list[t]],list[list[t]],integer,integer){}.
  popGroups(Stk,Stk,Grps,Grps,Low,Pt) :- Low<Pt.
  popGroups(Stk,OStk,Grps,mkGroup(Group,Grps),Low,Pt) :-
    popGroup(Stk,OStk,Group,Pt).

  popGroup:all e,t ~~ depends[t->>e] |: (list[(t,integer)],list[(t,integer)],list[t],integer){}.
  popGroup([(D,DPt),..Stk],OStk,[D,..Dfs],Low) :- DPt >= Low,
    popGroup(Stk,OStk,Dfs,Low).
  popGroup(Stk,Stk,[],_).

  mkGroup:all e ~~ (list[e],list[list[e]]) => list[list[e]].
  mkGroup([],Grps) => Grps.
  mkGroup(G,Grps) => [G,..Grps].

  minPoint:(integer,integer,integer){}.
  minPoint(X,Y,X) :- X =< Y.
  minPoint(X,Y,Y) :- X>Y.
}