lo.list{
  -- implement standard list functions
  import lo.core.
  import lo.collection.
  import lo.coerce.

  public (<>):all t ~~ (list[t],list[t])=>list[t].
  [] <> X => X.
  [E,..X] <> Y => [E,..X<>Y].

  public listEl:all t ~~ (t,list[t]){}.
  listEl(X,[X,.._]).
  listEl(X,[_,..Y]) :- listEl(X,Y).

  public merge:all t ~~ (list[t],list[t]) => list[t].
  merge([],X) => X.
  merge([e,..l],x) => merge(l,x) :- listEl(e,x).
  merge([e,..l],x) => [e,..merge(l,x)].

  public multiCat:all x ~~ (list[list[x]]) => list[x].
  multiCat([]) => [].
  multiCat([E,..L]) => cat(E,L).

  cat:all x ~~ (list[x], list[list[x]]) => list[x].
  cat([],M) => multiCat(M).
  cat([E,..L],M) => [E,..cat(L,M)].

  public reverse:all t ~~ (list[t]) => list[t].
  reverse(X) => rev(X,[]).

  private
  rev:all t ~~ (list[t],list[t]) => list[t].
  rev([],R) => R.
  rev([E,..L],R) => rev(L,[E,..R]).

  public drop:all t ~~ (list[t]) => list[t].
  drop([_,..L]) => L.

  public subtract:all t ~~ (t,list[t])=>list[t].
  subtract(_,[]) => [].
  subtract(E,[E,..R]) => R.
  subtract(E,[X,..R]) => [X,..subtract(E,R)] :- E\=X.

  public
  length:all t ~~ (list[t]) => integer.
  length([]) => 0.
  length([_,..L]) => length(L)+1.

  public implementation all c ~~ sizeable[list[c]] <= {
    size(L) => length(L).
    isEmpty([]).
  }

  public implementation all e ~~ folding[list[e]->>e] <= {
    foldLeft(f,x,[]) => x.
    foldLeft(f,x,[e,..l]) => foldLeft(f,f(x,e),l).

    foldRight(f,x,[]) => x.
    foldRight(f,x,[e,..l]) => f(e,foldRight(f,x,l)).
  }

  public implementation all e,f ~~ mapping[list->>e,f] <= {
    L//F => mapList(L,F).
  }

  public mapList:all v,w ~~ (list[v],((v)=>w)) => list[w].
  mapList([],_) => [].
  mapList([e,..l],f) => [f(e),..mapList(l,f)].

  public implementation all e ~~ filter[list[e]->>e] <= {
    L^/P => filterList(L,P).
  }

  filterList:all e ~~ (list[e],(e){})=>list[e].
  filterList([],_) => [].
  filterList([e,..l],p) => [e,..filterList(l,p)] :- p(e).
  filterList([_,..l],p) => filterList(l,p).

  public implementation all e,f ~~ coercion[e,f] |: coercion[list[e],list[f]] <= {
    _coerce(Sx) => coerceList(Sx).
  }

  coerceList:all e,f ~~ coercion[e,f] |: (list[e]) => list[f].
  coerceList([]) => [].
  coerceList([e,..l]) => [_coerce(e),..coerceList(l)].

  public implementation all e ~~ map[list[e] ->> integer,e] <= {
    present(L,Ix,V) :- nthEl(L,Ix,V)!.
    _remove(L,Ix) => dropNth(L,Ix).
    _put = replaceNth.
    keys(L) => indexes(L,0).
    pairs(L) => listPairs(L,0).
    values(L) => L.
    _empty = [].
  }

  public implementation all e ~~ membership[list[e] ->> e] <= {
    empty = [].
    addMem(L,e) => [e,..L].
    delMem(L,e) => subtract(e,L).
    e in L :- listEl(e,L).
  }

  public nthEl:all e ~~ (list[e],integer,e){}.
  nthEl([e,.._],0,e).
  nthEl([_,..L],Ix,e) :- Ix>0, nthEl(L,Ix-1,e).

  private dropNth:all e ~~ (list[e],integer) => list[e].
  dropNth([],_) => [].
  dropNth([_,..L],0) => L.
  dropNth([E,..L],Ix) => [E,..dropNth(L,Ix-1)] :- Ix>0.

  private replaceNth:all e ~~ (list[e],integer,e) => list[e].
  replaceNth([_,..L],0,e) => [e,..L].
  replaceNth([],0,e) => [e].
  replaceNth([E,..L],Ix,e) => [E,..replaceNth(L,Ix-1,e)] :- Ix>0.

  public lastEl:all e ~~ (list[e],e){}.
  lastEl([X],X).
  lastEl([_,..L],X) :- lastEl(L,X).

  public dropLast:all e ~~ (list[e],list[e]){}.
  dropLast([_],[]).
  dropLast([E,..L],[E,..R]) :- dropLast(L,R).

  private indexes:all e ~~ (list[e],integer) => list[integer].
  indexes([],_) => [].
  indexes([_,..L],Ix) => [Ix,..indexes(L,Ix+1)].

  private listPairs:all e ~~ (list[e],integer) => list[(integer,e)].
  listPairs([],_) => [].
  listPairs([E,..L],Ix) => [(Ix,E),..listPairs(L,Ix+1)].

  public interleave:all x~~(list[x],x) => list[x].
  interleave([],_)=>[].
  interleave([F,..L],S)=>[F,..mixin(L,S)].

  private mixin:all x~~(list[x],x)=>list[x].
  mixin([],_)=>[].
  mixin([F,..L],S) =>[S,F,..mixin(L,S)].

  public zip: all e,f ~~ (list[e],list[f]) => list[(e,f)].
  zip([],_) => [].
  zip(_,[]) => [].
  zip([e1,..l1],[e2,..l2]) => [(e1,e2),..zip(l1,l2)].

  public unzip: all e,f ~~ (list[(e,f)],list[e],list[f]){}.
  unzip([],[],[]).
  unzip([(e,f),..l],[e,..r1],[f,..r2]) :- unzip(l,r1,r2).

  public iota:(integer,integer)=>list[integer].
  iota(F,T) => [] :- F>T.
  iota(F,T) => [F,..iota(F+1,T)] :- F=<T.

  public head:all e ~~ (list[e]) => e.
  head([E,.._]) => E.

  public tail:all e ~~ (list[e]) => list[e].
  tail([_,..L]) => L.

  public split:all e ~~ (list[e],integer,list[e],e,list[e]){}.
  split([R,..l],0,[],R,l).
  split([e,..l],ix,[e,..f],x,r) :- ix>0, split(l,ix-1,f,x,r).
}
