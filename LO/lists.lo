lo.list{
  -- implement standard list functions
  import lo.core.
  import lo.collection.
  import lo.coerce.

  public (<>):all t ~~ (list[t],list[t])=>list[t].
  [] <> X => X.
  [E,..X] <> Y => [E,..X<>Y].

  public (in):all t ~~ (t,list[t]){}.
  X in [X,.._].
  X in [_,..Y] :- X in Y.

  public merge:all t ~~ (list[t],list[t]) => list[t].
  merge([],X) => X.
  merge([e,..l],x) => merge(l,x) :- e in x.
  merge([e,..l],x) => [e,..merge(l,x)].

  public multiCat:all x ~~ (list[list[x]]) => list[x].
  multiCat([]) => [].
  multiCat([E,..L]) => cat(E,L).

  cat:all x ~~ (list[x], list[list[x]]) => list[x].
  cat([],M) => multiCat(M).
  cat([E,..L],M) => [E,..cat(L,M)].

  public reverse:all t ~~ (list[t]) => list[t].
  reverse(X) => rev(X,[]).

  private
  rev:all t ~~ (list[t],list[t]) => list[t].
  rev([],R) => R.
  rev([E,..L],R) => rev(L,[E,..R]).

  public drop:all t ~~ (list[t]) => list[t].
  drop([_,..L]) => L.

  public isMember:all t ~~ (t,list[t]){}.
  isMember(E,[E,.._]).
  isMember(E,[_,..L]) :- isMember(E,L).

  public subtract:all t ~~ (t,list[t])=>list[t].
  subtract(_,[]) => [].
  subtract(E,[E,..R]) => R.
  subtract(E,[X,..R]) => [E,..subtract(E,R)].

  public
  length:all t ~~ (list[t]) => integer.
  length([]) => 0.
  length([_,..L]) => length(L)+1.

  public implementation all c ~~ sizeable[list[c]] <= {
    size(L) => length(L).
    isEmpty([]).
  }

  public implementation all e ~~ folding[list[e]->>e] <= {
    foldLeft(f,x,[]) => x.
    foldLeft(f,x,[e,..l]) => foldLeft(f,f(x,e),l).

    foldRight(f,x,[]) => x.
    foldRight(f,x,[e,..l]) => f(e,foldRight(f,x,l)).
  }

  public implementation mapping[list] <= {
    L//F => mapList(L,F).
  }

  public mapList:all v,w ~~ (list[v],((v)=>w)) => list[w].
  mapList([],_) => [].
  mapList([e,..l],f) => [f(e),..mapList(l,f)].

  public implementation all e ~~ filter[list[e]->>e] <= {
    L^/P => filterList(L,P).
  }

  filterList:all e ~~ (list[e],(e){})=>list[e].
  filterList([],_) => [].
  filterList([e,..l],p) => [e,..filterList(l,p)] :- p(e).
  filterList([_,..l],p) => filterList(l,p).

  public implementation all e,f ~~ coercion[e,f] |: coercion[list[e],list[f]] <= {
    _coerce(Sx) => coerceList(Sx).
  }

  coerceList:all e,f ~~ coercion[e,f] |: (list[e]) => list[f].
  coerceList([]) => [].
  coerceList([e,..l]) => [_coerce(e),..coerceList(l)].

  public implementation all e ~~ map[list[e] ->> integer,e] <= {
    present(L,Ix,V) :- nthEl(L,Ix,V)!.
    _remove(L,Ix) => dropNth(L,Ix).
    _put = replaceNth.
    keys(L) => indexes(L,0).
    pairs(L) => listPairs(L,0).
    _empty = [].
  }

  public implementation all e ~~ equality[e] |: membership[list[e] ->> e] <= {
    empty = [].
    addMem(L,e) => [e,..L].
    delMem(L,e) => subtract(e,L).
    pick(L,e) :- e in L.
  }

  public nthEl:all e ~~ (list[e],integer,e){}.
  nthEl([e,.._],0,e).
  nthEl([_,..L],Ix,e) :- Ix>0, nthEl(L,Ix-1,e).

  private dropNth:all e ~~ (list[e],integer) => list[e].
  dropNth([],_) => [].
  dropNth([_,..L],0) => L.
  dropNth([E,..L],Ix) => [E,..dropNth(L,Ix-1)] :- Ix>0.

  private replaceNth:all e ~~ (list[e],integer,e) => list[e].
  replaceNth([_,..L],0,e) => [e,..L].
  replaceNth([],0,e) => [e].
  replaceNth([E,..L],Ix,e) => [E,..replaceNth(L,Ix-1,e)] :- Ix>0.

  private indexes:all e ~~ (list[e],integer) => list[integer].
  indexes([],_) => [].
  indexes([_,..L],Ix) => [Ix,..indexes(L,Ix+1)].

  private listPairs:all e ~~ (list[e],integer) => list[(integer,e)].
  listPairs([],_) => [].
  listPairs([E,..L],Ix) => [(Ix,E),..listPairs(L,Ix+1)].

}