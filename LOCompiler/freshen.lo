lo.comp.freshen{
  import lo.
  import lo.comp.misc.
  import lo.comp.types.

  public contract all s ~~ freshen[s] <~ {
    freshen:(s,map[string,tipe]) => (map[string,tipe],s).
    skolemize:(s,map[string,tipe]) =>(map[string,tipe],s).
  }.

  public implementation freshen[tipe] <= {
    freshen(T,M) => freshenType(deRef(T),M).
    skolemize(T,M) => skolemizeType(deRef(T),M).
  }

  private freshenType:(tipe,map[string,tipe]) => (map[string,tipe],tipe).
  freshenType(univType(kVar(Nm),T),B) => freshenType(T,B[Nm->newVar(Nm)]).
  freshenType(univType(kFun(Nm,Ar),T),B) => freshenType(T,B[Nm->newTFun(Nm,Ar)]).
  freshenType(T,B) => (B,frshnType(T,B)).

  private skolemizeType:(tipe,map[string,tipe]) => (map[string,tipe],tipe).
  skolemizeType(univType(kVar(Nm),T),B) => skolemizeType(T,B[Nm->skolem(Nm)]).
  skolemizeType(univType(kFun(Nm,Ar),T),B) => skolemizeType(T,B[Nm->skolemFun(Nm,Ar)]).
  skolemizeType(T,B) => (B,frshnType(T,B)).

  private skolem:(string) => tipe.
  skolem(Nm) => kVar(_str_gen(Nm)).

  private skolemFun:(string,integer) => tipe.
  skolemFun(Nm,Ar) => kFun(_str_gen(Nm),Ar).

  public implementation freshen[constraint] <= {
    freshen(C,B) => freshenConstraint(C,B).
    skolemize(C,B) => skolemizeConstraint(C,B).
  }

  frshnType:(tipe,map[string,tipe]) => tipe.
  frshnType(Tp,M) => frshn(deRef(Tp),M).

  frshn:(tipe,map[string,tipe]) => tipe.
  frshn(anonType,_) => anonType.
  frshn(voidType,_) => voidType.
  frshn(thisType,B) => Tp :- present(B,"this",Tp).
  frshn(thisType,_) => thisType.
  frshn(kVar(Nm),B) => Tp :- present(B,Nm,Tp).
  frshn(kVar(Nm),_) => kVar(Nm).
  frshn(kFun(Nm,_),B) => Tp :- present(B,Nm,Tp).
  frshn(kFun(Nm,Ar),_) => kFun(Nm,Ar).
  frshn(tipe(Nm),_) => tipe(Nm).
  frshn(tpFun(Nm,Ar),_) => tpFun(Nm,Ar).
  frshn(typeExp(Op,A),B) => typeExp(frshnType(Op,B),frshnTypes(A,B)).
  frshn(funType(A,R),B) => funType(frshnType(A,B),frshnType(R,B)).
  frshn(predType(A),B) => predType(frshnType(A,B)).
  frshn(grammarType(A,R),B) => grammarType(frshnType(A,B),frshnType(R,B)).
  frshn(classType(A,R),B) => classType(frshnType(A,B),frshnType(R,B)).
  frshn(tupleType(A),B) => tupleType(frshnTypes(A,B)).
  frshn(faceType(F),B) => faceType(frshnFields(F,B)).
  frshn(univType(kVar(Nm),T),B) => univType(kVar(Nm),frshnType(T,B[\+Nm])).
  frshn(univType(kFun(Nm,Ar),T),B) => univType(kFun(Nm,Ar),frshnType(dT,B[\+Nm])).
  frshn(constrained(T,C),B) => constrained(frshnType(T,B),frshnConstraint(C,B)).
  frshn(typeRule(S,T),B) => typeRule(frshnType(S,B),frshnType(T,B)).
  frshn(Tp,_) => Tp.

  private
  frshnTypes:(list[tipe],map[string,tipe]) => list[tipe].
  frshnTypes([],_) => [].
  frshnTypes([E,..R],B) => [frshnType(E,B),..frshnTypes(R,B)].

  private
  frshnFields:(list[(string,tipe)],map[string,tipe]) => list[(string,tipe)].
  frshnFields([],_) => [].
  frshnFields([(F,E),..R],B) => [(F,frshnType(E,B)),..frshnFields(R,B)].

  private freshenConstraint:(constraint,map[string,tipe]) => (map[string,tipe],constraint).
  freshenConstraint(univCon(kVar(Nm),C),B) => freshenConstraint(C,B[Nm->newVar(Nm)]).
  freshenConstraint(univCon(kFun(Nm,Ar),C),B) => freshenConstraint(C,B[Nm->newTFun(Nm,Ar)]).
  freshenConstraint(C,B) => (B,frshnConstraint(C,B)).

  private skolemizeConstraint:(constraint,map[string,tipe]) => (map[string,tipe],constraint).
  skolemizeConstraint(univCon(kVar(Nm),T),B) => skolemizeConstraint(T,B[Nm->skolem(Nm)]).
  skolemizeConstraint(univCon(kFun(Nm,Ar),T),B) => skolemizeConstraint(T,B[Nm->skolem(Nm)]).
  skolemizeConstraint(T,B) => (B,frshnConstraint(T,B)).

  frshnConstraint:(constraint,map[string,tipe]) => constraint.
  frshnConstraint(conTract(Nm,Args,Deps),B) => conTract(Nm,frshnTypes(Args,B),frshnTypes(Deps,B)).
  frshnConstraint(implementsFace(Tp,Els),B) => implementsFace(frshnType(Tp,B),frshnFields(Els,B)).
  frshnConstraint(conCon(Con,Ext),B) => conCon(frshnConstraint(Con,B),frshnConstraint(Ext,B)).
  frshnConstraint(univCon(kVar(Nm),C),B) => frshnConstraint(C,B[\+Nm]).
  frshnConstraint(univCon(kFun(Nm,_),C),B) => frshnConstraint(C,B[\+Nm]).

  public freezeType:(tipe,map[string,tipe],tipe){}.
  freezeType(Tp,B,FrZ) :-
    freeze(Tp,B,FT),
    reQuant(pairs(B),B,FT,FrZ).

  private freeze:(tipe,map[string,tipe],tipe){}.
  freeze(T,B,Frzn) :-
    frze(deRef(T),B,Frzn)!.

  private frze:(tipe,map[string,tipe],tipe){}.
  frze(voidType,_,voidType).
  frze(anonType,_,anonType).
  frze(thisType,_,thisType).
  frze(kVar(TV),_,kVar(TV)).
  frze(kFun(F,A),_,kFun(F,A)).
  frze(V,B,kVar(TV)) :- isUnbound(V), present(B,TV,VV), isIdenticalVar(V,deRef(VV)).
  frze(V,_,V) :- isUnbound(V).
  frze(tipe(Nm),_,tipe(Nm)).
  frze(tpFun(F,A),_,tpFun(F,A)).
  frze(funType(A,R),B,funType(FA,FR)) :-
    freeze(A,B,FA),
    freeze(R,B,FR).
  frze(grammarType(A,R),B,grammarType(FA,FR)) :-
    freeze(A,B,FA),
    freeze(R,B,FR).
  frze(classType(A,R),B,classType(FA,FR)) :-
    freeze(A,B,FA),
    freeze(R,B,FR).
  frze(predType(A),B,predType(FA)) :- freeze(A,B,FA).
  frze(tupleType(L),B,tupleType(FL)) :- freezeTypes(L,B,FL).
  frze(typeExp(O,A),B,typeExp(FO,FA)) :- frze(O,B,FO),freezeTypes(A,B,FA).
  frze(univType(kVar(V),Tp),B,univType(kVar(V),FTp)) :-
    freeze(Tp,_remove(B,V),FTp).
  frze(faceType(L),B,faceType(FL)) :-
    freezeFields(L,B,FL).
  frze(typeRule(A,R),B,typeRule(FA,FR)) :-
    freeze(A,B,FA),
    freeze(R,B,FR).
  frze(constrained(Tp,Con),B,constrained(FTp,FCon)) :-
    freeze(Tp,B,FTp),
    freezeConstraint(Con,B,FCon).

  freezeFields:(list[(string,tipe)],map[string,tipe],list[(string,tipe)]){}.
  freezeFields([],_,[]).
  freezeFields([(Nm,A),..L],B,[(Nm,FA),..FL]) :- freeze(A,B,FA), freezeFields(L,B,FL).

  freezeTypes:(list[tipe],map[string,tipe],list[tipe]){}.
  freezeTypes([],_,[]).
  freezeTypes([A,..L],B,[FA,..FL]) :- freeze(A,B,FA), freezeTypes(L,B,FL).

  reQuant:(list[(string,tipe)],map[string,tipe],tipe,tipe){}.
  reQuant([],_,T,T).
  reQuant([(_,Tp),..R],BB,FT,FZT) :- 
    V = deRef(Tp), isUnbound(V),
    reQuant(R,BB,FT,FZT).
  reQuant([_,..B],BB,T,FT) :- reQuant(B,BB,T,FT).

  freezeConstraints:(list[constraint],map[string,tipe],tipe,tipe){}.
  freezeConstraints(C,_,T,T) :- var(C)!.
  freezeConstraints([C,.._],_,T,T) :- var(C)!.
  freezeConstraints([C,..R],BB,T,FT) :-
    freezeConstraint(C,BB,FC),
    freezeConstraints(R,BB,constrained(T,FC),FT).

  freezeConstraint:(constraint,map[string,tipe],constraint){}.
  freezeConstraint(conTract(Nm,A,D),B,conTract(Nm,FA,FD)) :-
    freezeTypes(A,B,FA),
    freezeTypes(D,B,FD).
  freezeConstraint(implementsFace(T,F),B,implementsFace(FT,FF)) :-
    freeze(T,B,FT),
    freezeFields(F,B,FF).
}