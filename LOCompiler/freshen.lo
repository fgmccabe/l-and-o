lo.comp.freshen{
  import lo.
  import lo.comp.misc.
  import lo.comp.types.

  public contract all s ~~ freshen[s] <~ {
    freshen:(s,map[string,tipe]) => (map[string,tipe],s).
    skolemize:(s,map[string,tipe]) =>(map[string,tipe],s).
  }.

  public implementation freshen[tipe] .. {
    freshen(T,M) => freshenType(T,M).
    skolemize(T,M) => skolemizeType(T,M).
  }

  private freshenType:(tipe,map[string,tipe]) => (map[string,tipe],tipe).
  freshenType(univType(kVar(Nm),T),B) => freshenType(T,B+[Nm->newVar(Nm)]).
  freshenType(T,B) => (B,frshnType(T,B)).

  private skolemizeType:(tipe,map[string,tipe]) => (map[string,tipe],tipe).
  skolemizeType(univType(kVar(Nm),T),B) => skolemizeType(T,B+[Nm->skolem(Nm)]).
  skolemizeType(T,B) => (B,frshnType(T,B)).

  private skolem:(string) => tipe.
  skolem(Nm) => kVar(_str_gen(Nm)).

  public implementation freshen[constraint] .. {
    freshen(C,B) => freshenConstraint(C,B).
    skolemize(C,B) => skolemizeConstraint(C,B).
  }

  frshnType:(tipe,map[string,tipe]) => tipe.
  frshnType(anonType,_) => anonType.
  frshnType(voidType,_) => voidType.
  frshnType(thisType,B) => Tp :- present(B,"this",Tp).
  frshnType(thisType,_) => thisType.
  frshnType(kVar(Nm),B) => Tp :- present(B,Nm,Tp).
  frshnType(kVar(Nm),_) => kVar(Nm).
  frshnType(V,B) => (var(Curr) ? V | frshnType(Curr,B)) :-  V=tVar(Curr,_,_,_,_).
  frshnType(tipe(Nm),_) => tipe(Nm).
  frshnType(typeExp(Nm,A),B) => typeExp(Nm,frshnTypes(A,B)).
  frshnType(funType(A,R),B) => funType(frshnType(A,B),frshnType(R,B)).
  frshnType(predType(A),B) => predType(frshnType(A,B)).
  frshnType(grammarType(A,R),B) => grammarType(frshnType(A,B),frshnType(R,B)).
  frshnType(classType(A,R),B) => classType(frshnType(A,B),frshnType(R,B)).
  frshnType(tupleType(A),B) => tupleType(frshnTypes(A,B)).
  frshnType(faceType(F),B) => faceType(frshnFields(F,B)).
  frshnType(univType(kVar(Nm),T),B) => univType(NV,frshnType(T,B-[Nm->_])).
  frshnType(constrained(T,C),B) => constrained(frshnType(T,B),frshnConstraint(C,B)).
  frshnType(typeRule(S,T),B) => typeRule(frshnType(S,B),frshnType(T,B)).

  private
  frshnTypes:(list[tipe],map[string,tipe]) => list[tipe].
  frshnTypes([],_) => [].
  frshnTypes([E,..R],B) => [frshnType(E,B),..frshnTypes(R,B)].

  private
  frshnFields:(list[(string,tipe)],map[string,tipe]) => list[(string,tipe)].
  frshnFields([],_) => [].
  frshnFields([(F,E),..R],B) => [(F,frshnType(E,B)),..frshnFields(R,B)].

  private freshenConstraint:(constraint,map[string,tipe]) => (map[string,tipe],constraint).
  freshenConstraint(univCon(kVar(Nm),C),B) => freshenConstraint(C,B+[Nm->newVar(Nm)]).
  freshenConstraint(C,B) => (B,frshnConstraint(C,B)).

  private skolemizeConstraint:(constraint,map[string,tipe]) => (map[string,tipe],constraint).
  skolemizeConstraint(univCon(kVar(Nm),T),B) => skolemizeConstraint(T,B+[Nm->skolem(Nm)]).
  skolemizeConstraint(T,B) => (B,frshnConstraint(T,B)).

  frshnConstraint:(constraint,map[string,tipe]) => constraint.
  frshnConstraint(conTract(Nm,Args,Deps),B) => conTract(Nm,frshnTypes(Args,B),frshnTypes(Deps,B)).
  frshnConstraint(implementsFace(Tp,Els),B) => implementsFace(frshnType(Tp,B),frshnFields(Els,B)).
  frshnConstraint(conRule(Args,C),B) => conRule(frshnConstraints(Args,B),frshnConstraint(C,B)).
  frshnConstraint(univCon(kVar(Nm),C),B) => frshnConstraint(C,B-[Nm->_]).

  private
  frshnConstraints:(list[constraint],map[string,tipe]) => list[constraint].
  frshnConstraints([],_) => [].
  frshnConstraints([C,..R],B) => [frshnConstraint(C,B),..frshnConstraints(R,B)].

  public freezeType:(tipe,map[string,tipe],tipe){}.
  freezeType(Tp,B,FrZ) :-
    freeze(Tp,B,FT),
    reQuant(pairs(B),B,FT,FrZ).

  private freeze:(tipe,map[string,tipe],tipe){}.
  freeze(T,B,Frzn) :-
    frze(deRef(T),B,Frzn)!.

  private frze:(tipe,map[string,tipe],tipe){}.
  frze(voidType,_,voidType).
  frze(anonType,_,anonType).
  frze(thisType,_,thisType).
  frze(kVar(TV),_,kVar(TV)).
  frze(V,B,kVar(TV)) :- isUnbound(V), present(B,TV,VV), isIdenticalVar(V,deRef(VV)).
  frze(V,_,V) :- isUnbound(V).
  frze(tipe(Nm),_,tipe(Nm)).
  frze(funType(A,R),B,funType(FA,FR)) :-
    freeze(A,B,FA),
    freeze(R,B,FR).
  frze(grammarType(A,R),B,grammarType(FA,FR)) :-
    freeze(A,B,FA),
    freeze(R,B,FR).
  frze(classType(A,R),B,classType(FA,FR)) :-
    freeze(A,B,FA),
    freeze(R,B,FR).
  frze(predType(A),B,predType(FA)) :- freeze(A,B,FA).
  frze(tupleType(L),B,tupleType(FL)) :- freezeTypes(L,B,FL).
  frze(typeExp(O,A),B,typeExp(O,FA)) :- freezeTypes(A,B,FA).
  frze(univType(kVar(V),Tp),B,univType(kVar(V),FTp)) :-
    freeze(Tp,_remove(B,V),FTp).
  frze(faceType(L),B,faceType(FL)) :-
    freezeFields(L,B,FL).
  frze(typeRule(A,R),B,typeRule(FA,FR)) :-
    freeze(A,B,FA),
    freeze(R,B,FR).
  frze(constrained(Tp,Con),B,constrained(FTp,FCon)) :-
    freeze(Tp,B,FTp),
    freezeConstraint(Con,B,FCon).

  freezeFields:(list[(string,tipe)],map[string,tipe],list[(string,tipe)]){}.
  freezeFields([],_,[]).
  freezeFields([(Nm,A),..L],B,[(Nm,FA),..FL]) :- freeze(A,B,FA), freezeFields(L,B,FL).

  freezeTypes:(list[tipe],map[string,tipe],list[tipe]){}.
  freezeTypes([],_,[]).
  freezeTypes([A,..L],B,[FA,..FL]) :- freeze(A,B,FA), freezeTypes(L,B,FL).

  reQuant:(list[(string,tipe)],map[string,tipe],tipe,tipe){}.
  reQuant([],_,T,T).
  reQuant([(_,Tp),..R],BB,T,FZT) :- 
    V = deRef(Tp), isUnbound(V),
    freezeConstraints(constraints(V),BB,T,FT)!,
    reQuant(R,BB,FT,FZT).
  reQuant([_,..B],BB,T,FT) :- reQuant(B,BB,T,FT).

  freezeConstraints:(list[constraint],map[string,tipe],tipe,tipe){}.
  freezeConstraints(C,_,T,T) :- var(C)!.
  freezeConstraints([C,.._],_,T,T) :- var(C)!.
  freezeConstraints([C,..R],BB,T,FT) :-
    freezeConstraint(C,BB,FC),
    freezeConstraints(R,BB,constrained(T,FC),FT).

  freezeConstraint:(constraint,map[string,tipe],constraint){}.
  freezeConstraint(conTract(Nm,A,D),B,conTract(Nm,FA,FD)) :-
    freezeTypes(A,B,FA),
    freezeTypes(D,B,FD).
  freezeConstraint(implementsFace(T,F),B,implementsFace(FT,FF)) :-
    freeze(T,B,FT),
    freezeFields(F,B,FF).
}