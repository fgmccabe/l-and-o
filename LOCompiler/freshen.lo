lo.comp.freshen{
  import lo.
  import lo.comp.misc.
  import lo.comp.types.

  public
  freshen:(type,map[string,type]) => type.
  freshen(univType(V,T),B) :: deQuant(V,B,NV,NB) => freshen(T,NB).
  freshen(T,B) => frshn(T,B).

  private
  deQuant:(type,map[string,type],type-,map[string,type]-){}.
  deQuant(kVar(Nm),B,NV,B+{Nm->NV}) :- NV = newVar(Nm).
  deQuant(constrained(Lw,V,Up),B,NV,NB) :-
    deQuant(V,B,NV,NB),
    markConstraints(NV,frshn(Lw,NB),frshn(Up,NB)).

  frshn:(type,map[string,type]) => type.
  frshn(anonType,_) => anonType.
  frshn(voidType,_) => voidType.
  frshn(topType,_) => topType.
  frshn(thisType,{"this"->Tp}) => Tp.
  frshn(thisType,_) => thisType.
  frshn(kVar(Nm),{Nm->Tp}) => Tp.
  frshn(kVar(Nm),_) => kVar(Nm).
  frshn(V :: V=tVar(_,Curr,_,_,_,_),B) => (var(Curr) ? V | frshn(Curr,B)).
  frshn(type(Nm),_) => type(Nm).
  frshn(typeExp(Nm,A),B) => typeExp(Nm,frshnTypes(A,B)).
  frshn(funType(A,R),B) => funType(frshnArgTypes(A,B),frshn(R,B)).
  frshn(predType(A),B) => predType(frshnArgTypes(A,B)).
  frshn(grammarType(A,R),B) => grammarType(frshnArgTypes(A,B),frshn(R,B)).
  frshn(classType(A,R),B) => classType(frshnTypes(A,B),frshn(R,B)).
  frshn(tupleType(A),B) => tupleType(frshnTypes(A,B)).
  frshn(faceType(F),B) => faceType(frshnFields(F,B)).
  frshn(univType(V,T),B) :: frshnBounds(V,B,NV,NB) => univType(NV,frshn(T,NB)).

  private
  frshnTypes:(list[type],map[string,type]) => list[type].
  frshnTypes([],_) => [].
  frshnTypes([E,..R],B) => [frshn(E,B),..frshnTypes(R,B)].

  private
  frshnArgTypes:(list[typeFlow],map[string,type]) => list[typeFlow].
  frshnArgTypes([],_) => [].
  frshnArgTypes([E,..R],B) => [frshnArg(E,B),..frshnArgTypes(R,B)].

  private
  frshnArg:(typeFlow,map[string,type]) => typeFlow.
  frshnArg(inFlow(Tp),B) => inFlow(frshn(Tp,B)).
  frshnArg(outFlow(Tp),B) => outFlow(frshn(Tp,B)).
  frshnArg(inoutFlow(Tp),B) => inoutFlow(frshn(Tp,B)).

  private
  frshnFields:(list[(string,type)],map[string,type]) => list[(string,type)].
  frshnFields([],_) => [].
  frshnFields([(F,E),..R],B) => [(F,frshn(E,B)),..frshnFields(R,B)].

  private
  frshnBounds:(type,map[string,type],type-,map[string,type]-){}.
  frshnBounds(kVar(V),B,kVar(V),B-{V->_}) :-- true.
  frshnBounds(constrained(Lw,V,Up),B,constrained(frshn(Lw,NB),NV,frshn(Up,NB)),NB) :--
    frshnBounds(V,B,NV,NB).
}