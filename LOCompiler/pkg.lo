lo.comp.code.pkg{
  import lo.

  -- Top level of the prolog compiler

  import lo.comp.errors.
  import lo.comp.package.
  import lo.comp.reduce.
  import lo.comp.term.

  import lo.comp.code.asm.
  import lo.comp.code.clause.
  import lo.comp.code.code.
  import lo.comp.code.indexing.
  import lo.comp.code.instructions.
  import lo.comp.code.registers.

  public compileMdl:(prProg) => codeMdl.
  compileMdl(prProg(Spec,Clses)) =>
    codeMdl(Spec,pairs(pickupDefs(Clses,[]))//(((Nm,Cls)) => asm(compRel(Nm,Cls)))).

  pickupDefs:(list[clse],map[term,list[clse]]) => map[term,list[clse]].
  pickupDefs([],D)=>D.
  pickupDefs([Cl,..L],D) => pickupDefs(L,D[Nm->Clses<>[Cl]]):- Cl=clse(_,Nm,_,_), present(D,Nm,Clses).
  pickupDefs([Cl,..L],D) => pickupDefs(L,D[Nm->[Cl]]) :- Cl=clse(_,Nm,_,_).

  compRel:(term,list[clse]) => assem.
  compRel(prg(Nm,Ar),Cls) => Code :-
    logMsg("Compiling \(Cls)"),
    Prefix = Nm+"_",
    L0 = newLabel(Prefix),
    DefltCode = defltSeq(Prefix,L0,Cls,true,[],Lts,Entries,[]),
    IndexCode = genIndex(Entries,L0),
    Code = assem(prg(Nm,Ar),IndexCode<>DefltCode,[litrl(newLabel(Prefix),prg(Nm,Ar)),..Lts]),
    logMsg("Assembler output: \(Code)").

  defltSeq:(string,string,list[clse],logical,list[litrl],list[litrl],list[(string,clse)],list[(string,clse)]) => list[instruction].
  defltSeq(Prefix,Lb,[Cl],true,Lts,Ltx,[(Lb,Cl),..Entries],Entries) => [iLbl(Lb),..ClCode] :-
    compCl(reduceClause(Cl),Lts) = assem(_,ClCode,Ltx).
  defltSeq(Prefix,Lb,[Cl],false,Lts,Ltx,[(Lbx,Cl),..Entries],Entries) => [iLbl(Lb),iTrustme,iLbl(Lbx),..ClCode] :-
    Lbx = newLabel("Cl"),
    compCl(reduceClause(Cl),Lts) = assem(_,ClCode,Ltx).
  defltSeq(Prefix,Lb,[Cl,..Rest],true,Lts,Ltx,[(Lbx,Cl),..Entries],Enx) =>
      [iLbl(Lb),iTryme(Lbnxt),iLbl(Lbx),..ClCode] <> defltSeq(Prefix,Lbnxt,Rest,false,Lt0,Ltx,Entries,Enx) :-
    Lbx = newLabel("Cl"),
    Lbnxt = newLabel("Nxt"),
    compCl(reduceClause(Cl),Lts) = assem(_,ClCode,Lt0).
  defltSeq(Prefix,Lb,[Cl,..Rest],false,Lts,Ltx,[(Lbx,Cl),..Entries],Enx) =>
      [iLbl(Lb),iRetryme(Lbnxt),iLbl(Lbx),..ClCode] <> defltSeq(Prefix,Lbnxt,Rest,false,Lt0,Ltx,Entries,Enx) :-
    Lbx = newLabel("Cl"),
    Lbnxt = newLabel("Nxt"),
    compCl(reduceClause(Cl),Lts) = assem(_,ClCode,Lt0).
  defltSeq(_,Lb,[],_,Lts,Lts,Entries,Entries) => [iLbl(Lb),iFayl].
}
