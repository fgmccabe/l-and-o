lo.comp.resolve{
  import lo.
  import lo.comp.misc.
  import lo.comp.errors.
  import lo.comp.types.
  import lo.comp.freshen.
  import lo.comp.canon.
  import lo.comp.unify.

  public overload:(list[canonDef],list[implEntry],list[implEntry],list[canonDef]){}.
  overload(Defs,Dict,RDict,overloadDefs(Defs,RDict,Rp,Rpx),Rp,Rpx`) :-
    declareImplementations(Defs,Dict,RDict).

  overloadDefs:(list[canonDef],list[implEntry],report,report) => list[canonDef].
  overloadDefs([],_,Rp,Rp) => [].
  overloadDefs([Df,..L],Dc,Rp,Rpx) => [overloadDef(Df,Dc,Rp,Rp0),..overloadDefs(L,Dc,Rp0,Rpx)].

  overloadDef:(canonDef,list[implEntry],report,report) => canonDef.
  overloadDef(funDef(Lc,Nm,Tp,Cx,Eqns),Dict,Rp,Rpx) => overloadFunction(Lc,Nm,Tp,Cx,Eqns,Dict,Rp,Rpx).
  overloadDef(relDef(Lc,Nm,Tp,Cx,Cls),Dict,Rp,Rpx) => overloadPredicate(Lc,Nm,Tp,Cx,Cls,Dict,Rp,Rpx).
  overloadDef(varDef(Lc,Nm,Tp,Cx,Value,Cond),Dict,Rp,Rpx) => overloadDefn(Lc,Nm,Tp,Cx,Value,Cond,Dict,Rp,Rpx).
  overloadDef(enumDef(Lc,Nm,Tp,Cx,Rules),Dict,Rp,Rpx) => overloadEnum(Lc,Nm,Tp,Cx,Rules,Dict,Rp,Rpx).
  overloadDef(classDef(Lc,Nm,Tp,Cx,Rules),Dict,Rp,Rpx) => overloadClass(Lc,Nm,Tp,Cx,Rules,Dict,Rp,Rpx).
  overloadDef(grammDef(Lc,Nm,Tp,Cx,Rules),Dict,Rp,Rpx) => overloadGrammar(Lc,Nm,Tp,Cx,Rules,Dict,Rp,Rpx).
  overloadDef(T,_) => T :-
    T = typeDef(_,_,_,_).
  overloadDef(C,_) => C :-
    C = cnDefn(_,_,_,_).
  overloadDef(implDef(Lc,INm,ImplName,Spec,Cx,ThDefs,Others),Dict,Rp,Rpx) => 
      overloadImplementation(Lc,INm,ImplName,Spec,Cx,ThDefs,Others,Dict,Rp,Rpx).

  private overloadFunction:(location,string,tipe,list[constraint],list[canonRule],list[implEntry],report,report)=>canonDef.
  overloadFunction(Lc,Nm,Tp,[],Eqns,Dict,Rp,Rpx) => funDef(Lc,Nm,Tp,[],overloadRules(Eqns,Dict,[],Rp,Rpx))).
  overloadFunction(Lc,Nm,Tp,Cx,Eqns,Dict,Rp,Rpx) => funDef(Lc,Nm,Tp,[],overloadRules(Eqns,FDict,CVars,Rp,Rpx))) :-
    defineCVars(Lc,Cx,Dict,CVars,FDict).

  private overloadPredicate:(location,string,tipe,list[constraint],list[canonRule],list[implEntry],report,report)=>canonDef.
  overloadPredicate(Lc,Nm,Tp,[],Cls,Dict,Rp,Rpx) => predicate(Lc,Nm,Tp,[],overloadRules(Cls,Dict,[],Rp,Rpx))).
  overloadPredicate(Lc,Nm,Tp,Cx,Cls,Dict,Rp,Rpx) => predicate(Lc,Nm,Tp,[],overloadRules(Cls,FDict,CVars,Rp,Rpx))) :-
    defineCVars(Lc,Cx,Dict,CVars,FDict).

  private overloadDefn:(location,string,tipe,list[constraint],canonTerm,canonCond,list[implEntry],report,report) => canonDef.
  overloadDefn(Lc,Nm,Tp,[],Exp,Cond,Dict,Rp,Rpx) => varDef(Lc,Nm,Tp,[],RExp,RCond)) :-
    RCond = resolveCond(Cond,Dict,Rp,Rp0),
    RExp = resolveTerm(Exp,Dict,Rp0,Rpx).
  overloadDefn(Lc,Nm,Tp,Cx,Exp,Cond,Dict,Rp,Rpx) => funDef(Lc,Nm,functionType(tupleType([]),Tp),[],[equation(Lc,Nm,tpl(CVars),RExp,RCond)]) :-
    RCond = resolveCond(Cond,Dict,Rp,Rp0),
    RExp = resolveTerm(Exp,FDict,RExp).

  overloadGrammar:(location,string,tipe,list[constraint],list[canonRule],list[implEntry],report,report) => canonDef.
  overloadGrammar(Lc,Nm,Tp,[],Rules,Dict,Rp,Rpx) => grammDef(Lc,Nm,Tp,[],overloadRules(Rules,Dict,[],Rp,Rpx)).
  overloadGrammar(Lc,Nm,Tp,Cx,Rules,Dict,Rp,Rpx) => grammDef(Lc,Nm,Tp,[],overloadRules(Rules,FDict,CVars,Rp,Rpx)) :-
    defineCVars(Lc,Cx,Dict,CVars,FDict).

  defineCVars:(location,list[constraint],list[implEntry],list[canonTerm],list[implEntry]){}.
  defineCVars(_,[],Dict,[],Dict).
  defineCVars(Lc,[Con,..Cx],Dict,[NV,..CVars],FDict) :-
    ImplNm = implementationName(Con),
    NV = genVar(ImplNm),
    defineCVars(Lc,Cx,[(ImplNm,implVar(NV))|Dict],CVars,FDict).
  defineCVars(Lc,[implementsFace(_,_),..Cx],Dict,CVars,FDict) :-
    defineCVars(Lc,Cx,Dict,CVars,FDict).

  private overloadRules:(list[canonRule],list[implEntry],list[canonTerm],report,report) => list[canonRule].
  overloadRules([],_,_,Rp,Rp) => [].
  overloadRules([Rl,..L],Dict,Ex,Rp,Rpx) => [overloadRule(Rl,Dict,Ex,Rp,Rp0),..overloadRules(L,Dict,Ex,Rp0,Rpx)].

  private overloadRule:(canonRule,list[implEntry],list[canonTerm],report,report) => canonRule.
  overloadRule(equation(Lc,Nm,Args,Rep,Cond),Dict,Ex,Rp,Rpx) => 
      equation(Lc,Nm,addExtra(Ex,resolveTerm(Args,Dict,Rp,Rp0)),resolveTerm(Rep,Dict,Rp0,Rp1),resolveCond(Cond,Dict,Rp1,Rpx)).
  overloadRule(clause(Lc,Nm,Args,Cond),Dict,Ex,Rp,Rpx) => 
      clause(Lc,Nm,addExtra(Ex,resolveTerm(Args,Dict,Rp,Rp0)),resolveCond(Cond,Dict,Rp0,Rpx)).
  overloadRule(grRule(Lc,Nm,Args,Hed,Body),Dict,Ex,Rp,Rpx) =>
      grRule(Lc,Nm,addExtra(Ex,resolveTerm(Args,Dict,Rp,Rp0)),resolveGr(Hed,Dict,Rp0,Rp1),resolveGr(Body,Dict,Rp1,Rp2)).

  addExtra:(list[canonTerm],canonTerm) => canonTerm.
  addExtra([],T) => T.
  addExtra(Ex,tpl(A)) => tpl(Ex<>A).
  
  private resolveTerm:(canonTerm,list[implEntry],report,report) => canonTerm.
  resolveTerm(v(Nm),_,Rp,Rp) => v(Nm).
  resolveTerm(int(Ix),_,Rp,Rp) => int(Ix).
  resolveTerm(flt(Dx),_,Rp,Rp) => flt(Dx).
  resolveTerm(str(Sx),_,Rp,Rp) => str(Sx).
  resolveTerm(dot(Rc,Fld),Dict,Rp,Rpx) => dot(resolveTerm(Rc,Dict,Rp,Rpx),Fld).
  resolveTerm(tpl(Args),Dict,Rp,Rpx) => tpl(resolveTerms(Args,Dict,Rp,Rpx)).
  resolveTerm(whre(Trm,Cond),Dict,Rp,Rpx) => whre(resolveTerm(Trm,Dict,Rp,Rp0),resolveCond(Cond,Dict,Rp0,Rpx)).
  resolveTerm(condExp(Cond,Then,Else),Dict,Rp,Rpx) => 
      condExp(Lc,resolveCond(Cond,Dict,Rp,Rp0),resolveTerm(Then,Dict,Rp0,Rp1),resolveTerm(Else,Dict,Rp1,Rpx)).
  resolveTerm(apply(Lc,over(T,Cx),tpl(Args)),Dict,Rp,Rpx) => apply(Lc,OverOp,tpl(NArgs)) :-
    resolveContracts(Lc,Cx,Dict,DTerms,Rp,Rp0),
    overloadRef(T,DTerms,RArgs,OverOp,resolveTerms(Args,Dict,Rp0,Rpx)).
  resolveTerm(apply(Op,Args),Dict,Rp,Rpx) => apply(resolveTerm(Op,Dict,Rp,RP0),resolveTerms(Args,Dict,Rp0,Rpx)).
  resolveTerm(over(Lc,T,Cx),Dict,Rp,Rpx) => Over :-
    ( resolveContracts(Lc,Cx,Dict,DTerms) ?
        overloadRef(T,DTerms,[],OverOp,NArgs),
        (NArgs=[] ? Over = OverOp | Over = apply(OverOp,NArgs)),
        Rp=Rpx |
        reportError("cannot find implementation for contracts $(Cx)",Lc,Rp,Rpx),
        Over = T).
  resolveTerm(mtd(Lc,Nm),_,Rp,Rpx) => v(Nm):-
    reportError("cannot find implementation for naked method $(Nm)",Lc,Rp,Rpx).
  resolveTerm(lambda(Rl),Dict,Rp,Rpx) => lambda(overloadRule(Rl,Dict,Rp,Rpx)).

  resolveTerms:(list[canonTerm],list[implEntry],report,report) => list[canonTerm].
  resolveTerms([],_,Rp,Rp) => Rp.
  resolveTerms([t,..l],D,Rp,Rpx) => [resolveTerm(t,D,Rp,Rp0),..resolveTerms(l,D,Rp0,Rpx)].

  resolveCond:(canonCond,list[implEntry],report,report) => canonCond.
  resolveCond(trueCond,_,Rp,Rp) => trueCond.
  resolveCond(falseCond,_,Rp,Rp) => falseCond.
  resolveCond(conjCond(L,R),Dict,Rp,Rpx) => conjCond(resolveCond(L,Dict,Rp,Rp0),resolveCond(R,Dict,Rp0,Rpx)).
  resolveCond(disjCond(L,R),Dict,Rp,Rpx) => disjCond(resolveCond(L,Dict,Rp,Rp0),resolveCond(R,Dict,Rp0,Rpx)).
  resolveCond(forallCond(L,R),Dict,Rp,Rpx) => forallCond(resolveCond(L,Dict,Rp,Rp0),resolveCond(R,Dict,Rp0,Rpx)).
  resolveCond(condCond(T,L,R),Dict,Rp,Rpx) => condCond(resolveCond(T,Dict,Rp,Rp0),resolveCond(L,Dict,Rp0,Rp1),resolveCond(R,Dict,Rp1,Rpx)).
  resolveCond(oneCond(T),Dict,Rp,Rpx) => oneCond(resolveCond(T,Dict,Rp,Rpx)).
  resolveCond(negCond(T),Dict,Rp,Rpx) => negCond(resolveCond(T,Dict,Rp,Rpx)).
  resolveCond(unifyCond(L,R),Dict,Rp,Rpx) => unifyCond(resolveTerm(L,Dict,Rp,Rp0),resolveTerm(R,Dict,Rp0,Rpx)).
  resolveCond(phraseCond(Lc,T,S,R),Dict,Rp,Rpx) => 
      phraseCond(Lc,resolveGr(T,Dict,Rp,Rp0),resolveTerm(S,Dict,Rp0,Rp1),resolveTerm(R,Dict,Rp1,Rpx)).
  resolveCond(callCond(Lc,over(T,Cx),tpl(Args)),Dict,Rp,Rpx) => CallCond(Lc,OverOp,tpl(NArgs)) :-
    resolveContracts(Lc,Cx,Dict,DTerms,Rp,Rp0),
    overloadRef(T,DTerms,RArgs,OverOp,resolveTerms(Args,Dict,Rp0,Rpx)).
  resolveCond(callCond(Lc,P,A),Dict,Rp,Rpx) => callCond(Lc,resolveTerm(P,Dict,Rp,Rp0),resolveTerm(A,Dict,Rp0,Rpx)).

  resolveGr:(canonNT,list[implEntry],report,report) => canonNT.
  resolveGr(grTerms(Terms),Dict,Rp,Rpx) => grTerms(resolveTerminals(Terms,Dict,Rp,Rpx)),
  resolveGr(grConj(L,R),Dict,Rp,Rpx)) => grConj(resolveGr(L,Dict,Rp,Rp0),resolveGr(R,Dict,Rp0,Rpx)).
  resolveGr(grDisj(L,R),Dict,Rp,Rpx)) => grDisj(resolveGr(L,Dict,Rp,Rp0),resolveGr(R,Dict,Rp0,Rpx)).
  resolveGr(grCond(T,L,R),Dict,Rp,Rpx)) => grCond(resolveGr(T,Dict,Rp,Rp0),resolveGr(L,Dict,Rp0,Rp1),resolveGr(R,Dict,Rp1,Rpx)).
  resolveGr(grOne(T),Dict,Rp,Rpx)) => grOne(resolveGr(T,Dict,Rp,Rpx)).
  resolveGr(grNeg(T),Dict,Rp,Rpx)) => grNeg(resolveGr(T,Dict,Rp,Rpx)).
  resolveGr(grAhed(T),Dict,Rp,Rpx)) => grAhed(resolveGr(T,Dict,Rp,Rpx)).
  resolveGr(grDip(T,C),Dict,Rp,Rpx)) => grDip(resolveTerm(T,Dict,Rp,Rp0),resolveCond(C,Dict,Rp0,Rpx)).
  resolveGr(grTest(C),Dict,Rp,Rpx) => grTest(resolveCond(C,Dict,Rp,Rpx)).
  resolveGr(grCall(Lc0,over(Lc,T,Cx),tpl(Args)),Dict,Rp,Rpx) => grCall(Lc0,OverOp,tpl(NArgs)) :-
    DTerms = resolveContracts(Lc,Cx,Dict,Rp,Rp0),
    overloadRef(T,DTerms,RArgs,OverOp,NArgs,Rp0,Rp1),
    RArgs = resolveTerms(Args,Dict,Rp1,Rpx).
  resolveGr(grCall(Lc,Op,Args),Dict,Rp,Rpx) => grCall(Lc,resolveTerm(Op,Dict,Rp,Rp0),resolveTerm(Args,Dict,Rp,Rpx)).

  resolveTerminals:(list[(location,string,canonTerm)],list[implEntry],report,report) => list[(location,string,canonTerm)].
  resolveTerminals([],_,Rp,Rp) => [].
  resolveTerminals([(Lc,Op,T),..L],Dict,Rp,Rpx) => [(Lc,Op,resolveTerm(T,Dict,Rp,Rp0)),..resolveTerminals(L,Dict,Rp0,Rpx)].

  overloadRef:(canonTerm,list[canonTerm],list[canonTerm],canonTerm,list[canonTerm]){}.
  overloadRef(mtd(_,Nm),[DT],RArgs,dot(DT,Nm),RArgs).
  overloadRef(v(Nm),DT,RArgs,v(Nm),DT<>RArgs).

  resolveContracts:(location,list[constraint],list[implEntry],list[canonTerm],report,report){}.
  resolveContracts(_,[],_,[],Rp,Rp).
  resolveContracts(Lc,[Con,..C],Dict,[CV,..Vs],Rp,Rpx) :-
    resolveContract(Lc,Con,Dict,CV,Rp,Rp0),
    resolveContracts(Lc,C,Dict,Vs,Rp0,Rpx).

  resolveContract:(location,constraint,list[implEntry],canonTerm,report,report){}.
  resolveContract(Lc,C,Dict,Over,Rp,Rpx) :-
    findImplementation(implementationName(C),Dict,Impl)!,
    resolve(Impl,C,Lc,Dict,Over,Rp,Rpx)!.
  resolveContract(Lc,C,_,v(implementationName(C)),Rp,Rpx) :-
    reportError("no implementation known for $(C)",Lc,Rp,Rpx).

  resolve:(implEntry,constraint,location,list[implEntry],canonTerm,report,report){}.
  resolve(implVar(_,v(Nm)),_,_,_,_,v(Nm),Rp,Rp).
  resolve(implEntry(ImpNm,IC),C,Lc,Dict,formOver(v(ImpNm),Lc,Args),Rp,Rpx) :-
    freshenContract(IC,_,Con),
    moveConConstraints(Con,Cx,CT),
    sameContract(CT,C,[]),
    resolveDependents(Cx,Lc,Dict,[],Args,Rp,Rpx).
  resolve(I,C,Lc,_,v(_str_gen("void")),Rp,Rpx) :-
    reportError("cannot resolve contract $(C)",Lc,Rp,Rpx).

  resolveDependents:(list[constraint],location,list[implEntry],list[canonTerm],list[canonTerm],report,report){}.
  resolveDependents([],_,_,Args,Args,Rp,Rp).
  resolveDependents([C,..L],Lc,Dict,As,Args,Rp,Rpx) :-
    resolveContract(Lc,C,Dict,A,Rp,Rp0),
    resolveDependents(L,Lc,Dict,[A|As],Args,Rp0,Rpx).

  formOver:(canonTerm,location,list[canonTerm]) => canonTerm.
  formOver(V,_,[]) => V.
  formOver(V,_,Args) => apply(Lc,V,Args)).

  genVar:(string) => canonTerm.
  genVar(Nm) => v(_str_gen(Nm)).

  declareImplementations:(list[canonDef],list[implEntry],list[implEntry]){}.
  declareImplementations([],Dict,Dict).
  declareImplementations([implDef(_,_,ImplName,Spec,_,_,_),..Defs],Dict,RDict) :-
    declareImplementations(Defs,[implEntry(ImplName,Spec),..Dict],RDict).
  declareImplementations([_,..Defs],Dict,RDict) :-
    declareImplementations(Defs,Dict,RDict).

  findImplementation:(string,list[implEntry],implEntry){}.
  findImplementation(ImplName,[I,.._],I) :- I.name=ImplName.
  findImplementation(ImplName,[_,..D],Spec) :- findImplementation(ImplName,D,Spec).

  overloadImplementation:(location,string,string,constraint,list[constraint],list[canonDef],list[canonOther],list[implEntry],report,report) => canonDef.
  overloadImplementation(Lc,INm,ImplName,Spec,Cx,ThDefs,Face,Types,Others,Dict,Rp,Rpx) => 
      implDef(Lc,INm,ImplName,Arity,Spec,Cx,implBody(Lc,Hd,RThDefs,ROthers,Types),InhRules,faceType(Face)) :-
    defineCVars(Lc,AC,Dict,CVars,FDict),
    overload(ThDefs,FDict,FODict,RThDefs),
    overloadOthers(Others,FODict,ROthers),
    resolveDependents(Cx,Lc,FODict,[],Inherits),
    length(CVars,Arity),
    (CVars=[] -> Hd = enum(Lc,ImplName) ; Hd = apply(v(Lc,ImplName),CVars)),
    inheritImplementations(Inherits,Hd,InhRules).

  inheritImplementations([],_,[]).
  inheritImplementations([Impl|L],Hd,[rule(Hd,Impl)|M]) :-
    inheritImplementations(L,Hd,M).

  overloadOthers(Other,Dict,OOthers) :-
    overloadList(Other,resolve:overloadOther,Dict,OOthers).

  overloadOther(show(Lc,Show),Dict,show(Lc,RShow)) :-
    resolveTerm(Show,Dict,RShow).
  overloadOther(assertion(Lc,Cond),Dict,assertion(Lc,RCond)) :-
    resolveCond(Cond,Dict,RCond).

  overloadEnum(Lc,Nm,Tp,[],Rules,Face,Dict,enum(Lc,Nm,Tp,[],ORules,Face)) :-
    overloadClassRules(Rules,[],Dict,ORules).
  overloadEnum(Lc,Nm,Tp,Cx,Rules,Face,Dict,class(Lc,Nm,Tp,[],ORules,Face)) :-
    defineCVars(Lc,Cx,Dict,EVars,EDict),
    overloadClassRules(Rules,EVars,EDict,ORules).

  overloadClass(Lc,Nm,Tp,Cx,Rules,Face,Dict,class(Lc,Nm,Tp,[],ORules,Face)) :-
    defineCVars(Lc,Cx,Dict,EVars,EDict),
    overloadClassRules(Rules,EVars,EDict,ORules).

  overloadClassRule(labelRule(Lc,Nm,Hd,Repl,Face),CVars,Dict,labelRule(Lc,Nm,OHd,ORepl,Face)) :-
    resolveHead(Hd,CVars,OHd),
    resolveTerm(Repl,Dict,ORepl).
  overloadClassRule(classBody(Lc,Nm,Hd,Stmts,Others,Types),CVars,Dict,classBody(Lc,Nm,OHd,OStmts,OOthers,Types)) :-
    resolveHead(Hd,CVars,OHd),
    overloadDefs(Stmts,Dict,OStmts),
    overloadOthers(Others,Dict,OOthers).

  resolveHead(Hd,[],Hd).
  resolveHead(enum(Lc,Nm),CVars,apply(v(Nm),CVars)).
  resolveHead(apply(Op,Args),CVars,apply(Op,CVars<>Args)).

  overloadClassRules([],_,_,[]).
  overloadClassRules([Rl|L],V,D,[ORl|M]) :-
    overloadClassRule(Rl,V,D,ORl),
    overloadClassRules(L,V,D,M).
}