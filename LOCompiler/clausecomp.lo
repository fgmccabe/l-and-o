lo.comp.clausecomp{
  import lo.

  import lo.comp.errors.
  import lo.comp.registers.
  import lo.comp.term.
  import lo.comp.varcomp.

  unifyHead:(list[term],map[string,dictEntry],map[string,dictEntry],varSet,varSet,list[literal],list[literal],logical) => list[instruction].

  unifyTerm:(term,logical,source,map[string,dictEntry],map[string,dictEntry],varSet,varSet,list[literal],list[literal],logical) => list[instruction].
  unifyTerm(anon,_,Src,D,D,VS,VS,Lts,Lts,_) => skipOver(Src).
  unifyTerm(T,Top,Src,D,D,VS,VSx,Lt,Ltx,_) => unifyLit(Lb,Top,Src,VS,VSx) :- isGroundTerm(T), accessLiteral(T,Lb,Lt,Ltx).
  unifyTerm(varbl(Nm),_,Src,D,Dx,VS,Vx,Lt,Lt,last) => unifyVar(Dst,Src,In,D,Dx,VS,Vx,Lt,last) :- present(D,Nm,dictEntry(_,In,Dst)).
  unifyTerm(cons(Op,Els),Top,Src,D,Dx,V,Vx,Lt,Ltx,Last) => unifyOp(Lb,Top,Src,V,V0) <> unifyEls(Els,D,Dx,V,Vx,Lt0,Ltx) :-
      accessLiteral(Op,Lt,Lt0).

  unifyEls:(list[term],map[string,dictEntry],map[string,dictEntry],varSet,varSet,list[literal],list[literal]) => list[instruction].
  unifyEls([],D,D,V,V,Lt,Lt) => [].
  unifyEls([e],D,Dx,V,Vx,Lt,Ltx) => unifyTerm(e,false,sReg,D,Dx,V,Vx,Lt,Ltx,true).
  unifyEls([e,..l],D,Dx,V,Vx,Lt,Ltx) => unifyTerm(e,false,sReg,D,D0,V,V0,Lt,Lt0,false)<>unifyEls(l,D0,Dx,V0,Vx,Lt0,Ltx).

  unifyVar:(source,source,initialized,map[string,dictEntry],map[string,dictEntry],varSet,varSet,logical) => list[instruction].
  unifyVar(voidVar,sReg,_,D,D,V,V,_) => [iClS].
  unifyVar(voidVar,_,_,D,D,V,V,_) => [].
  unifyVar(Src,Dst,true,D,D,V,Vx,Last) => Ins :- unifyVr(Src,Dst,V,Last,Ins,Vx).
  unifyVar(Src,Dst,false,D,Dx,V,Vx,Last) => Ins :- moveVr(Src,Dst,V,Last,Ins,Vx), updateInited(Src,D,Dx).

  skipOver:(source) => list[instruction].
  skipOver(voidVar) => [].
  skipOver(aReg(_)) => [].
  skipOver(yReg(_,_)) => [].
  skipOver(sReg) => [iClS].

  unifyLit:(string,logical,source,varSet,varSet) => list[instruction].
  unifyLit(_,_,anon,Vs,Vs) => [].
  unifyLit(Lb,true,aReg(Rg),VS,freeReg(VS,Rg)) => [iUAlit(Rg,Lb)].
  unifyLit(Lb,false,aReg(Rg),VS,VS) => [iUAlit(Rg,Lb)].
  unifyLit(Lb,_,yReg(Lc,_),VS,VS) => [iMAY(0,Lc),iUAlit(0,Lb)].
  unifyLit(Lb,_,sReg,VS,VS) => [iUSlit(Lcb)].

  accessLiteral:(term,string,list[literal],list[literal]){}.
  accessLiteral(T,Lb,Lt,Lt) :- literal(T,Lb) in Lt.
  accessLiteral(T,Lb,Lts,[literal(Lb,T)]) :- Lb = _str_gen("L").

  unifyOp:(string,source,logical,varSet,varSet) => list[instruction].
  unifyOp(Lb,aReg(1),true,V,freeAReg(V,1)) => [iUAcns1(Lb)].
  unifyOp(Lb,aReg(1),false,V,V) =>  [iUAcns1(Lb)].
  unifyOp(Lb,aReg(2),true,V,freeAReg(V,2)) => [iUAcns2(Lb)].
  unifyOp(Lb,aReg(2),false,V,V) =>  [iUAcns2(Lb)].
  unifyOp(Lb,aReg(3),true,V,freeAReg(V,3)) => [iUAcns3(Lb)].
  unifyOp(Lb,aReg(3),false,V,V) =>  [iUAcns3(Lb)].
  unifyOp(Lb,aReg(4),true,V,freeAReg(V,4)) => [iUAcns4(Lb)].
  unifyOp(Lb,aReg(4),false,V,V) =>  [iUAcns4(Lb)].
  unifyOp(Lb,aReg(Rg),true,V,freeAReg(V,Rg)) => [iUAcns(Rg.Lb)].
  unifyOp(Lb,aReg(Rg),false,V,V) =>  [iUAcns(Rg,Lb)].
  unifyOp(Lb,yReg(Lc,_),_,V,V) =>  [iMAY(0,Lc),iUAcns0(Lb)].
  unifyOp(Lb,sReg,_,V,V) =>  [iUScns(Lb)].

  matchTerm:(term,logical,source,map[string,dictEntry],map[string,dictEntry],varSet,varSet,list[literal],list[literal],logical) => list[instruction].
  matchTerm(anon,_,Src,D,D,VS,VS,Lts,Lts,_) => skipOver(Src).
  matchTerm(T,Top,Src,D,D,VS,VSx,Lt,Ltx,_) => matchLit(Lb,Top,Src,VS,VSx) :- isGroundTerm(T), accessLiteral(T,Lb,Lt,Ltx).
  matchTerm(varbl(Nm),_,Src,D,Dx,VS,Vx,Lt,Lt,last) => matchVar(Dst,Src,In,D,Dx,VS,Vx,Lt,last) :- present(D,Nm,dictEntry(_,In,Dst)).
  matchTerm(cons(Op,Els),Top,Src,D,Dx,V,Vx,Lt,Ltx,Last) => matchOp(Lb,Top,Src,V,V0) <> matchEls(Els,D,Dx,V,Vx,Lt0,Ltx) :-
      accessLiteral(Op,Lt,Lt0).

  matchEls:(list[term],map[string,dictEntry],map[string,dictEntry],varSet,varSet,list[literal],list[literal]) => list[instruction].
  matchEls([],D,D,V,V,Lt,Lt) => [].
  matchEls([e],D,Dx,V,Vx,Lt,Ltx) => matchTerm(e,false,sReg,D,Dx,V,Vx,Lt,Ltx,true).
  matchEls([e,..l],D,Dx,V,Vx,Lt,Ltx) => matchTerm(e,false,sReg,D,D0,V,V0,Lt,Lt0,false)<>matchEls(l,D0,Dx,V0,Vx,Lt0,Ltx).

  matchVar:(source,source,initialized,map[string,dictEntry],map[string,dictEntry],varSet,varSet,logical) => list[instruction].
  matchVar(voidVar,sReg,_,D,D,V,V,_) => [iClS].
  matchVar(voidVar,_,_,D,D,V,V,_) => [].
  matchVar(Src,Dst,true,D,D,V,Vx,Last) => Ins :- matchVr(Src,Dst,V,Last,Ins,Vx).
  matchVar(Src,Dst,false,D,Dx,V,Vx,Last) => Ins :- moveVr(Src,Dst,V,Last,Ins,Vx), updateInited(Src,D,Dx).

  matchLit:(string,logical,source,varSet,varSet) => list[instruction].
  matchLit(_,_,anon,Vs,Vs) => [].
  matchLit(Lb,true,aReg(Rg),VS,freeReg(VS,Rg)) => [iCAlit(Rg,Lb)].
  matchLit(Lb,false,aReg(Rg),VS,VS) => [iCAlit(Rg,Lb)].
  matchLit(Lb,_,yReg(Lc,_),VS,VS) => [iMAY(0,Lc),iCAlit(0,Lb)].
  matchLit(Lb,_,sReg,VS,VS) => [iCSlit(Lcb)].

  matchOp:(string,source,logical,varSet,varSet) => list[instruction].
  matchOp(Lb,aReg(1),true,V,freeAReg(V,1)) => [iCAcns1(Lb)].
  matchOp(Lb,aReg(1),false,V,V) =>  [iCAcns1(Lb)].
  matchOp(Lb,aReg(2),true,V,freeAReg(V,2)) => [iCAcns2(Lb)].
  matchOp(Lb,aReg(2),false,V,V) =>  [iCAcns2(Lb)].
  matchOp(Lb,aReg(3),true,V,freeAReg(V,3)) => [iCAcns3(Lb)].
  matchOp(Lb,aReg(3),false,V,V) =>  [iCAcns3(Lb)].
  matchOp(Lb,aReg(4),true,V,freeAReg(V,4)) => [iCAcns4(Lb)].
  matchOp(Lb,aReg(4),false,V,V) =>  [iCAcns4(Lb)].
  matchOp(Lb,aReg(Rg),true,V,freeAReg(V,Rg)) => [iCAcns(Rg.Lb)].
  matchOp(Lb,aReg(Rg),false,V,V) =>  [iCAcns(Rg,Lb)].
  matchOp(Lb,yReg(Lc,_),_,V,V) =>  [iMAY(0,Lc),iCAcns0(Lb)].
  matchOp(Lb,sReg,_,V,V) =>  [iCScns(Lb)].

  buildTerm:(term,logical,source,map[string,dictEntry],map[string,dictEntry],varSet,varSet,list[literal],list[literal],logical) => list[instruction].
  buildTerm(anon,_,Src,D,D,V,Vx,Lts,Lts,_) => clearVar(Src,V,Vx).
  buildTerm(T,Top,Src,D,D,VS,VSx,Lt,Ltx,_) => buildLit(Lb,Top,Src,VS,VSx) :- isGroundTerm(T), accessLiteral(T,Lb,Lt,Ltx).
  buildTerm(varbl(Nm),_,Src,D,Dx,VS,Vx,Lt,Lt,last) => buildVar(Dst,Src,In,D,Dx,VS,Vx,Lt,last) :- present(D,Nm,dictEntry(_,In,Dst)).
  buildTerm(cons(Op,Els),Top,Src,D,Dx,V,Vx,Lt,Ltx,Last) => buildOp(Lb,Top,Src,V,V0) <> buildEls(Els,D,Dx,V,Vx,Lt0,Ltx) :-
      accessLiteral(Op,Lt,Lt0).

  buildEls:(list[term],map[string,dictEntry],map[string,dictEntry],varSet,varSet,list[literal],list[literal]) => list[instruction].
  buildEls([],D,D,V,V,Lt,Lt) => [].
  buildEls([e],D,Dx,V,Vx,Lt,Ltx) => buildTerm(e,false,sReg,D,Dx,V,Vx,Lt,Ltx,true).
  buildEls([e,..l],D,Dx,V,Vx,Lt,Ltx) => buildTerm(e,false,sReg,D,D0,V,V0,Lt,Lt0,false)<>buildEls(l,D0,Dx,V0,Vx,Lt0,Ltx).

  buildVar:(source,source,initialized,map[string,dictEntry],map[string,dictEntry],varSet,varSet,logical) => list[instruction].
  buildVar(voidVar,sReg,_,D,D,V,V,_) => [iClS].
  buildVar(voidVar,_,_,D,D,V,V,_) => [].
  buildVar(Src,Dst,true,D,D,V,Vx,Last) => Ins :- moveVr(Src,Dst,V,Ins,Vx).
  buildVar(Src,Dst,false,D,Dx,V,Vx,Last) => Ins :- clearVr(Src,Dst,V,Last,Ins,Vx), updateInited(Src,D,Dx).

  buildLit:(string,logical,source,varSet,varSet) => list[instruction].
  buildLit(_,_,anon,Vs,Vs) => [].
  buildLit(Lb,true,aReg(Rg),VS,freeReg(VS,Rg)) => [iCAlit(Rg,Lb)].
  buildLit(Lb,false,aReg(Rg),VS,VS) => [iCAlit(Rg,Lb)].
  buildLit(Lb,_,yReg(Lc,_),VS,VS) => [iMAY(0,Lc),iCAlit(0,Lb)].
  buildLit(Lb,_,sReg,VS,VS) => [iCSlit(Lcb)].

  buildOp:(string,source,logical,varSet,varSet) => list[instruction].
  buildOp(Lb,aReg(1),true,V,freeAReg(V,1)) => [iCAcns1(Lb)].
  buildOp(Lb,aReg(1),false,V,V) =>  [iCAcns1(Lb)].
  buildOp(Lb,aReg(2),true,V,freeAReg(V,2)) => [iCAcns2(Lb)].
  buildOp(Lb,aReg(2),false,V,V) =>  [iCAcns2(Lb)].
  buildOp(Lb,aReg(3),true,V,freeAReg(V,3)) => [iCAcns3(Lb)].
  buildOp(Lb,aReg(3),false,V,V) =>  [iCAcns3(Lb)].
  buildOp(Lb,aReg(4),true,V,freeAReg(V,4)) => [iCAcns4(Lb)].
  buildOp(Lb,aReg(4),false,V,V) =>  [iCAcns4(Lb)].
  buildOp(Lb,aReg(Rg),true,V,freeAReg(V,Rg)) => [iCAcns(Rg.Lb)].
  buildOp(Lb,aReg(Rg),false,V,V) =>  [iCAcns(Rg,Lb)].
  buildOp(Lb,yReg(Lc,_),_,V,V) =>  [iMAY(0,Lc),iCAcns0(Lb)].
  buildOp(Lb,sReg,_,V,V) =>  [iCScns(Lb)].


}