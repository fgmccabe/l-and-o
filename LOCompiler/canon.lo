lo.comp.canon {
  import lo.
  import lo.comp.location.
  import lo.comp.types.
  import lo.comp.package.

  public type
  canonPkg ::= canonPkg(pkgSpec,list[pkgSpec],list[canonDef],list[canonOther]).

  public implVar:(string,canonTerm) <=> implEntry.
  implVar(Nm,T) <= {
    name = Nm.
  }

  public type
  canonDef ::= funDef(location,string,tipe,list[constraint],list[canonRule])
           |   relDef(location,string,tipe,list[constraint],list[canonRule])
           |   grammDef(location,string,tipe,list[constraint],list[canonRule])
           |   classDef(location,string,tipe,list[constraint],list[canonRule],tipe)
           |   varDef(location,string,tipe,list[constraint],canonTerm,canonCond)
           |   otherDef(location,canonOther)
           |   typeDef(location,string,tipe,tipe)
           |   cnDefn(location,string,conEntry)
           |   implDef(location,string,string,constraint,list[constraint],canonTerm,canonTerm,tipe).

  public canonOther ::= integrity(location,canonCond)
           | expShow(location,canonTerm).

  public type
  canonRule ::= clause(location,string,canonTerm,canonCond)
            | equation(location,string,canonTerm,canonTerm,canonCond)
            | vrDef(location,string,canonTerm,canonCond)
            | clRule(location,string,canonTerm,canonTerm,canonCond,tipe)
            | grRule(location,string,canonTerm,canonNT,canonNT)
            | tpRule(location,tipe).

  public type
  canonTerm ::= v(location,string)
            | int(integer)
            | flt(float)
            | str(string)
            | apply(location,canonTerm,canonTerm)
            | tpl(list[canonTerm])
            | whre(canonTerm,canonCond)
            | condExp(location,canonCond,canonTerm,canonTerm)
            | lambda(canonRule)
            | theta(list[canonDef],list[canonOther])
            | dot(location,canonTerm,string)
            | over(location,canonTerm,list[constraint])
            | mtd(location,string).

  public type
  canonCond ::= trueCond
            | falseCond
            | conjCond(canonCond,canonCond)
            | disjCond(canonCond,canonCond)
            | condCond(canonCond,canonCond,canonCond)
            | unifyCond(location,canonTerm,canonTerm)
            | oneCond(canonCond)
            | negCond(canonCond)
            | forallCond(canonCond,canonCond)
            | callCond(location,canonTerm,canonTerm)
            | isTrue(canonTerm)
            | phraseCond(location,canonNT,canonTerm,canonTerm).

  public type
  canonNT ::= grTerms(list[(location,canonTerm,canonTerm)])
          | grCall(location,canonTerm,canonTerm)
          | grTest(canonCond)
          | grOne(canonNT)
          | grNeg(canonNT)
          | grAhed(canonNT)
          | grDisj(canonNT,canonNT)
          | grConj(canonNT,canonNT)
          | grCond(canonNT,canonNT,canonNT)
          | grDip(canonTerm,canonCond).

  public implementation display[canonPkg] <= {
    disp(P) => dispPkg(P)
  }

  public implementation display[pkgSpec] <= {
    disp(PSpec) => dispPkgSpec(PSpec).
  }

  private dispPkgSpec:(pkgSpec)=>ss.
  dispPkgSpec(pkgSpec(Pk,_,_,_,_,_,_)) => disp(Pk).

  public implementation display[canonDef] <= {
    disp(C) => dispDef(C)
  }

  public implementation display[canonTerm] <= {
    disp(T) => dispTerm(T).
  }

  public implementation display[canonCond] <= {
    disp(C) => dispCond(C)
  }

  public implementation display[canonRule] <= {
    disp(C) => dispRule(C)
  }

  public implementation display[canonNT] <= {
    disp(C) => dispNT(C)
  }

  public implementation display[visibility] <= {
    disp(priVate) => ss("private").
    disp(pUblic) => ss("public").
  }

  public implementation display[canonOther] <= {
    disp(O) => dispOther(O).
  }

  private dispPkg:(canonPkg) => ss.
  dispPkg(canonPkg(Pkg,Imps,Defs,Others)) => ssSeq([ss("package: "),disp(Pkg),ss("\n"),ssSeq(dispDefs(Defs)),ss("Others:\n"),..dispOthers(Others)]).

  private dispDef:(canonDef) => ss.
  dispDef(funDef(Lc,Nm,Tp,Cx,Rules)) => ssSeq([ss(" function @ "),disp(Lc),ss("\n"),ss(Nm),ss(":"),disp(Tp),ss("\n"),ssSeq(dispRules(Rules))]).
  dispDef(relDef(Lc,Nm,Tp,Cx,Rules)) => ssSeq([ss(" relDef @ "),disp(Lc),ss("\n"),ss(Nm),ss(":"),disp(Tp),ss("\n"),ssSeq(dispRules(Rules))]).
  dispDef(grammDef(Lc,Nm,Tp,Cx,Rules)) => ssSeq([ss(" grammDef @ "),disp(Lc),ss("\n"),ss(Nm),ss(":"),disp(Tp),ss("\n"),ssSeq(dispRules(Rules))]).
  dispDef(classDef(Lc,Nm,Tp,Cx,Rules,Face)) => ssSeq([ss(" class@ "),disp(Lc),ss("\n"),ss(Nm),ss(":"),disp(Tp),ss("\n"),ssSeq(dispRules(Rules))]).
  dispDef(varDef(Lc,Nm,Tp,Cx,Exp,trueCond)) => ssSeq([ss(" var @ "),disp(Lc),ss("\n"),ss(Nm),ss(":"),disp(Tp),ss("\n"),ss(Nm),ss("="),dispTerm(Exp)]).
  dispDef(varDef(Lc,Nm,Tp,Cx,Exp,C)) => ssSeq([ss(" var @ "),disp(Lc),ss("\n"),ss(Nm),ss(":"),disp(Tp),ss("\n"),ss(Nm),ss("="),dispTerm(Exp),ss(":-"),dispCond(C)]).
  dispDef(typeDef(Lc,Nm,Tp,TpDef)) => ssSeq([ss(" type @ "),disp(Lc),ss("\n"),disp(TpDef)]).
  dispDef(otherDef(Lc,C)) => ssSeq([ss("other @" ),disp(Lc),ss("\n"),disp(C),ss("\n")]).
  dispDef(cnDefn(Lc,_,conEntry(N,Nm,Con,B))) => ssSeq([ss(" contract: @ "),disp(Lc),ss("\n"),disp(Con),ss("<~"),disp(B)]).
  dispDef(implDef(Lc,_,ImplNm,Con,_,Hd,T,_)) => ssSeq([ss(" implementation: "),ss(ImplNm),ss(" @ "),disp(Lc),ss("\n"),disp(Con),ss("<="),dispTerm(Hd),ss("=>"),dispTerm(T)]).

  private dispDefs:(list[canonDef]) => list[ss].
  dispDefs([]) => [].
  dispDefs([D,..L]) => [dispDef(D),ss("\n"),..dispDefs(L)].

  private dispRule:(canonRule) => ss.
  dispRule(clause(_,Nm,Hed,trueCond)) => ssSeq([ss(Nm),dispTerm(Hed)]).
  dispRule(clause(_,Nm,Hed,Body)) => ssSeq([ss(Nm),dispTerm(Hed),ss(":-"),dispCond(Body)]).
  dispRule(equation(_,Nm,L,R,trueCond)) => ssSeq([ss(Nm),dispTerm(L),ss("=>"),dispTerm(R)]).
  dispRule(equation(_,Nm,L,R,Body)) => ssSeq([ss(Nm),dispTerm(L),ss("=>"),dispTerm(R),ss(":-"),dispCond(Body)]).
  dispRule(clRule(_,Nm,L,R,trueCond,_)) => ssSeq([dispTerm(L),ss("<="),dispTerm(R)]).
  dispRule(clRule(_,Nm,L,R,C,_)) => ssSeq([dispTerm(L),ss("<="),dispTerm(R),ss(":-"),dispCond(C)]).
  dispRule(grRule(_,Nm,L,grTerms([]),R)) => ssSeq([ss(Nm),dispTerm(L),ss("-->"),dispNT(R)]).
  dispRule(grRule(_,Nm,L,A,R)) => ssSeq([ss(Nm),dispTerm(L),ss(","),dispNT(A),ss("-->"),dispNT(R)]).
  dispRule(tpRule(_,T)) => disp(T).

  private dispRules:(list[canonRule]) => list[ss].
  dispRules([]) => [].
  dispRules([Rl,..L]) => [dispRule(Rl),ss(".\n"),..dispRules(L)].

  private dispOther:(canonOther) => ss.
  dispOther(integrity(Lc,C)) => ssSeq([ss(" assert@ "),disp(Lc),ss("\n"),dispCond(C),ss("\n")]).
  dispOther(expShow(Lc,E)) => ssSeq([ss(" show@ "),disp(Lc),ss("\n"),dispTerm(E),ss("\n")]).


  private dispOthers:(list[canonOther]) => list[ss].
  dispOthers([]) => [].
  dispOthers([Rl,..L]) => [dispOther(Rl),..dispOthers(L)].

  private showVars:(list[string]) => list[ss].
  showVars([]) => [].
  showVars([V,..L]) => [ss("all "),ss(V),..showMoreVars(L)].

  private showMoreVars:(list[string]) => list[ss].
  showMoreVars([]) => [ss("~~")].
  showMoreVars([V,..L]) => [ss(", "),ss(V),..showMoreVars(L)].

  private dispTerm:(canonTerm)=>ss.
  dispTerm(v(_,Nm)) => ss(Nm).
  dispTerm(int(Ix)) => ss(Ix::string).
  dispTerm(flt(Dx)) => ss(Dx::string).
  dispTerm(str(Sx)) => ssSeq([ss("\""),ss(Sx),ss("\"")]).
  dispTerm(apply(_,Op,Arg)) => ssSeq([dispTerm(Op),dispTerm(Arg)]).
  dispTerm(tpl([])) => ss("()").
  dispTerm(tpl([E,..L])) => ssSeq([ss("("),dispTerm(E),ssSeq(dispEls(L)),ss(")")]).
  dispTerm(whre(T,C)) => ssSeq([dispTerm(T),ss("@@"),dispCond(C)]).
  dispTerm(condExp(_,T,E,F)) => ssSeq([ss("("),dispCond(T),ss("?"),dispTerm(E),ss("|"),dispTerm(F),ss(")")]).
  dispTerm(dot(_,R,F)) => ssSeq([dispTerm(R),ss("."),ss(F)]).
  dispTerm(over(_,T,C)) => ssSeq([disp(C),ss("|:"),dispTerm(T)]).
  dispTerm(mtd(_,M)) => ss(M).
  dispTerm(lambda(R)) => ssSeq([ss("<"),dispRule(R),ss(">")]).
  dispTerm(theta(D,O)) => ssSeq([ss("{"),ssSeq(dispDefs(D)),ssSeq(dispOthers(O)),ss("}")]).

  private dispEls:(list[canonTerm]) => list[ss].
  dispEls([]) => [].
  dispEls([E,..L]) => [ss(", "),dispTerm(E),..dispEls(L)].

  private dispCond:(canonCond) => ss.
  dispCond(trueCond) => ss("true").
  dispCond(falseCond) => ss("false").
  dispCond(callCond(_,Op,Arg)) => ssSeq([dispTerm(Op),dispTerm(Arg)]).
  dispCond(conjCond(A,B)) => ssSeq([dispCond(A),ss(","),dispCond(B)]).
  dispCond(disjCond(A,B)) => ssSeq([ss("("),dispCond(A),ss("|"),dispCond(B),ss(")")]).
  dispCond(condCond(T,A,B)) => ssSeq([ss("("),dispCond(T),ss("?"),dispCond(A),ss("|"),dispCond(B),ss(")")]).
  dispCond(unifyCond(_,L,R)) => ssSeq([dispTerm(L),ss("="),dispTerm(R)]).
  dispCond(oneCond(A)) => ssSeq([ss("("),dispCond(A),ss(")!")]).
  dispCond(negCond(A)) => ssSeq([ss("\\+("),dispCond(A),ss(")")]).
  dispCond(isTrue(A)) => ssSeq([ss("is true ("),dispTerm(A),ss(")")]).
  dispCond(forallCond(A,B)) => ssSeq([ss("("),dispCond(A),ss("*>"),dispCond(B),ss(")")]).

  private dispNT:(canonNT) => ss.
  dispNT(grTerms(Ts)) => ssSeq([ss("["),ssSeq(dispTerminals(Ts)),ss("]")]).
  dispNT(grCall(_,Op,Arg)) => ssSeq([dispTerm(Op),dispTerm(Arg)]).
  dispNT(grTest(C)) => ssSeq([ss("{"),dispCond(C),ss("}")]).
  dispNT(grOne(N)) => ssSeq([ss("("),dispNT(N),ss(")!")]).
  dispNT(grNeg(N)) => ssSeq([ss("\\+("),dispNT(N),ss(")")]).
  dispNT(grAhed(N)) => ssSeq([ss("("),dispNT(N),ss(")+")]).
  dispNT(grDisj(L,R)) => ssSeq([ss("("),dispNT(L),ss("|"),dispNT(R),ss(")")]).
  dispNT(grConj(L,R)) => ssSeq([dispNT(L),ss(","),dispNT(R)]).
  dispNT(grCond(T,L,R)) => ssSeq([ss("("),dispNT(T),ss("?"),dispNT(L),ss("|"),dispNT(R),ss(")")]).

  private dispTerminals:(list[(location,canonTerm,canonTerm)]) => list[ss].
  dispTerminals([]) => [].
  dispTerminals([(_,_,T)]) => [dispTerm(T)].
  dispTerminals([(_,_,T),..L]) => [dispTerm(T),ss(","),..dispTerminals(L)].

  public relocate:(canonTerm,location) => canonTerm.
  relocate(v(_,Nm),Lc) => v(Lc,Nm).
  relocate(mtd(_,Nm),Lc) => mtd(Lc,Nm).
  relocate(apply(_,Op,Ar),Lc) => apply(Lc,Op,Arg).
}
