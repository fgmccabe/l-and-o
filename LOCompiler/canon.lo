lo.comp.canon {
  import lo.
  import lo.comp.location.
  import lo.comp.types.

  public type visibility ::= priVate | pUblic.

  public type
  canonPkg ::= canonPkg(location,string,list[(string,visibility)],list[canonDef],list[canonOther],list[constraint],list[constraint]).

  public type
  canonDef ::= funDef(location,string,tipe,list[canonRule])
           |   relDef(location,string,tipe,list[canonRule])
           |   grammDef(location,string,tipe,list[canonRule])
           |   classDef(location,string,tipe,list[canonRule])
           |   enumDef(location,string,tipe,list[canonRule])
           |   varDef(location,string,tipe,canonTerm,canonCond)
           |   otherDef(location,canonOther)
           |   typeDef(location,string,tipe,tipe)
           |   cnDefn(location,string,constraint,tipe)
           |   implDef(location,constraint,list[canonDef]).

  public type canonOther ::= integrity(location,canonCond)
           | expShow(location,canonTerm).

  public type
  canonRule ::= clause(location,string,canonTerm,canonCond)
             | equation(location,string,canonTerm,canonTerm,canonCond)
             | vrDef(location,string,canonTerm,canonCond)
             | clRule(location,string,canonTerm,canonTerm,canonCond,tipe)
             | clBody(location,string,canonTerm,list[canonDef],list[canonOther],list[canonDef])
             | grRule(location,canonTerm,list[canonTerm],canonNT)
             | tpRule(location,tipe).

  public type 
  canonTerm ::= v(string)
            | int(integer)
            | flt(float)
            | str(string)
            | apply(location,canonTerm,canonTerm)
            | tpl(list[canonTerm])
            | whre(canonTerm,canonCond)
            | condExp(canonCond,canonTerm,canonTerm)
            | lambda(canonRule)
            | dot(canonTerm,string)
            | dct(list[(canonTerm,canonTerm)])
            | over(canonTerm,list[constraint])
            | mtd(string).

  public type
  canonCond ::= trueCond
            | falseCond
            | conjCond(canonCond,canonCond)
            | disjCond(canonCond,canonCond)
            | condCond(canonCond,canonCond,canonCond)
            | unifyCond(canonTerm,canonTerm)
            | oneCond(canonCond)
            | negCond(canonCond)
            | forallCond(canonCond,canonCond)
            | goal(location,canonTerm,canonTerm)
            | phraseCond(location,canonNT,canonTerm,canonTerm).

  public type
  canonNT ::= grTerms(list[(location,string,canonTerm)])
          | grCall(location,canonTerm,canonTerm)
          | grTest(canonCond)
          | grOne(canonNT)
          | grNeg(canonNT)
          | grAhed(canonNT)
          | grDisj(canonNT,canonNT)
          | grConj(canonNT,canonNT)
          | grCond(canonNT,canonNT,canonNT)
          | grDip(canonTerm,canonCond).

  public implementation display[canonPkg] .. {
    disp(P) => dispPkg(P)
  }

  public implementation display[canonDef] .. {
    disp(C) => dispDef(C)
  }

  public implementation display[canonTerm] .. {
    disp(T) => dispTerm(T).
  }

  public implementation display[canonCond] .. {
    disp(C) => dispCond(C)
  }

  public implementation display[canonRule] .. {
    disp(C) => dispRule(C)
  }

  public implementation display[canonNT] .. {
    disp(C) => dispNT(C)
  }

  public implementation display[visibility] .. {
    disp(priVate) => ss("private").
    disp(pUblic) => ss("public").
  }

  public implementation display[canonOther] .. {
    disp(integrity(_,C)) => dispCond(C).
    disp(expShow(_,E)) => dispTerm(E).
  }

  private dispPkg:(canonPkg) => ss.
  dispPkg(canonPkg(Lc,Nm,Imps,Defs,Cons,Impls)) => ssSeq([ss("package: "),ss(Nm),ss("@"),disp(Lc),ss("\n"),ssSeq(dispDefs(Defs))]).

  private dispDef:(canonDef) => ss.
  dispDef(funDef(Lc,Nm,Tp,Rules)) => ssSeq([ss(" function: "),ss(Nm),ss("@"),disp(Lc),ss("\n"),ssSeq(dispRules(Rules))]).
  dispDef(relDef(Lc,Nm,Tp,Rules)) => ssSeq([ss(" relDef: "),ss(Nm),ss("@"),disp(Lc),ss("\n"),ssSeq(dispRules(Rules))]).
  dispDef(grammDef(Lc,Nm,Tp,Rules)) => ssSeq([ss(" grammDef: "),ss(Nm),ss("@"),disp(Lc),ss("\n"),ssSeq(dispRules(Rules))]).
  dispDef(classDef(Lc,Nm,Tp,Rules)) => ssSeq([ss(" class: "),ss(Nm),ss("@"),disp(Lc),ss("\n"),ssSeq(dispRules(Rules))]).
  dispDef(varDef(Lc,Nm,Tp,Exp,trueCond)) => ssSeq([ss(" var: "),ss(Nm),ss("@"),disp(Lc),ss("\n"),ss(Nm),ss("="),dispTerm(Exp)]).
  dispDef(varDef(Lc,Nm,Tp,Exp,C)) => ssSeq([ss(" var: "),ss(Nm),ss("@"),disp(Lc),ss("\n"),ss(Nm),ss("="),dispTerm(Exp),ss(":-"),dispCond(C)]).
  dispDef(typeDef(Lc,Nm,Tp,TpDef)) => ssSeq([ss(" type: "),ss(Nm),ss("@"),disp(Lc),ss("\n"),disp(TpDef)]).
  dispDef(otherDef(Lc,C)) => ssSeq([ss("other: "),ss("@"),disp(Lc),ss("\n"),disp(C)]).
  dispDef(cnDefn(Lc,Nm,Con,B)) => ssSeq([ss(" contract: "),ss(Nm),ss("@"),disp(Lc),ss("\n"),disp(Con),ss("<~"),disp(B)]).
  dispDef(implDef(Lc,Con,D)) => ssSeq([ss(" implementation: "),ss("@"),disp(Lc),ss("\n"),disp(Con),ss(".."),ssSeq(dispDefs(D))]).

  private dispDefs:(list[canonDef]) => list[ss].
  dispDefs([]) => [].
  dispDefs([D,..L]) => [dispDef(D),ss("\n"),..dispDefs(L)].

  private dispRule:(canonRule) => ss.
  dispRule(clause(_,_,Hed,trueCond)) => dispTerm(Hed).
  dispRule(clause(_,_,Hed,Body)) => ssSeq([dispTerm(Hed),ss(":-"),dispCond(Body)]).
  dispRule(equation(_,_,L,R,trueCond)) => ssSeq([dispTerm(L),ss("=>"),dispTerm(R)]).
  dispRule(equation(_,_,L,R,Body)) => ssSeq([dispTerm(L),ss("=>"),dispTerm(R),ss(":-"),dispCond(Body)]).
  dispRule(clRule(_,_,L,R,trueCond,_)) => ssSeq([dispTerm(L),ss("<="),dispTerm(R)]).
  dispRule(clRule(_,_,L,R,C,_)) => ssSeq([dispTerm(L),ss("<="),dispTerm(R),ss(":-"),dispCond(C)]).
  dispRule(clBody(_,_,L,B,_,_)) => ssSeq([dispTerm(L),ss("{"),ssSeq(dispDefs(B)),ss("\n}")]).
  dispRule(grRule(_,L,[],R)) => ssSeq([dispTerm(L),ss("-->"),dispNT(R)]).
  dispRule(grRule(_,L,A,R)) => ssSeq([dispTerm(L),ss(","),ssSeq(dispEls(A)),ss("-->"),dispNT(R)]).
  dispRule(tpRule(_,T)) => disp(T).



  private dispRules:(list[canonRule]) => list[ss].
  dispRules([]) => [].
  dispRules([Rl,..L]) => [dispRule(Rl),..dispRules(L)].

  private showVars:(list[string]) => list[ss].
  showVars([]) => [].
  showVars([V,..L]) => [ss("all "),ss(V),..showMoreVars(L)].

  private showMoreVars:(list[string]) => list[ss].
  showMoreVars([]) => [ss("~~")].
  showMoreVars([V,..L]) => [ss(", "),ss(V),..showMoreVars(L)].

  private dispTerm:(canonTerm)=>ss.
  dispTerm(v(Nm)) => ss(Nm).
  dispTerm(int(Ix)) => ss(Ix::string).
  dispTerm(flt(Dx)) => ss(Dx::string).
  dispTerm(str(Sx)) => ssSeq([ss("\""),ss(Sx),ss("\"")]).
  dispTerm(apply(_,Op,Arg)) => ssSeq([dispTerm(Op),dispTerm(Arg)]).
  dispTerm(tpl([])) => ss("()").
  dispTerm(tpl([E,..L])) => ssSeq([ss("("),dispTerm(E),ssSeq(dispEls(L)),ss(")")]).
  dispTerm(whre(T,C)) => ssSeq([dispTerm(T),ss("@@"),dispCond(C)]).
  dispTerm(condExp(T,E,F)) => ssSeq([ss("("),dispCond(T),ss("?"),dispTerm(E),ss("|"),dispTerm(F),ss(")")]).
  dispTerm(dot(R,F)) => ssSeq([dispTerm(R),ss("."),ss(F)]).
  dispTerm(over(T,C)) => ssSeq([disp(C),ss("|:"),dispTerm(T)]).
  dispTerm(mtd(M)) => ss(M).
  dispTerm(lambda(R)) => ssSeq([ss("<"),dispRule(R),ss(">")]).

  private dispEls:(list[canonTerm]) => list[ss].
  dispEls([]) => [].
  dispEls([E,..L]) => [ss(", "),dispTerm(E),..dispEls(L)].

  private dispCond:(canonCond) => ss.
  dispCond(trueCond) => ss("true").
  dispCond(falseCond) => ss("false").
  dispCond(goal(_,Op,Arg)) => ssSeq([dispTerm(Op),dispTerm(Arg)]).
  dispCond(conjCond(A,B)) => ssSeq([dispCond(A),ss(","),dispCond(B)]).
  dispCond(disjCond(A,B)) => ssSeq([ss("("),dispCond(A),ss("|"),dispCond(B),ss(")")]).
  dispCond(condCond(T,A,B)) => ssSeq([ss("("),dispCond(T),ss("?"),dispCond(A),ss("|"),dispCond(B),ss(")")]).
  dispCond(unifyCond(L,R)) => ssSeq([dispTerm(L),ss("="),dispTerm(R)]).
  dispCond(oneCond(A)) => ssSeq([ss("("),dispCond(A),ss(")!")]).
  dispCond(negCond(A)) => ssSeq([ss("\\+("),dispCond(A),ss(")")]).
  dispCond(forallCond(A,B)) => ssSeq([ss("("),dispCond(A),ss("*>"),dispCond(B),ss(")")]).

  private dispNT:(canonNT) => ss.
  dispNT(grTerms(Ts)) => ssSeq([ss("["),ssSeq(dispTerminals(Ts)),ss("]")]).
  dispNT(grCall(_,Op,Arg)) => ssSeq([dispTerm(Op),dispTerm(Arg)]).
  dispNT(grTest(C)) => ssSeq([ss("{"),dispCond(C),ss("}")]).
  dispNT(grOne(N)) => ssSeq([ss("("),dispNT(N),ss(")!")]).
  dispNT(grNeg(N)) => ssSeq([ss("\\+("),dispNT(N),ss(")")]).
  dispNT(grAhed(N)) => ssSeq([ss("("),dispNT(N),ss(")+")]).
  dispNT(grDisj(L,R)) => ssSeq([ss("("),dispNT(L),ss("|"),dispNT(R),ss(")")]).
  dispNT(grConj(L,R)) => ssSeq([dispNT(L),ss(","),dispNT(R)]).
  dispNT(grCond(T,L,R)) => ssSeq([ss("("),dispNT(T),ss("?"),dispNT(L),ss("|"),dispNT(R),ss(")")]).

  private dispTerminals:(list[(location,string,canonTerm)]) => list[ss].
  dispTerminals([]) => [].
  dispTerminals([(_,_,T)]) => [dispTerm(T)].
  dispTerminals([(_,_,T),..L]) => [dispTerm(T),ss(","),..dispTerminals(L)].
}