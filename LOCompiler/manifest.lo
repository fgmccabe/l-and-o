lo.comp.manifest{
  import lo.
  import lo.resources.
  import lo.uri.
  import lo.comp.package.
  import lo.json.

  public type manifest ::= manifest(list[manifestEntry]).

  -- A manifest entry looks like:
  -- packageName : { (version:file[uri])* }

  type manifestEntry ::= manifestEntry(string,list[(version,uri,string)]).

  public readManifest:(uri) => manifest.
  readManifest(u) => m :- parseJson(j) %% getResource(u), jsonManifest(j,m).

  public flushManifest:(uri,manifest){}.
  flushManifest(Root,M) :-
    putResource(Root,flatten(disp(manifestJson(M)))).

  jsonManifest:(json,manifest){}.
  jsonManifest(jColl(L),manifest(M)) :-
    jsonEntries(L,M).

  jsonEntries:(map[string,json],list[manifestEntry]){}.
  jsonEntries(M,L) :- L=pairs(M)//(((K,V))=>jsonEntry(K,V)).

  jsonEntry:(string,json)=>manifestEntry.
  jsonEntry(P,jColl(Vs)) => manifestEntry(P,pairs(Vs)//(((K,V))=>jsonVersion(P,K,V))).

  jsonVersion:(string,string,json) => (version,uri,string).
  jsonVersion(P,"*",jColl(Dtl)) => (defltVersion,parseUri(Src),Code) :-
    present(Dtl,"source",jTxt(Src)),
    present(Dtl,"code",jTxt(Code)).
  jsonVersion(P,V,jColl(Dtl)) => (vers(V),parseUri(Src),Code) :-
    present(Dtl,"source",jTxt(Src)),
    present(Dtl,"code",jTxt(Code)).

  manifestJson:(manifest)=>json.
  manifestJson(manifest(E)) => jColl(foldLeft(entryJson,[],E)).

  entryJson:(map[string,json],manifestEntry) => map[string,json].
  entryJson(M,manifestEntry(P,V)) => M[P->jColl(foldLeft(versionJson,[],V))].

  versionJson:(map[string,json],(version,uri,string)) => map[string,json].
  versionJson(M,(defltVersion,U,S)) => M["*"->jColl(["source"->jTxt(U::string),"code"->jTxt(S)])].

  -- Displaying a manifest
  public implementation display[manifest] <= {
    disp(manifest(E)) => ssSeq([ss("manifest"),ss("{\n"),ssSeq(showEntries(E)),ss("}\n")]).
  }

  showEntries:(list[manifestEntry]) => list[ss].
  showEntries([]) => [].
  showEntries([E,..L]) => [showEntry(E),..showEntries(L)].

  showEntry:(manifestEntry) => ss.
  showEntry(manifestEntry(Pk,Versions)) => ssSeq([ss("  "),ss(Pk),ss(":{\n"),ssSeq(showVersions(Versions)),ss("  }\n")]).

  showVersions:(list[(version,uri,string)]) => list[ss].
  showVersions([]) => [].
  showVersions([V,..M]) => [showVersion(V),..showVersions(M)].

  showVersion:((version,uri,string)) => ss.
  showVersion((V,SrcUri,CodeFn)) => ssSeq([ss("    "),disp(V),ss("="),ss(CodeFn),ss("["),disp(SrcUri),ss("]\n")]).

  -- Simple API to manipulate entries in a mAnifest

  public locateVersion:(manifest,string,version,version,uri,string){}.
  locateVersion(manifest(Entries),Pkg,Vers,Act,SrcUri,CodeFn) :-
    manifestEntry(Pkg,V) in Entries,
    getVersion(Vers,Act,V,SrcUri,CodeFn).

  getVersion:(version,version,list[(version,uri,string)],uri,string){}.
  getVersion(Vers,Vers,V,SrcUri,CodeFn) :- (Vers,SrcUri,CodeFn) in V!.
  getVersion(defltVersion,Act,V,SrcUri,CodeFn) :- (Act,SrcUri,CodeFn) in V!.

  public addToManifest:(manifest,uri,string,version,string) => manifest.
  addToManifest(manifest(M),SrcUri,Pkg,Version,CodeFn) => manifest(addEntry(M,SrcUri,Pkg,Version,CodeFn)).

  addEntry:(list[manifestEntry],uri,string,version,string) => list[manifestEntry].
  addEntry([],SrcUri,Pkg,Version,CodeFn) => [(manifestEntry(Pkg,[(Version,SrcUri,CodeFn)]))].
  addEntry([manifestEntry(Pkg,Vers),..E],SrcUri,Pkg,Version,CodeFn) => [manifestEntry(Pkg,addVersion(Vers,SrcUri,Version,CodeFn)),..E].
  addEntry([E,..M],SrcUri,Pkg,Version,CodeFn) => [E,..addEntry(M,SrcUri,Pkg,Version,CodeFn)].

  addVersion:(list[(version,uri,string)],uri,version,string) => list[(version,uri,string)].
  addVersion([],SrcUri,Vers,CodeFn) => [(Vers,SrcUri,CodeFn)].
  addVersion([(Vers,_,_),..V],SrcUri,Vers,CodeFn) => [(Vers,SrcUri,CodeFn),..V] . -- replace version
  addVersion([V,..M],SrcUri,Vers,CodeFn) => [V,..addVersion(M,SrcUri,Vers,CodeFn)].
}
