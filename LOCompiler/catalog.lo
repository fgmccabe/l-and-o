lo.comp.catalog{
  import lo.
  import lo.uri.
  import lo.resources.
  import lo.comp.misc.
  import lo.comp.package.
  import lo.comp.parseutils.

  public type catalog ::= cat(list[catEntry]).

  private type catEntry ::= catEntries(map[pkg,uri]) | default(uri) | version(version) | base(uri).
  
  public locateCatalog:(uri) => catalog.
  locateCatalog(Uri) => Cat :-
    CatURI = resolveUri(Uri,relUri(localRsrc(relPath(["catalog"])),noQ)),
    parseCatalog(getResource(CatUri),CatURI,Cat).

  public resolveCatalog:(catalog,pkg,uri){}.
  resolveCatalog(cat(Cat),Nm,resolveUri(Base,U)) :-
    catEntries(Map) in Cat,
    base(Base) in Cat,
    present(Map,Nm,U).
  resolveCatalog(cat(Cat),Nm,Uri) :-
    default(Deflt) in Cat,
    base(Base) in Cat,
    resolveCatalog(locateCatalog(resolveUri(Base,Deflt)),Nm,Uri).

  parseCatalog:(list[integer],uri,catalog){}.
  parseCatalog(Chrs,Uri,defaultBase(C,Uri)) :-
    tokens(Toks) %% Chrs,
    catalog(C) %% Toks.

  defaultBase:(catalog,uri) => catalog.
  defaultBase(cat(Stmts),Fl) => cat(replace(Stmts,base(_),base(Fl))).

  -- Tokenization

  private type token ::= catalg
    | content | version | bAse | deflt | lbrce | rbrce
    | thin_arrow | term | period | colon | hash | idn(list[integer]) | strg(list[integer]).

  tokens:(list[token]) --> list[integer].
  tokens(Toks) --> spaces(), moreToks(Toks).

  moreToks:(list[token]) --> list[integer].
  moreToks([]) --> eof.
  moreToks([Tok,..More]) --> token(Tok), tokens(More).

  token:(token) --> list[integer].
  token(catalg) --> "catalog".
  token(content) --> "content".
  token(verson) --> "version".
  token(bAse) --> "base".
  token(deflt) --> "default".
  token(lbrce) --> "{".
  token(rbrce) --> "}".
  token(thin_arrow) --> "->".
  token(T) --> ".", ((eof | " " | "\n") ? {T=term} | {T=period}).
  token(colon) --> ":".
  token(hash) --> "#".
  token(strg(Seq)) --> "\"", stringText(Seq), "\"".
  token(idn(Text)) --> iden(Text).

  stringText:(list[integer]) --> list[integer].
  stringText([]) --> [].
  stringText([C,..More]) --> "\\", quote(C), stringText(More).
  stringText([C,..More]) --> [C], { C \= 0c" }, stringText(More).

  quote:(integer) --> list[integer].
  quote(0c\n) --> "n".
  quote(0c") --> "\"".
  quote(0c') --> "'".
  quote(0c\t) --> "t".
  quote(C) --> [C].

  private catalog:(catalog) --> list[token].
  catalog(cat(Stmts)) -->
    [catalg, lbrce], catStmts(Stmts), [rbrce].

  private catStmts:(list[catEntry]) --> list[token].
  catStmts([St,..More]) --> catStmt(St), catStmts(More).
  catStmts([]) --> [].

  catStmt:(catEntry) --> list[token].
  catStmt(catEntries(Contents)) --> [content, lbrce], contents[||],Contents), [rbrce].
  catStmt(base(BaseUri)) --> [bAse, colon, strg(Base)], { parseableUri(Base,BaseUri) }, [term].
  catStmt(version(V)) --> [verson, colon], versn(V), [term].
  catStmt(default(CatUri)) --> [deflt, colon, strg(U)], { uriParse(CatUri)%%U }, [term].

  parseableUri:(list[integer],uri){}.
  parseableUri(Chrs,U) :- uriParse(U)%%Chrs.

  contents:(map[pkg,uri],map[pkg,uri]) --> list[token].
  contents(C,Cx) --> entry(C,C0), contents(C0,Cx).
  contents(C,C) --> [].
 
  entry:(map[pkg,uri],map[pkg,uri]) --> list[token].
  entry(C,put(C,Key,Uri)) --> package(Key), [thin_arrow,strg(U),term], {uriParse(Uri)%%U}.

  package:(pkg) --> list[token].
  package(pkg(stringify([Id,..Suf],[0c.]),V)) --> [idn(Id)], suffixes(Suf), versn(V).

  suffixes:(list[list[integer]]) --> list[token].
  suffixes([Id,..More]) --> [period, idn(Id)], suffixes(More).
  suffixes([]) --> [].

  versn:(version) --> list[token].
  versn(vers(stringify([F,..Vs],[0c.]))) --> [hash, idn(F)], vSegs(Vs).
  versn(defltVersion) --> [].

  vSegs:(list[list[integer]]) --> list[token].
  vSegs([V,..More]) --> [period, idn(V)], vSegs(More).
  vSegs([]) --> [].

  stringify:(list[list[integer]],list[integer])=>string.
  stringify(L,S) => 
    implode(multiCat(interleave(L,S))).
}