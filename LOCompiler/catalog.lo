lo.comp.catalog{
  import lo.
  import lo.json.
  import lo.uri.
  import lo.resources.
  import lo.comp.misc.
  import lo.comp.package.
  import lo.comp.parseutils.

  public catalog <~ {}.

  private cat:(map[string,uri],uri,version,option[uri]) <=> catalog.
  cat(M,B,V,D) <= {}.

  public locateCatalog:(uri) => catalog.
  locateCatalog(Uri) => Cat :-
    CatURI = resolveUri(Uri,relUri(localRsrc(relPath(["catalog"])),noQ)),
    parseCatalog(getResource(CatURI),CatURI,Cat).

  public resolveCatalog:(catalog,pkg,uri,pkg){}.
  resolveCatalog(cat(Map,Base,Vers,_),pkg(P,RV),resolveUri(Base,U),pkg(P,V)) :-
    present(Map,P,U),
    resolveVersion(RV,Vers,V).
  resolveCatalog(cat(_,Base,_,some(Deflt)),Rq,Uri,Pkg) :-
    resolveCatalog(locateCatalog(resolveUri(Base,Deflt)),Rq,Uri,Pkg).

  resolveVersion:(version,version,version){}.
  resolveVersion(defltVersion,V,V).
  resolveVersion(V,_,V).

  parseCatalog:(string,uri,catalog){}.
  parseCatalog(Chrs,Uri,Cat) :-
    parseJson(jColl(j)) %% explode(Chrs),
    Cat = foldMap(jsonStmt,cat([],Uri,defltVersion,none),j).

  jsonStmt:(string,json,catalog) => catalog.
  jsonStmt("content",jColl(jE),cat(M,U,V,B)) => cat(foldMap(jsonEntry,M,jE),U,V,B).
  jsonStmt("base",jTxt(tB),cat(M,_,V,D)) => cat(M,U,V,D) :- uriParse(U) %% explode(tB).
  jsonStmt("version",jTxt(V),cat(M,U,_,B)) => cat(M,U,vers(V),B).
  jsonStmt("default",jTxt(tD),cat(M,B,V,_)) => cat(M,U,V,some(D)) :- uriParse(D) %% explode(tD).
  jsonStmt(_,_,Cat) => Cat.

  jsonEntry:(string,json,map[string,uri]) => map[string,uri].
  jsonEntry(P,jTxt(tU),M) => M[P->U] :- uriParse(U) %% explode(tU).
}
