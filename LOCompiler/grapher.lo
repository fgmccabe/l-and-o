lo.comp.grapher{
  import lo.
  import lo.uri.
  import lo.repo.file.
  import lo.resources.
  import lo.topsort.

  import lo.comp.grammar.
  import lo.comp.abstract.
  import lo.comp.ast.
  import lo.comp.canon.
  import lo.comp.errors.
  import lo.comp.catalog.
  import lo.comp.package.
  import lo.comp.imports.
  import lo.comp.misc.

  public makeGraph:(list[pkg],fileRepo,catalog,report,report) => list[list[(pkg,list[pkg])]].
  makeGraph(Pkgs,Repo,Cat,Rp,Rpx) => G :-
    G = topsort(scanPkgs(Pkgs,Repo,Cat,[],Rp,Rpx)),
    showGroups(G).

  private implementation depends[(pkg,list[pkg])->>pkg] <= {
    defines((Pk,_),Rq) :- consistentPkg(Rq,Pk).
    references((Pk,I)) => I.
  }

  showGroups:(list[list[(pkg,list[pkg])]]){}.
  showGroups([]).
  showGroups([G,..L]) :-
    logMsg("---"),
    showGroup(G),
    showGroups(L).

  showGroup:(list[(pkg,list[pkg])]){}.
  showGroup([]).
  showGroup([P,..L]) :-
    showPkg(P),
    showGroup(L).

  showPkg:((pkg,list[pkg])){}.
  showPkg((P,I)) :-
    logMsg("\(P) --> \(I)").

  consistentPkg:(pkg,pkg){}.
  consistentPkg(pkg(P,V1),pkg(P,V2)) :- consistentVersion(V1,V2)!.

  consistentVersion:(version,version){}.
  consistentVersion(defltVersion,_).
  consistentVersion(vers(V),vers(V)).

  private graphPkgs:(list[(pkg,list[pkg])]) => list[list[(pkg,list[pkg])]].
  graphPkgs(Pkgs) => topsort(Pkgs).

  scanPkgs:(list[pkg],fileRepo,catalog,list[(pkg,list[pkg])],report,report) => list[(pkg,list[pkg])].
  scanPkgs([],_,_,SoFar,Rp,Rp) => SoFar.
  scanPkgs([Pkg,..Imports],Repo,Cat,SoFar,Rp,Rpx) => scanPkgs(Imports,Repo,Cat,scanPkg(Pkg,Repo,Cat,SoFar,Rp,Rp0),Rp0,Rpx).

  scanPkg:(pkg,fileRepo,catalog,list[(pkg,list[pkg])],report,report) => list[(pkg,list[pkg])].
  scanPkg(Rq,_,_,SoFar,Rp,Rp) => SoFar :-
    (Pkg,_) in SoFar,
    consistentPkg(Rq,Pkg).
  scanPkg(Pkg,Repo,Cat,SoFar,Rp,Rpx) => checkPkg(Spec,Repo,Cat,SoFar,Rp0,Rpx) :-
    packagePrologOk(Repo,Pkg),
    importPkg(Pkg,Repo,Spec,Rp,Rp0).
  scanPkg(Pkg,Repo,Cat,SoFar,Rp,Rpx) => scanFile(SrcUri,VPkg,Repo,Cat,SoFar,Rp,Rpx) :-
    resolveCatalog(Cat,Pkg,SrcUri,VPkg).
  scanPkg(Pkg,Repo,Cat,SoFar,Rp,Rpx) => SoFar :-
    reportError("cannot locate package \(Pkg)",std,Rp,Rpx).

  checkPkg:(pkgSpec,fileRepo,catalog,list[(pkg,list[pkg])],report,report) => list[(pkg,list[pkg])].
  checkPkg(pkgSpec(Pkg,_,_,_,_,_,Imports),Repo,Cat,SoFar,Rp,Rpx) => scanPkgs(Imported,Repo,Cat,[(Pkg,Imported),..SoFar],Rp,Rpx) :-
    Imported = projectOutPkgs(Imports).

  private projectOutPkgs:(list[(visibility,pkg)]) => list[pkg].
  projectOutPkgs([]) => [].
  projectOutPkgs([(_,Pkg),..L]) => [Pkg,..projectOutPkgs(L)].

  scanFile:(uri,pkg,fileRepo,catalog,list[(pkg,list[pkg])],report,report) => list[(pkg,list[pkg])].
  scanFile(Fl,Pkg,Repo,Cat,SoFar,Rp,Rpx) => scanPkgs(Imps,Repo,Cat,[(Pkg,Imps),..SoFar],Rp0,Rpx) :-
    Term = parseFile(Fl,Rp,Rp0),
    scanTerm(Term,Imps).

  scanTerm:(ast,list[pkg]){}.
  scanTerm(T,scanTheta(Th,[])) :-
    isBraceTerm(T,_,P,Th).

  scanTheta:(list[ast],list[pkg]) => list[pkg].
  scanTheta([],Imps) => Imps.
  scanTheta([St,..Stmts],Imports) => scanTheta(Stmts,scanStmt(St,Imports)).

  scanStmt:(ast,list[pkg]) => list[pkg].
  scanStmt(St,Imp) => scanStmt(El,Imp) :-
    isUnary(St,"public",_,El).
  scanStmt(St,Imp) => scanStmt(El,Imp) :-
    isUnary(St,"private",_,El).
  scanStmt(St,Imps) => [scanPkgName(P,defltVersion),..Imps] :-
    isUnary(St,"import",_,P).
  scanStmt(St,Imps) => Imps.

  scanPkgName:(ast,version) => pkg.
  scanPkgName(T,_) => pkg(packageName(P),vers("\(V)")) :-
    isBinary(T,"#",_,P,V).
  scanPkgName(T,V) => pkg(packageName(T),V).
}
