lo.comp.dict{
  import lo.comp.location.
  import lo.comp.types.
  import lo.comp.misc.
  import lo.comp.canon.
  import lo.comp.escapes.
  import lo.

  public
  vr ::= vr(canonTerm,tipe).

  public
  env ::= scope(map[string,typeDef],map[string,vr],list[constraint],map[string,conEntry],map[string,map[string,implEntry]]).

  public
  typeDef ::= tpDef(location,string,typeKind,tipe).

  public implementation display[env] <= {
    disp(E) => showEnv(E).
  }

  private showEnv:(env) => ss.
  showEnv(scope(Tps,Vars,Constraints,Contracts,Implementations)) => ssSeq([ss("scope types: "),disp(Tps),ss("\nvars: "),disp(Vars)]).

  implementation display[typeDef] <= {
    disp(D) => showTpDef(D).
  }

  private showTpDef:(typeDef)=>ss.
  showTpDef(tpDef(Lc,_,_,Face)) => ssSeq([ss("type @"),disp(Lc),ss("\nType def"),disp(Face),ss("\n")]).

  public implementation display[vr] <= {
    disp(D) => showVr(D).
  }

  private showVr:(vr)=>ss.
  showVr(vr(T,Tp)) => ssSeq([ss(" "),disp(T),ss(" |= "),disp(Tp),ss("\n")]).

  public
  typeInDict:(string,list[env],location,string,typeKind,tipe){}.
  typeInDict(Nm,Env,Lc,TpNm,K,Tp) :- typeInD(localTypeName(Nm),Env,tpDef(Lc,TpNm,K,Tp))!.

  private
  tpInDict:(string,list[env]) => option[typeDef].
  tpInDict(Nm,Env) => some(D) :- typeInD(localTypeName(Nm),Env,D).
  tpInDict(_,_) => none.

  public
  declareTypeExists:(string,location,tipe,list[env]) => list[env].
  declareTypeExists(Nm,Lc,Tp,Env) => declareType(Nm,Lc,Tp,Env).

  public declareType:(string,location,tipe,list[env]) => list[env].
  declareType(Nm,Lc,Tp,[scope(Types,Names,Cons,Contracts,Imps),..E]) =>
      [scope(Types[Nm->tpDef(Lc,typeNm(Core),typeKind(typeOp(Core)),Tp)],Names,Cons,Contracts,Imps),..E] :-
        Core = typeCore(Tp).

  private standardType:(string,tipe,list[env]) => list[env].
  standardType(Nm,Tp,[scope(Types,Names,Cons,Contracts,Imps),..E]) =>
      [scope(Types[Nm->tpDef(std,typeNm(Core),typeKind(Core),typeRule(Tp,faceType([])))],Names,Cons,Contracts,Imps),..E] :-
        Core = typeCore(Tp).

  private
  localTypeName:(string) => string.
  localTypeName(Nm) => pathSuffix(Nm,"*").

  private
  typeInD:(string,list[env],typeDef){}.
  typeInD(Key,[scope(Defs,_,_,_,_),.._],Def) :- present(Defs,Key,Def).
  typeInD(Key,[_,..Env],Def) :- typeInD(Key,Env,Def).

  public
  typeOfVar:(string,list[env])=>option[vr].
  typeOfVar(Nm,Env) =>  some(D) :-  varInD(Nm,Env,D).
  typeOfVar(_,_) => none.

  private
  varInD:(string,list[env],vr){}.
  varInD(Nm,[scope(_,Vars,_,_,_),.._],D) :- present(Vars,Nm,D).
  varInD(Nm,[_,..E],D) :- varInD(Nm,E,D).

  public
  isVar:(string,list[env],vr){}.
  isVar(Nm,_,vr(v(std,Nm),escapeType(Nm))) :- isEscape(Nm,_).
  isVar(Nm,Env,Def) :- varInD(Nm,Env,Def)!.

  public
  declareVar:(string,vr,list[env]) => list[env].
  declareVar(Nm,V,[scope(Tps,Nms,Cons,Contracts,Imps),..E]) => [scope(Tps,Nms[Nm->V],Cons,Contracts,Imps),..E].

  public
  topVars:(list[env]) => map[string,vr].
  topVars([scope(_,Vars,_,_,_),.._]) => Vars.

  public pushScope:(list[env]) => list[env].
  pushScope(E) => [scope([],[],[],[],[]),..E].

  public declareConstraint:(constraint,list[env]) => list[env].
  declareConstraint(C,[scope(Tps,Nms,Cons,Contracts,Imps),..E]) => [scope(Tps,Nms,[C,..Cons],Contracts,Imps),..E].

  public definedConstraint:(constraint,list[env]){}.
  definedConstraint(Cx,[scope(_,_,Cons,_,_),.._]) :-
    Cx in Cons.
  definedConstraint(Cx,[_,..E]) :-
    definedConstraint(Cx,E).

  public
  declareContract:(string,conEntry,list[env]) => list[env].
  declareContract(Nm,Con,[scope(Tps,Nms,Cons,Contracts,Imps),..E]) => [scope(Tps,Nms,Cons,Contracts[Nm->Con],Imps),..E].

  conInD:(string,list[env],conEntry){}.
  conInD(Nm,[scope(_,_,_,Cons,_),.._],Dec) :- present(Cons,Nm,Dec).
  conInD(Nm,[_,..Env],Con) :- conInD(Nm,Env,Con).

  public
  getContract:(string,list[env],conEntry){}.
  getContract(Nm,Env,Def) :-  conInD(Nm,Env,Def).

  public
  isContract:(string,list[env],conEntry){}.
  isContract(Nm,Env,Def) :- conInD(Nm,Env,Def)!.

  public
  declareImplementation:(string,string,implEntry,list[env]) => list[env].
  declareImplementation(Nm,ImplNm,Con,[scope(Tps,Nms,Cons,Contracts,Imps),..E]) => [scope(Tps,Nms,Cons,Contracts,Imps[Nm->I[ImplNm->Con]]),..E] :-  present(Imps,Nm,I) .
  declareImplementation(Nm,ImplNm,Con,[scope(Tps,Nms,Cons,Contracts,Imps),..E]) => [scope(Tps,Nms,Cons,Contracts,Imps[Nm->[ImplNm->Con]]),..E].

  impInD:(string,list[env],map[string,implEntry]){}.
  impInD(Nm,[scope(_,_,_,_,Impls),.._],Dec) :- present(Impls,Nm,Dec).
  impInD(Nm,[_,..Env],Con) :- impInD(Nm,Env,Con).

  public isImplemented:(constraint,list[env],implEntry){}.
  isImplemented(conTract(Nm,Args,Deps),Env,Impl) :-
    impInD(Nm,Env,Impls),
    present(Impls,implementationName(conTract(Nm,Args,Deps)),Impl).

  public allDefinedVars:(list[env]) => set[string].
  allDefinedVars(Env) => allVars(Env,emptySet).

  allVars:(list[env],set[string]) => set[string].
  allVars([],S) => S.
  allVars([scope(_,Vrs,_,Cons,Impls),..E],S) => allVars(E,implementations(Impls,varsInScope(Vrs,S))).

  varsInScope:(map[string,vr],set[string]) => set[string].
  varsInScope(V,E) => foldLeft(addMem,E,keys(V)).

  implementations:(map[string,map[string,implEntry]],set[string]) => set[string].
  implementations(Impls,Ex) => foldLeft(pickImplName,Ex,values(Impls)).

  pickImplName:(map[string,implEntry],set[string]) => set[string].
  pickImplName(M,Ex) => foldLeft(((I:implEntry),E)=>addMem(I.name,E),Ex,values(M)).

  public stdDict : list[env].
  stdDict = standardType("string",tipe("lo.core*string"),
              standardType("integer",tipe("lo.core*integer"),
                standardType("float",tipe("lo.core*float"),
                  pushScope([])))).
}
