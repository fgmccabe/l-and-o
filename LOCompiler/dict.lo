lo.comp.dict{
  import lo.comp.location.
  import lo.comp.types.
  import lo.comp.misc.
  import lo.comp.canon.
  import lo.

  public
  type vr ::= vr(location,canonTerm,tipe).

  public
  type env ::= scope(map[string,typeDef],map[string,vr],list[constraint],map[string,conEntry],map[string,map[string,implEntry]]).

  public
  type typeDef ::= tpDef(option[location],tipe,tipe).

  public
  typeInDict:(string,list[env],tipe){}.
  typeInDict(Nm,Env,Tp) :- typeInD(localTypeName(Nm),Env,tpDef(_,_,Tp))!.

  public isType:(string,list[env],option[location],tipe){}.
  isType(Nm,Env,Lc,Tp) :- typeInD(localTypeName(Nm),Env,tpDef(Lc,Tp,_))!.

  private
  tpInDict:(string,list[env]) => option[typeDef].
  tpInDict(Nm,Env) => some(D) :- typeInD(localTypeName(Nm),Env,D).
  tpInDict(_,_) => none.

  public
  declareTypeExists:(string,option[location],tipe,list[env]) => list[env].
  declareTypeExists(Nm,Lc,Tp,Env) => declareType(Nm,tpDef(Lc,Tp,voidType),Env).

  public declareType:(string,typeDef,list[env]) => list[env].
  declareType(Nm,Tp,[scope(Types,Names,Cons,Contracts,Imps),..E]) =>
      [scope(Types+[Nm->Tp],Names,Cons,Contracts,Imps),..E].

  private standardType:(string,tipe,list[env]) => list[env].
  standardType(Nm,Tp,[scope(Types,Names,Cons,Contracts,Imps),..E]) => 
      [scope(Types+[Nm->tpDef(none,Tp,typeRule(Tp,faceType([])))],Names,Cons,Contracts,Imps),..E].

  private
  localTypeName:(string) => string.
  localTypeName(Nm) => pathSuffix(Nm,"*").

  private
  typeInD:(string,list[env],typeDef){}.
  typeInD(Key,[scope(Defs,_,_,_,_),.._],Def) :- present(Defs,Key,Def).
  typeInD(Key,[_,..Env],Def) :- typeInD(Key,Env,Def).

  public
  typeOfVar:(string,list[env])=>option[vr].
  typeOfVar(Nm,Env) =>  some(D) :-  varInD(Nm,Env,D).
  typeOfVar(_,_) => none.

  private
  varInD:(string,list[env],vr){}.
  varInD(Nm,[scope(_,Vars,_,_,_),.._],D) :- present(Vars,Nm,D).
  varInD(Nm,[_,..E],D) :- varInD(Nm,E,D).

  public
  isVar:(string,list[env],vr){}.
  isVar(Nm,Env,Def) :- varInD(Nm,Env,Def)!.

  public
  declareVar:(string,vr,list[env]) => list[env].
  declareVar(Nm,V,[scope(Tps,Nms,Cons,Contracts,Imps),..E]) => [scope(Tps,Nms+[Nm->V],Cons,Contracts,Imps),..E].

  public
  topVars:(list[env]) => map[string,vr].
  topVars([scope(_,Vars,_,_,_),.._]) => Vars.

  public pushScope:(list[env]) => list[env].
  pushScope(E) => [scope([],[],[],[],[]),..E].

  public declareConstraint:(constraint,list[env]) => list[env].
  declareConstraint(C,[scope(Tps,Nms,Cons,Contracts,Imps),..E]) => [scope(Tps,Nms,[C,..Cons],Contracts,Imps),..E].

  public definedConstraint:(constraint,list[env]){}.
  definedConstraint(Cx,[scope(_,_,Cons,_,_),.._]) :-
    Cx in Cons.
  definedConstraint(Cx,[_,..E]) :-
    definedConstraint(Cx,E).

  public
  declareContract:(string,conEntry,list[env]) => list[env].
  declareContract(Nm,Con,[scope(Tps,Nms,Cons,Contracts,Imps),..E]) => [scope(Tps,Nms,Cons,Contracts+[Nm->Con],Imps),..E].

  conInD:(string,list[env],conEntry){}.
  conInD(Nm,[scope(_,_,_,Cons,_),.._],Dec) :- present(Cons,Nm,Dec).
  conInD(Nm,[_,..Env],Con) :- conInD(Nm,Env,Con).

  public
  getContract:(string,list[env],conEntry){}.
  getContract(Nm,Env,Def) :-  conInD(Nm,Env,Def).

  public
  isContract:(string,list[env],conEntry){}.
  isContract(Nm,Env,Def) :- conInD(Nm,Env,Def)!.

  public
  declareImplementation:(string,string,implEntry,list[env]) => list[env].
  declareImplementation(Nm,ImplNm,Con,[scope(Tps,Nms,Cons,Contracts,Imps),..E]) => [scope(Tp,Nms,Cons,Contracts,Imps+[Nm->I+[ImplNm->Con]]),..E] :-  present(Imps,Nm,I) .
  declareImplementation(Nm,ImplNm,Con,[scope(Tps,Nms,Cons,Contracts,Imps),..E]) => [scope(Tp,Nms,Cons,Contracts,Imps+[Nm->[ImplNm->Con]]),..E].

  impInD:(string,list[env],map[string,implEntry]){}.
  impInD(Nm,[scope(_,_,_,_,Impls),.._],Dec) :- present(Impls,Nm,Dec).
  impInD(Nm,[_,..Env],Con) :- impInD(Nm,Env,Con).

  public isImplemented:(constraint,list[env],implEntry){}.
  isImplemented(conTract(Nm,Args,Deps),Env,Impl) :- 
    impInD(Nm,Env,Impls), 
    present(Impls,implementationName(conTract(Nm,Args,Deps)),Impl).

  public stdDict : list[env].
  stdDict = standardType("string",tipe("lo.core*string"),
              standardType("integer",tipe("lo.core*integer"),
                standardType("float",tipe("lo.core*float"),
                  pushScope([])))).
}