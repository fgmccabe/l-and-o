lo.comp.dict{
  import lo.comp.location.
  import lo.comp.types.
  import lo.comp.misc.
  import lo.comp.canon.
  import lo.

  public
  type vr ::= vr(location,canonTerm,tipe).

  public
  type conDef ::= conDef(string,string,constraint,constraint,tipe).

  public
  type implDef ::= impl(string,constraint).

  public
  type env ::= scope(map[string,typeDef],map[string,vr],map[string,conDef],map[string,map[string,implDef]]).

  public
  type typeDef ::= tpDef(option[location],tipe,tipe).

  public
  typeInDict:(string,list[env],tipe){}.
  typeInDict(Nm,Env,Tp) :- typeInD(localTypeName(Nm),Env,tpDef(_,_,Tp))!.

  public isType:(string,list[env],option[location],tipe){}.
  isType(Nm,Env,Lc,Tp) :- typeInD(localTypeName(Nm),Env,tpDef(Lc,Tp,_))!.

  private
  tpInDict:(string,list[env]) => option[typeDef].
  tpInDict(Nm,Env) => some(D) :- typeInD(localTypeName(Nm),Env,D).
  tpInDict(_,_) => none.

  public
  declareTypeExists:(string,option[location],tipe,list[env]) => list[env].
  declareTypeExists(Nm,Lc,Tp,[scope(Types,Names,Cons,Imps),..E]) => 
      [scope(Types+{Nm->tpDef(Lc,Tp,voidType)},Names,Cons,Imps),..E].

  private standardType:(string,tipe,list[env]) => list[env].
  standardType(Nm,Tp,[scope(Types,Names,Cons,Imps),..E]) => 
      [scope(Types+{Nm->tpDef(none,Tp,typeRule(Tp,faceType([])))},Names,Cons,Imps),..E].

  private
  localTypeName:(string) => string.
  localTypeName(Nm) => pathSuffix(Nm,"*").

  private
  typeInD:(string,list[env],typeDef){}.
  typeInD(Key,[scope({Key->Def},_,_,_),.._],Dec).
  typeInD(Key,[_,..Env],Def) :- typeInD(Key,Env,Def).

  public
  typeOfVar:(string,list[env])=>option[vr].
  typeOfVar(Nm,Env) =>  some(D) :-  varInD(Nm,Env,D).
  typeOfVar(_,_) => none.

  private
  varInD:(string,list[env],vr){}.
  varInD(Nm,[scope(_,{Nm->D},_,_),.._],D).
  varInD(Nm,[_,..E],D) :- varInD(Nm,E,D).

  public
  isVar:(string,list[env],vr){}.
  isVar(Nm,Env,Def) :- varInD(Nm,Env,Def)!.

  public
  declareVar:(string,vr,list[env]) => list[env].
  declareVar(Nm,V,[scope(Tps,Nms,Cons,Imps),..E]) => [scope(Tps,Nms+{Nm->V},Cons,Imps),..E].

  public
  topVars:(list[env]) => map[string,vr].
  topVars([scope(_,Vars,_,_),.._]) => Vars.

  public pushScope:(list[env]) => list[env].
  pushScope(E) => [scope({},{},{},{}),..E].

  public
  declareContract:(string,conDef,list[env]) => list[env].
  declareContract(Nm,Con,[scope(Tps,Nms,Cons,Imps),..E]) => [scope(Tp,Nms,Cons+{Nm->Con},Imps),..E].

  conInD:(string,list[env],conDef){}.
  conInD(Nm,[scope(_,_,{Nm->Dec},_),.._],Dec).
  conInD(Nm,[_,..Env],Con) :- conInD(Nm,Env,Con).

  public
  getContract:(string,list[env]) => option[conDef].
  getContract(Nm,Env) =>  some(Def) :-  conInD(Nm,Env,Def) .
  getContract(_,_) => none.

  public
  isContract:(string,list[env],conDef){}.
  isContract(Nm,Env,Def) :- conInD(Nm,Env,Def)!.

  public
  declareImplementation:(string,string,implDef,list[env]) => list[env].
  declareImplementation(Nm,ImplNm,Con,[scope(Tps,Nms,Cons,Imps),..E]) => [scope(Tp,Nms,Cons,Imps+{Nm->I+{ImplNm->Con}}),..E] :-  present(Imps,Nm,I) .
  declareImplementation(Nm,ImplNm,Con,[scope(Tps,Nms,Cons,Imps),..E]) => [scope(Tp,Nms,Cons,Imps+{Nm->{ImplNm->Con}}),..E].

  impInD:(string,list[env],map[string,implDef]){}.
  impInD(Nm,[scope(_,_,_,{Nm->Dec}),.._],Dec).
  impInD(Nm,[_,..Env],Con) :- impInD(Nm,Env,Con).

  public
  isImplemented:(constraint,list[env],implDef){}.
  isImplemented(conTract(Nm,Args,Deps),Env,Impl) :- 
    impInD(Nm,Env,Impls), 
    present(Impls,implementationName(conTract(Nm,Args,Deps)),Impl).

  public stdDict : list[env].
  stdDict = standardType("string",tipe("lo.core*string"),
              standardType("integer",tipe("lo.core*integer"),
                standardType("float",tipe("lo.core*float"),
                  pushScope([])))).
}