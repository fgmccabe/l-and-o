lo.comp.lexer{
  import lo.
  import lo.comp.location.
  import lo.comp.token.
  import lo.comp.operators.

  -- Define the lexer for the L&O syntax

  tokenState <~ stream[integer].
  tokenState <~ { currLine:integer. currOff:integer. currCol:integer}.

  tkState:(list[integer],integer,integer,integer) <=> tokenState.
  tkState(Chars,Line,Off,Col) .. {
    eof() :- Chars = [].

    hdtl(0c\n,Next) :: Chars =. [0c\n,..Rest] :-- Next = tkState(Rest,Line+1,Off+1,0).
    hdtl(Ch,Next) :: Chars =. [Ch,..Rest] :-- Next = tkState(Rest,Line,Off+1,Col+1).

    cons(Ch) => tkState([Ch,..Chars],Line,Off,Col).

    currLine = Line.
    currOff = Off.
    currCol = Col.
  }.

  skipSpaces: () --> tokenState.
  skipSpaces() --> [0c ], skipSpaces().
  skipSpaces() --> [0c\t], skipSpaces().
  skipSpaces() --> [0c\n], skipSpaces().
  skipSpaces() --> [0c-, 0c-], ([0c ] | [0c\t]), lineComment(), skipSpaces().
  skipSpaces() --> [0c/, 0c*], blockComment(), skipSpaces().
  skipSpaces() --> [].

  lineComment:() --> tokenState.
  lineComment() --> [0c\n].
  lineComment() --> [_], lineComment().

  blockComment:() --> tokenState.
  blockComment() --> eof.
  blockComment() --> [0c*, 0c/].
  blockComment() --> [_], blockComment().
}