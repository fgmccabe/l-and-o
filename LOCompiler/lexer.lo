lo.comp.lexer{
  import lo.
  import lo.uri.
  import lo.resources.

  import lo.comp.location.
  import lo.comp.token.
  import lo.comp.operators.

  -- Define the lexer for the L&O syntax

  public tokenizeFile:(uri) => list[token].
  tokenizeFile(U) => Toks :-  tokenize(Toks) %% startState(explode(getResource(U)),getUriPath(U)).

  public tokenCodes:(list[integer],string) => list[token].
  tokenCodes(Chars,Pth) => Toks :- tokenize(Toks) %% startState(Chars,Pth).

  public getNTokens:(list[integer],string,integer) => list[token].
  getNTokens(Chars,Pth,Count) => Toks :- (skipSpaces(), allTokens(Toks,Count)) %% startState(Chars,Pth) ~ _.

  public type tokenState <~ {
    currentLocation:((integer,integer,integer,string)){}
  }.

  public
  startState:(list[integer],string)=>tokenState.
  startState(Src,Pth) => tkState(Src,1,0,1,Pth).

  tkState:(list[integer],integer,integer,integer,string) <=> tokenState.
  tkState(Chars,Line,Off,Col,Pth) <= {
    currentLocation((Line,Off,Col,Pth)).
  }.

  public implementation stream[tokenState ->> integer] <= {
    _eof(tkState([],_,_,_,_)).

    _hdtl(tkState([0c\n,..Rest],Line,Off,Col,Pth),0c\n,tkState(Rest,Line+1,Off+1,1,Pth)).
    _hdtl(tkState([Ch,..Rest],Line,Off,Col,Pth),Ch,tkState(Rest,Line,Off+1,Col+1,Pth)) :- \+ Ch = 0c\n.

    -- _cons(Ch,tkState(Chars,Line,Off,Col,Pth)) => tkState([Ch,..Chars],Line,Off-1,Col-1,Pth).
  }

  private
  makeLocation:((integer,integer,integer,string),(integer,integer,integer,string)) => location.
  makeLocation((StartLine,StartOff,StartCol,Pth),(_,EndOff,_,_)) =>
      loc(StartLine,StartOff,StartCol,EndOff-StartOff,Pth).

  public
  tokenize:(list[token]) --> tokenState.
  tokenize(AllTokens) -->
    skipSpaces(),
    allTokens(AllTokens,-1).

  private
  allTokens : (list[token],integer) --> tokenState.
  allTokens([],0) --> [].
  allTokens([],_) --> eof.
  allTokens([tok(Tk,Lc),..More],Cx) -->
    @currentLocation(Start),
    nxtTok(Tk)!,
    @currentLocation(End),
    Lc = makeLocation(Start,End),
    skipSpaces(),
    allTokens(More,Cx-1).

  public
  subTokenize:(location,string) => list[token].
  subTokenize(loc(Ln,Off,Col,_,Pth),Text) => Toks :-
    tokenize(Toks) %% tkState(explode(Text),Ln,Off,Col,Pth).

  nxtTok:(tok) --> tokenState.
  nxtTok(intTok(Ch)) --> "0c", charRef(Ch).
  nxtTok(intTok(Hx)) --> "0x", hexInt(0,Hx).
  nxtTok(Num) --> digit(_)+, readNumber(Num).
  nxtTok(lpar) --> [0c(].
  nxtTok(rpar) --> [0c)].
  nxtTok(lbra) --> [0c[].
  nxtTok(rbra) --> [0c]].
  nxtTok(lbrce) --> [0c{].
  nxtTok(rbrce) --> [0c}].
  nxtTok(lqpar) --> [0c<, 0c|].
  nxtTok(rqpar) --> [0c|, 0c>].
  nxtTok(period) --> [0c.], whiteSpace().
  nxtTok(period) --> [0c.], [0c}]+.
  nxtTok(regTok(Rg)) --> "`", regExp(Chars), "`", { Rg = implode(Chars) }.
  nxtTok(idTok(Id)) --> idStart(C), readIden(R), { Id = implode([C,..R]) }.
  nxtTok(idQTok(Id)) --> [0c'], readQuoted(Q), [0c'], { Id = implode(Q)}.
  nxtTok(stringTok(Text)) --> [0c"], readStringSegments(Text), [0c"].
  nxtTok(idTok(Op)) --> [Ch], { follows("",Ch,Next)}, followGraph(Next,Op)!.

  followGraph:(string,string) --> tokenState.
  followGraph(State,Op) --> [Ch], { follows(State,Ch,Next)}, followGraph(Next,Op).
  followGraph(Op,Op) --> { final(Op)}.

  readQuoted : (list[integer]) --> tokenState.
  readQuoted([]) --> [0c']+.
  readQuoted([C,..R]) --> charRef(C), C\=0c', readQuoted(R).

  public readIden : (list[integer]) --> tokenState.
  readIden([C,..R]) --> alphaNum(C), readIden(R).
  readIden([]) --> [].

  idStart:(integer) --> tokenState.
  idStart(0c_) --> [0c_].
  idStart(Ch) --> [Ch] , {_isLetterChar(Ch)}.

  alphaNum:(integer) --> tokenState.
  alphaNum(Ch) --> idStart(Ch).
  alphaNum(Ch) --> [Ch] , {_isNdChar(Ch) | _isMnChar(Ch) | _isMcChar(Ch) | _isPcChar(Ch) | _isCfChar(Ch) }!.

  regExp:(list[integer]) --> tokenState.
  regExp([]) --> "`"+.
  regExp([0c\\,Ch,..More]) --> [0c\\], [Ch], regExp(More).
  regExp([Ch,..More]) --> [Ch], regExp(More).

  readStringSegments:(list[stringSegment]) --> tokenState.
  readStringSegments([]) --> [0c"]+.
  readStringSegments([Seg,..Segs]) --> [0c\\], [0c(]+,
    interpolation(Seg),
    readStringSegments(Segs).
  readStringSegments([segment(Lc,Seg),..Segs]) -->
    @currentLocation(Start), -- read the current location from the token state
    readStr(Chars)!,
    @currentLocation(End),
    { Seg = implode(Chars),
      Lc = makeLocation(Start,End)},
    readStringSegments(Segs).

  readStr:(list[integer]) --> tokenState.
  readStr([]) --> [0c"]+.
  readStr([]) --> [0c\\,0c(]+.
  readStr([Ch,..More]) --> charRef(Ch), readStr(More).

  interpolation:(stringSegment) --> tokenState.
  interpolation(interpolate(Lc,implode(Text),implode(Format))) -->
    @currentLocation(Start),
    countBrackets(Text,[]),
    ([0c:],readFormat(Format) | Format=[]),
    @currentLocation(End),
    Lc = makeLocation(Start,End).

  countBrackets:(list[integer],list[integer]) --> tokenState.
  countBrackets([],[]) --> [C]+, {\+ C in [0c(,0c[, 0c{]}.
  countBrackets([Ch,..More],[Ch,..Stack]) --> [Ch], countBrackets(More,Stack).
  countBrackets([0c(,..More],Stack) --> [0c(], countBrackets(More,[0c),..Stack]).
  countBrackets([0c[,..More],Stack) --> [0c[], countBrackets(More,[0c],..Stack]).
  countBrackets([0c{,..More],Stack) --> [0c{], countBrackets(More,[0c},..Stack]).
  countBrackets([0c",..More],Stack) --> [0c"], Stack \= [], countBrackets(More,[0c",..Stack]).
  countBrackets([],[]) --> [0c"]+.
  countBrackets([Ch,..More],Stack) --> [Ch], countBrackets(More,Stack).

  readFormat:(list[integer]) --> tokenState.
  readFormat([]) --> [0c;].
  readFormat([Ch,..More]) --> [Ch], Ch\=0c\\, Ch\=0c", readFormat(More).
  readFormat([]) --> eof.

  readNumber:(tok) --> tokenState.
  readNumber(Tk) --> readNatural(0,First), readMoreNumber(Tk,First).

  readDecimal:(integer) --> tokenState.
  readDecimal(In) --> [0c-], readNatural(0,Pl), In = 0-Pl.
  readDecimal(In) --> readNatural(0,In).

  readNatural:(integer,integer) --> tokenState.
  readNatural(SoFar,Int) --> digit(D), readNatural(SoFar*10+D,Int).
  readNatural(SoFar,SoFar) --> \+digit(_).

  readMoreNumber:(tok,integer) --> tokenState.
  readMoreNumber(fltTok(Fp),Decimal) --> [0c.], digit(_)+, fraction(0.1,0.0,Fr),
      exponent(_int2flt(Decimal)+Fr,Fp).
  readMoreNumber(intTok(Ix),Ix) --> [].

  fraction:(float,float,float) --> tokenState.
  fraction(Scale,SoFar,Result) --> digit(D), fraction(Scale*0.1,SoFar+_int2flt(D)*Scale,Result).
  fraction(_,Fract,Fract) --> [].

  exponent:(float,float) --> tokenState.
  exponent(SoFar,Fp) --> ([0ce] | [0cE]), readDecimal(Exp), Fp = SoFar*_pwr(10.0,_int2flt(Exp)).
  exponent(Fp,Fp) --> [].

  digit:(integer) --> tokenState.
  digit(0) --> [0c0].
  digit(1) --> [0c1].
  digit(2) --> [0c2].
  digit(3) --> [0c3].
  digit(4) --> [0c4].
  digit(5) --> [0c5].
  digit(6) --> [0c6].
  digit(7) --> [0c7].
  digit(8) --> [0c8].
  digit(9) --> [0c9].

  public
  charRef:(integer) --> tokenState.
  charRef(Chr) --> [0c\\], backSlashRef(Chr).
  charRef(Chr) --> [Chr].

  backSlashRef:(integer) --> tokenState.
  backSlashRef(0c\a) --> [0ca].
  backSlashRef(0c\b) --> [0cb].
  backSlashRef(0c\t) --> [0ct].
  backSlashRef(0c\n) --> [0cn].
  backSlashRef(0c\r) --> [0cr].
  backSlashRef(Ch) --> [0cu], hexChars(0,Ch). -- implement \uXXX; form of unicode reference
  backSlashRef(Ch) --> [Ch].

  hexChars:(integer,integer)-->tokenState.
  hexChars(SoFar,Ch) --> hexDigit(N), hexChars(SoFar*16+N,Ch).
  hexChars(SoFar,SoFar) --> [0c;].

  hexInt:(integer,integer) --> tokenState.
  hexInt(SoFar,Ch) --> hexDigit(N), hexInt(SoFar*16+N,Ch).
  hexInt(SoFar,SoFar) --> \+hexDigit(_).

  hexDigit:(integer) --> tokenState.
  hexDigit(D) --> digit(D).
  hexDigit(10) --> [0ca].
  hexDigit(11) --> [0cb].
  hexDigit(12) --> [0cc].
  hexDigit(13) --> [0cd].
  hexDigit(14) --> [0ce].
  hexDigit(15) --> [0cf].
  hexDigit(10) --> [0cA].
  hexDigit(11) --> [0cB].
  hexDigit(12) --> [0cC].
  hexDigit(13) --> [0cD].
  hexDigit(14) --> [0cE].
  hexDigit(15) --> [0cF].

  whiteSpace:() --> tokenState.
  whiteSpace() --> [X] , {_isZsChar(X) | _isZlChar(X) | _isZpChar(X) | _isCcChar(X)}!.

  skipSpaces: () --> tokenState.
  skipSpaces() --> whiteSpace(), skipSpaces().
  skipSpaces() --> [0c-, 0c-], ([0c ] | [0c\t]), lineComment(), skipSpaces().
  skipSpaces() --> [0c/, 0c*], blockComment(), skipSpaces().
  skipSpaces() --> [].

  lineComment:() --> tokenState.
  lineComment() --> [0c\n].
  lineComment() --> [_], lineComment().

  blockComment:() --> tokenState.
  blockComment() --> eof.
  blockComment() --> [0c*, 0c/].
  blockComment() --> [_], blockComment().
}
