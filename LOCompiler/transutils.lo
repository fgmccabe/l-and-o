lo.comp.transutils {
  import lo.

  import lo.comp.args.
  import lo.comp.location.
  import lo.comp.package.
  import lo.comp.canon.
  import lo.comp.imports.
  import lo.comp.term.
  import lo.comp.types.

  public trOption ::= debugging | dbgVars(string,term,term) | pkgName(string).

  public trOptions ::= trOptions(list[trOption]).

  public trOpts:(compOption,string) => trOptions.
  trOpts(C,P) => trOptions([pkgName(P),debugging]) :- C.debugging=true.
  trOpts(_,P) => trOptions([pkgName(P)]).

  public isOption:(trOption,trOptions){}.
  isOption(O,trOptions(L)) :- O in L.

  public pushOpt:(trOption,trOptions) => trOptions.
  pushOpt(O,trOptions(L)) => trOptions([O,..L]).

  public trCons:(string,integer) => term.
  trCons(Nm,Ar) => strct(Nm+"%\(Ar)",Ar).

  public lyr ::= lyr(string,list[(string,mapEntry)],list[pred],term,term,term).

  public mapEntry ::= moduleFun(string,string,string,string,integer)
            | moduleRel(string,string,string,string,integer)
            | moduleVar(string,string,string)
            | moduleClass(string,string,integer)
            | moduleImpl(string,term)
            | localFun(string,string,string,integer,term,term)
            | localRel(string,string,string,integer,term,term)
            | localVar(string,string,term,term)
            | localClass(string,string,integer,term,term)
            | inherit(string,term,term,term)
            | inheritField(term,term,term)
            | labelArg(term,term,term)
            | notInMap.

  public makePkgMap:(string,list[canonDef],list[pkgSpec]) => (list[string],list[lyr]).
  makePkgMap(Pkg,Defs,Imports) => (Enums,[lyr(Pkg,DfList,[],anon,anon,anon)]) :-
    makeModuleMap(Pkg,Defs,DfList,Rest,Enums),
    makeImportsMap(Imports,Rest,[]).

  makeModuleMap:(string,list[canonDef],list[(string,mapEntry)],list[(string,mapEntry)],list[string]){}.
  makeModuleMap(Pkg,[Def,..Rest],Map,Mx,Enums) :-
    makeMdlEntry(Pkg,Def,Map,M0,Enums,Enx),
    makeModuleMap(Pkg,Rest,M0,Mx,Enx).
  makeModuleMap(_,[],Map,Map,[]).

  makeMdlEntry:(string,canonDef,list[(string,mapEntry)],list[(string,mapEntry)],list[string],list[string]){}.
  makeMdlEntry(Pkg,funDef(_,Nm,Tp,_,_),
      [(Nm,moduleFun(Pkg,localName(Pkg,"@",Nm),localName(Pkg,"%",Nm),localName(Pkg,"^",Nm),effectiveArity(Tp,0))),..Mx],Mx,Clx,Clx).
  makeMdlEntry(Pkg,grammDef(_,Nm,Tp,_,_),
      [(Nm,moduleRel(Pkg,localName(Pkg,"@",Nm),localName(Pkg,"%",Nm),localName(Pkg,"^",Nm),effectiveArity(Tp,0))),..Mx],Mx,Clx,Clx).
  makeMdlEntry(Pkg,relDef(_,Nm,Tp,_,_),
      [(Nm,moduleRel(Pkg,localName(Pkg,"@",Nm),localName(Pkg,"%",Nm),localName(Pkg,"^",Nm),effectiveArity(Tp,0))),..Mx],Mx,Clx,Clx).
  makeMdlEntry(Pkg,varDef(_,Nm,_,_,_,_),
      [(Nm,moduleVar(Pkg,localName(Pkg,"@",Nm),localName(Pkg,"%",Nm))),..Mx],Mx,Clx,Clx).
  makeMdlEntry(Pkg,classDef(_,Nm,Tp,_,_,_),
      [(Nm,moduleClass(localName(Pkg,"#",Nm),localName(Pkg,"@",Nm),effectiveArity(Tp,0))),..Mx],Mx,[Nm,..Clx],Clx).
  makeMdlEntry(Pkg,implDef(_,_,ImplNm,_,_,Deps,_,_),
      [(ImplNm,moduleImpl(ImplNm,LclNm)),..Mx],Mx,Ens,Enx) :-
    (isEmpty(Deps) ? LclNm=enum(ImplNm), Ens=[ImplNm,..Enx] | LclNm=strct(ImplNm,length(Deps)), Ens=Enx).
  makeMdlEntry(Pkg,_,Mx,Mx,Clx,Clx).

  makeImportsMap:(list[pkgSpec],list[(string,mapEntry)],list[(string,mapEntry)]){}.
  makeImportsMap([Import,..Rest],Map,Mx) :-
    makeImportMap(Import,Map,M0),
    makeImportsMap(Rest,M0,Mx).
  makeImportsMap([],Map,Map).

  makeImportMap:(pkgSpec,list[(string,mapEntry)],list[(string,mapEntry)]){}.
  makeImportMap(pkgSpec(pkg(Pkg,_),Fields,_,Enums,_,Impls,_),Map,Mx) :-
    importFields(Pkg,Enums,Fields,Map,M0),
    importImplementations(Impls,M0,Mx).

  importFields:(string,list[string],list[(string,tipe)],list[(string,mapEntry)],list[(string,mapEntry)]){}.
  importFields(_,_,[],Map,Map).
  importFields(Pkg,Enums,[(Nm,Tp),..Fields],Map,Mx) :-
    moveQuants(Tp,_,QTp),
    moveConstraints(QTp,_,Template),
    makeImportEntry(Template,Enums,Pkg,Nm,Map,M0),
    importFields(Pkg,Enums,Fields,M0,Mx).

  makeImportEntry:(tipe,list[string],string,string,list[(string,mapEntry)],list[(string,mapEntry)]){}.
  makeImportEntry(funType(A,_),_,Pkg,Nm,
      [(Nm,moduleFun(Pkg,localName(Pkg,"@",Nm),localName(Pkg,"%",Nm),localName(Pkg,"^",Nm),length(A))),..Mx],Mx).
  makeImportEntry(grammarType(A,_),_,Pkg,Nm,
      [(Nm,moduleRel(Pkg,localName(Pkg,"@",Nm),localName(Pkg,"%",Nm),localName(Pkg,"^",Nm),length(A))),..Mx],Mx).
  makeImportEntry(predType(A),_,Pkg,Nm,
      [(Nm,moduleRel(Pkg,localName(Pkg,"@",Nm),localName(Pkg,"%",Nm),localName(Pkg,"^",Nm),length(A))),..Mx],Mx).
  makeImportEntry(classType(A,_),_,Pkg,Nm,
      [(Nm,moduleClass(localName(Pkg,"#",Nm),localName(Pkg,"@",Nm),length(A))),..Mx],Mx).
  makeImportEntry(_,Enums,Pkg,Nm,
      [(Nm,moduleClass(localName(Pkg,"#",Nm),localName(Pkg,"@",Nm),0)),..Mx],Mx) :-
    Nm in Enums!.
  makeImportEntry(_,_,Pkg,Nm,[(Nm,moduleVar(Pkg,localName(Pkg,"@",Nm),localName(Pkg,"%",Nm))),..Mx],Mx).

  importImplementations:(list[implEntry],list[(string,mapEntry)],list[(string,mapEntry)]){}.
  importImplementations([],Map,Map).
  importImplementations([implEntry(Nm,Con),..L],[(Nm,moduleImpl(Nm,Struct)),..M],Mx) :-
    contractArity(Con,Ar),
    contractStruct(Ar,Nm,Struct),
    importImplementations(L,M,Mx).

  contractArity:(constraint,integer){}.
  contractArity(univCon(_,Con),Ar) :- contractArity(Con,Ar).
  contractArity(conCon(Con,_),A+1) :- contractArity(Con,A).
  contractArity(_,0).

  contractStruct:(integer,string,term){}.
  contractStruct(0,Nm,enum(Nm)).
  contractStruct(Ar,Nm,strct(Nm,Ar)).

  private lookup:(list[lyr],string,(mapEntry){},mapEntry){}.
  lookup([],_,_,notInMap).
  lookup([lyr(_,Defns,_,_,_,_),.._],Nm,Filter,Reslt) :-
    filteredSearch(Defns,Filter,Nm,Reslt).
  lookup([_,..Layers],Nm,Filter,Reslt) :-
    lookup(Layers,Nm,Filter,Reslt).

  private filteredSearch:(list[(string,mapEntry)],(mapEntry){},string,mapEntry){}.
  filteredSearch(Defns,Filter,Nm,Defn) :-
    (Nm,Defn) in Defns,
    Filter(Defn).

  public lookupVarName:(list[lyr],string,mapEntry){}.
  lookupVarName(Map,Nm,V) :-
    lookup(Map,Nm,anyDef,V)!.

  anyDef:(mapEntry){}.
  anyDef(_).

  public lookupRelName:(list[lyr],string,mapEntry){}.
  lookupRelName(Map,Nm,V) :-
    lookup(Map,Nm,relEntry,V)!.

  private relEntry:(mapEntry){}.
  relEntry(localRel(_,_,_,_,_,_)).
  relEntry(moduleRel(_,_,_,_,_)).
  relEntry(inherit(_,_,_,_)).
  relEntry(inheritField(_,_,_)).

  public lookupFunName:(list[lyr],string,mapEntry){}.
  lookupFunName(Map,Nm,V) :-
    lookup(Map,Nm,funEntry,V)!.

  private funEntry:(mapEntry){}.
  funEntry(localFun(_,_,_,_,_,_)).
  funEntry(moduleFun(_,_,_,_,_)).
  funEntry(inherit(_,_,_,_)).
  funEntry(inheritField(_,_,_)).
  funEntry(localClass(_,_,_,_,_)).
  funEntry(moduleClass(_,_,_)).
  funEntry(moduleImpl(_,_)).

  public lookupClassName:(list[lyr],string,mapEntry){}.
  lookupClassName(Map,Nm,V) :-
    lookup(Map,Nm,classEntry,V)!.

  private classEntry:(mapEntry){}.
  classEntry(localClass(_,_,_,_,_)).
  classEntry(moduleClass(_,_,_)).
  classEntry(inherit(_,_,_,_)).
  classEntry(inheritField(_,_,_)).

  public lookupDefn:(list[lyr],string,mapEntry){}.
  lookupDefn(Map,Nm,Df) :-
    lookup(Map,Nm,nonType,Df)!.

  private nonType:(mapEntry){}.
  nonType(_).

  public lookupPkgRef:(list[lyr],string,string,mapEntry){}.
  lookupPkgRef(Map,Pkg,Nm,Df) :-
    lookupPkg(Map,Pkg,Nm,Df)!.

  private lookupPkg:(list[lyr],string,string,mapEntry){}.
  lookupPkg([lyr(_,Defns,_,_,_,_),.._],Pkg,Nm,Reslt) :-
    (Nm,Def) in Defns,
    samePkg(Defn,Pkg).
  lookupPkg([_,..Layers],Pkg,Nm,Reslt) :-
    lookupPkg(Layers,Pkg,Nm,Reslt).

  private samePkg:(mapEntry,string){}.
  samePkg(moduleFun(_,Pkg,_,_,_),Pkg).
  samePkg(moduleRel(Pkg,_,_,_,_),Pkg).

  public programAccess:(mapEntry,string,string,string,integer){}.
  programAccess(moduleFun(_,Prog,Access,Closure,Arity),Prog,Access,Closure,Arity).
  programAccess(localFun(Prog,Access,Closure,Arity,_,_),Prog,Access,Closure,Arity).
  programAccess(moduleRel(_,Prog,Access,Closure,Arity),Prog,Access,Closure,Arity).
  programAccess(localRel(Prog,Access,Closure,Arity,_,_),Prog,Access,Closure,Arity).
  programAccess(moduleVar(_,Prog,Access),Prog,Access,Access,1).
  programAccess(localVar(Prog,Access,_,_),Prog,Access,Access,1).
  programAccess(localClass(Prog,Access,Arity,_,_),Prog,Access,Access,Arity).

  public extraVars:(list[lyr],list[term]){}.
  extraVars([lyr(_,_,_,anon,anon,_),.._],[]).
  extraVars([lyr(_,_,_,LbVr,ThVr,_),.._],[LbVr,ThVr]).

  public thisVar:(list[lyr],term){}.
  thisVar([lyr(_,_,_,_,ThVr,_),.._],ThVr) :- ThVr \= anon.

  public streamVar:(list[lyr],term){}.
  streamVar([lyr(_,_,_,_,_,StrmVr),.._],StrmVr) :- StrmVr\=anon.

  public pushStreamVar:(list[lyr],term)=>list[lyr].
  pushStreamVar([lyr(Nm,Defs,Gl,LbVr,ThVr,_),..L],StrmVr) => [lyr(Nm,Defs,Gl,LbVr,ThVr,StrmVr),..L].

  public labelAccess:(list[term],list[term],list[lyr],list[pred],list[pred]){}.
  labelAccess(Q,Q,[lyr(_,_,_,anon,anon,_),.._],G,G).
  labelAccess(Q,merge([LbVr],Q),[lyr(_,_,LblGl,LbVr,_,_),.._],G,Gx) :- G = LblGl<>Gx.

  public layerName:(list[lyr])=>string.
  layerName([lyr(Nm,_,_,_,_,_),.._]) => Nm.

  public allLabelArgs:(list[lyr],list[term]) => list[term].
  allLabelArgs([],SoF) => SoF.
  allLabelArgs([lyr(_,Entries,_,_,_,_),..L],SoF) => labelArgs(Entries,allLabelArgs(L,SoF)).

  labelArgs:(list[(string,mapEntry)],list[term]) => list[term].
  labelArgs([],L) => L.
  labelArgs([(_,labelArg(V,_,_)),..M],L) => labelArgs(M,[V,..L]).
  labelArgs([_,..M],L) => labelArgs(M,L).

  public genNewName:(list[lyr],string,integer,term){}.
  genNewName(Map,Variant,Ar,prg(localName(layerName(Map),"@",_str_gen(Variant)),Ar)).

  public genVars:(integer) => list[term].
  genVars(0) => [].
  genVars(K) => [V,..genVars(K-1)] :-
    K>0,
    genVarbl("V",V).

  public localName:(string,string,string) => string.
  localName(Pkg,Glue,Nm) => Nm :-
    _str_start(Pkg,Nm),
    _str_find(Nm,Glue,0,_).
  localName(Pkg,Glue,Nm) => Pkg+Glue+Nm.

  public effectiveArity:(tipe,integer) => integer.
  effectiveArity(Tp,Extra) => tpArity(Tp)+Extra.

  private tpArity:(tipe) => integer.
  tpArity(funType(E,_)) => length(E)+1.
  tpArity(predType(E)) => length(E).
  tpArity(grammarType(E,_)) => length(E)+2.
  tpArity(classType(E,_)) => length(E).
  tpArity(univType(_,T)) => tpArity(T).
  tpArity(constrained(T,_)) => tpArity(T).
  tpArity(tupleType(L)) => length(L).
  tpArity(faceType(F)) => length(F).
  tpArity(_) => 0.
}
