lo.comp.transutils {
  import lo.

  import lo.comp.location.
  -- import lo.comp.escapes.
  import lo.comp.canon.
  import lo.comp.imports.
  import lo.comp.term.
  import lo.comp.types.

  public type trOption ::= debugging | dbgVars(string,term,term) | pkgName(string).

  public type trOptions ::= trOptions(list[trOption]).

  public isOption:(trOption,trOptions){}.
  isOption(O,trOptions(L)) :- O in L.

  public pushOpt:(trOption,trOptions) => trOptions.
  pushOpt(O,trOptions(L)) => trOptions([O,..L]).

  public trCons:(string,integer) => term.
  trCons(Nm,Ar) => strct(Nm+"%\(Ar)",Ar).

  public type lyr ::= lyr(string,list[(string,progDef)],term,term,term).

  public type progDef ::= moduleFun(string,term,term)
            | moduleRel(string,term,term)
            | moduleVar(string,term)
            | moduleClass(string,term,term)
            | notInMap.

  stdMap:()=>list[lyr].
  stdMap() => [lyr("",[],anon,anon,aonon)].

  public makePkgMap:(pkg,list[canonDef],list[pkgSpec]) => (list[lyr],list[(string,term,tipe)]).
  makePkgMap(pkg(Pkg,_),Defs,Imports) => (Classes,[lyr(Pkg,DfList,anon,anon,anon),..stdMap()]) :-
    makeModuleMap(Pkg,Defs,DfList,Rest,Classes),
    makeImportsMap(Imports,Rest,[]).

  makeModuleMap:(string,list[canonDef],list[lyr],list[lyr],list[(string,term,tipe)]){}.
  makeModuleMap(Pkg,[Def,..Rest],Map,Mx,Classes) :-
    makeMdlEntry(Pkg,Def,Map,M0,Classes,Clx),
    makeModuleMap(Pkg,Rest,M0,Mx,Clx).
  makeModuleMap(_,[],Map,Map,[]).

  makeMdlEntry:(string,canonDef,list[(string,progDef)],list[(string,progDef)],list[(string,term,tipe)],list[(string,term,tipe)]){}.
  makeMdlEntry(Pkg,funDef(_,Nm,Tp,_,_),
      [(Nm,moduleFun(Pkg,prg(localName(Pkg,"@",Nm),Arity),strct(localName(Pkg,"%",Nm),Arity))),..Mx],Mx,Clx,Clx) :-
    Arity = typeArity(Tp)+1.
  makeMdlEntry(Pkg,grammDef(_,Nm,Tp,_,_),
      [(Nm,moduleRel(Pkg,prg(localName(Pkg,"@",Nm),Arity),strct(localName(Pkg,"%",Nm),Arity))),..Mx],Mx,Clx,Clx) :-
    Arity = typeArity(Tp)+2.
  makeMdlEntry(Pkg,relDef(_,Nm,Tp,_,_),
      [(Nm,moduleRel(Pkg,prg(localName(Pkg,"@",Nm),Arity),strct(localName(Pkg,"%",Nm),Arity))),..Mx],Mx,Clx,Clx) :-
    Arity = typeArity(Tp).
  makeMdlEntry(Pkg,varDef(_,Nm,_,_,_,_),
      [(Nm,moduleVar(Pkg,prg(localName(Pkg,"@",Nm),1))),..Mx],Mx,Clx,Clx).
  makeMdlEntry(Pkg,classDef(_,Nm,Tp,_,_,_),
      [(Nm,moduleClass(prg(AccessName,1),enum(LclName),prg(LclName,3)))|Mx],Mx,[(Nm,enum(LclName),Tp),..Clx],Clx) :-
    typeArity(Tp)=0,
    LclName = localName(Pkg,"#",Nm),
    AccessName = localName(Pkg,"@",Nm).
  makeMdlEntry(Pkg,classDef(_,Nm,Tp,_,_,_),
      [(Nm,moduleClass(prg(localName(Pkg,"@",Nm),1),Template,prg(LclName,3))),..Mx],Mx,[(Nm,Template,Tp),..Clx],Clx) :-
    LclName = localName(Pkg,"#",Nm),
    Template = strct(LclName,typeArity(Tp)).
  makeMdlEntry(Pkg,_,Mx,Mx,Clx,Clx).
  
  makeImportsMap:(list[pkgSpec],list[(string,progDef)],list[(string,progDef)]){}.
  makeImportsMap([Import,..Rest],Map,Mx) :-
    makeImportMap(Import,Map,M0),
    makeImportsMap(Rest,M0,Mx).
  makeImportsMap([],Map,Map).

  makeImportMap:(pkgSpec,list[(string,progDef)],list[(string,progDef)]){}.
  makeImportMap(pkgSpec(pkg(Pkg,_),faceType(Fields),_,Classes,_,Impls,_),Map,Mx) :-
    importFields(Pkg,Classes,Fields,Map,M0),
    importImplementations(Impls,M0,Mx).

  importFields:(string,list[(string,string,tipe)],list[(string,tipe)],list[(string,progDef)],list[(string,progDef)]){}.
  importFields(_,_,[],Map,Map).
  importFields(Pkg,Classes,[(Nm,Tp)|Fields],Map,Mx) :-
    moveQuants(Tp,_,QTp),
    moveConstraints(QTp,_,Template),
    makeImportEntry(Template,Classes,Pkg,Nm,Map,M0),
    importFields(Pkg,Classes,Fields,M0,Mx).

  importImplementations:(list[implEntry],list[(string,progDef)],list[(string,progDef)]){}.
  importImplementations([],Map,Map).
  importImplementations([implEntry(Nm,Con),..L],[(Nm,moduleImpl(prg(Nm,1),Struct,prg(Nm,3))),..M],Mx) :-
    contractArity(Con,Ar),
    contractStruct(Ar,Nm,Struct),
    importImplementations(L,M,Mx).

  contractArity:(constraint,integer){}.
  contractArity(univCon(_,Con),Ar) :- contractArity(Con,Ar).
  contractArity(conCOn(Con,_),Ar) :- contractArity(Con,A), Ar is A+1.
  contractArity(_,0).

  contractStruct:(integer,string,term){}.
  contractStruct(0,Nm,enum(Nm)).
  contractStruct(Ar,Nm,strct(Nm,Ar)).

  makeImportEntry:(tipe,list[(string,string,tipe)],string,list[(string,progDef)],list[(string,progDef)]){}.
  makeImportEntry(funType(A,_),_,Pkg,Nm,
      [(Nm,moduleFun(Pkg,prg(localName(Pkg,"@",Nm),Arity),strct(localName(Pkg,"%",Nm),Arity))),..Mx],Mx) :-
    Arity = typeArity(A)+1.
  makeImportEntry(grammarType(A,_),_,Pkg,Nm,
      [(Nm,moduleRel(Pkg,prg(localName(Pkg,"@",Nm),Arity)),strct(localName(Pkg,"%",Nm),Arity)),..Mx],Mx) :-
    Arity = typeArity(A)+2.
  makeImportEntry(predType(A),_,Pkg,Nm,
      [(Nm,moduleRel(Pkg,prg(localName(Pkg,"@",Nm),Arity)),strct(localName(Pkg,"%",Nm),Arity)),..Mx],Mx) :-
    Arity = typeArity(A).
  makeImportEntry(classType(A,_),_,Pkg,Nm,
      [(Nm,moduleClass(prg(AccessName,1),strct(LclName,Ar),prg(AccessName,3))),..Mx],Mx) :-
    AccessName = localName(Pkg,"@",Nm),
    LclName = localName(Pkg,"@",Nm).
  makeImportEntry(_,Classes,Pkg,Nm,
      [(Nm,moduleClass(prg(AccessName,1),enum(LclName),prg(LclName,3))),..Mx],Mx) :-
    (Nm,LclName,AccessName) in Classes.
  makeImportEntry(_,_,Pkg,Nm,[(Nm,moduleVar(Pkg,prg(localName(Pkg,"@",Nm),1))),..Mx],Mx).

  public lookup:(list[lyr],string,(string,progDef){},progDef){}.
  lookup([],_,_,notInMap).
  lookup([lyr(_Prefix,Defns,_Lc,_Lbl,_LbVr,_ThVr),.._],Nm,Filter,Reslt) :-
    filteredSearch(Defns,Filter,Nm,Reslt)!.
  lookup([_,..Layers],Nm,Filter,Reslt) :-
    lookup(Layers,Nm,Filter,Reslt).

  private filteredSearch:(list[(string,progDef)],(string,progDef){},string,progDef){}.
  filteredSearch(Defns,Filter,Nm,Defn) :-
    (Nm,Defn) in Defns,
    call(Filter,Defn),!.

  lookupVarName(Map,Nm,V) :-
    lookup(Map,Nm,anyDef,V).

  anyDef(moduleVar(_Pkg,_Vn)).
  anyDef(localVar(_Vn,_ClVr,_TVr)).
  anyDef(labelArg(_N,_ClVr,_TVr)).
  anyDef(localClass(_,_,_,_,_)).
  anyDef(moduleClass(_,_,_)).
  anyDef(inherit(_,_,_,_)).
  anyDef(inheritField(_,_,_)).
  anyDef(moduleContract(_,_,_)).
  anyDef(moduleImpl(_,_,_)).
  anyDef(moduleFun(_,_,_)).
  anyDef(localFun(_,_,_,_)).

  lookupRelName(Map,Nm,V) :-
    lookup(Map,Nm,relDef,V).

  relDef(localRel(_,_,_)).
  relDef(moduleRel(_,_)).
  relDef(inherit(_,_,_,_)).
  relDef(inheritField(_,_,_)).

  lookupFunName(Map,Nm,V) :-
    lookup(Map,Nm,funDef,V).

  funDef(localFun(_,_,_,_)).
  funDef(moduleFun(_,_,_)).
  funDef(inherit(_,_,_,_)).
  funDef(inheritField(_,_,_)).
  funDef(localClass(_,_,_,_,_)).
  funDef(moduleClass(_,_,_)).
  funDef(moduleImpl(_,_,_)).

  lookupClassName(Map,Nm,V) :-
    lookup(Map,Nm,classDef,V).

  classDef(localClass(_,_,_,_,_)).
  classDef(moduleClass(_,_,_)).
  classDef(inherit(_,_,_,_)).
  classDef(inheritField(_,_,_)).

  lookupTypeName(Map,Nm,T) :-
    lookup(Map,Nm,tpDef,T).

  tpDef(localType(_)).
  tpDef(inherit(_,_,_,_)).
  tpDef(moduleType(_,_)).

  lookupDefn(Map,Nm,Df) :-
    lookup(Map,Nm,nonType,Df).

  nonType(Df) :- Df \= moduleType(_,_), Df \= localType(_).

  lookupPackageRef(Map,Pkg,Nm,V) :-
    lookup(Map,Nm,pkgRef(Pkg),V).

  pkgRef(Pkg,moduleClass(Pkg,_,_)).
  pkgRef(Pkg,moduleFun(Pkg,_,_)).
  pkgRef(Pkg,moduleRel(Pkg,_)).
  pkgRef(Pkg,moduleVar(Pkg,_)).
  pkgRef(Pkg,moduleType(Pkg,_)).

  mapName(moduleFun(_,Prog,Access),Prog,Access).
  mapName(localFun(Prog,Access,_,_),Prog,Access).

  extraVars([lyr(_,_,_,_,void,void)|_],[]) :- !.
  extraVars([lyr(_,_,_,_,LbVr,ThVr)|_],[LbVr,ThVr]).

  thisVar([lyr(_,_,_,_,_,ThVr)|_],ThVr) :- ThVr \= void.

  labelAccess(Q,Q,[lyr(_,_,_,_,void,void)|_],G,G) :- !.
  labelAccess(Q,Qx,[lyr(_,_,_,LblGl,LbVr,_)|_],G,Gx) :- concat(LblGl,Gx,G),merge([LbVr],Q,Qx).

  pushOpt(Opts,Opt,[Opt|Opts]).

  isOption(Opt,Opts) :- is_member(Opt,Opts),!.

  layerName([lyr(Nm,_,_,_,_,_)|_],Nm).

  genVar(Prefix,idnt(V)) :-
    genstr(Prefix,V).

  genAnons(0,[]).
  genAnons(K,[anon|Rest]) :-
    K>0,
    K1 is K-1,
    genAnons(K1,Rest).

  genVars(0,[]).
  genVars(K,[V|Rest]) :-
    K>0,
    K1 is K-1,
    genVar("V",V),
    genVars(K1,Rest).

  typeTrArity(Tp,Ar) :-
    isFunctionType(Tp,A),
    Ar is A+1.
  typeTrArity(Tp,Ar) :-
    isPredType(Tp,Ar).
  typeTrArity(Tp,Ar) :-
    isClassType(Tp,A),
    Ar is A+1.
  typeTrArity(_,1).

  public localName:(string,string,string) => string.
  localName(_,Glue,Nm) => Nm :- 
    _str_find(Nm,Glue,_,_).
  localName(Pkg,Glue,Nm) => Pkg+Glue+Nm.
}