lo.comp.transutils {
  import lo.

  import lo.comp.location.
  import lo.comp.canon.
  import lo.comp.imports.
  import lo.comp.term.
  import lo.comp.types.

  public type trOption ::= debugging | dbgVars(string,term,term) | pkgName(string).

  public type trOptions ::= trOptions(list[trOption]).

  public isOption:(trOption,trOptions){}.
  isOption(O,trOptions(L)) :- O in L.

  public pushOpt:(trOption,trOptions) => trOptions.
  pushOpt(O,trOptions(L)) => trOptions([O,..L]).

  public trCons:(string,integer) => term.
  trCons(Nm,Ar) => strct(Nm+"%\(Ar)",Ar).

  public type lyr ::= lyr(string,list[(string,mapEntry)],term,term,term).

  public type mapEntry ::= moduleFun(string,string,string,integer)
            | moduleRel(string,string,string,string,integer)
            | moduleVar(string,string,string)
            | moduleClass(string,string,integer)
            | moduleImpl(string,term)
            | localFun(string,string,string,integer,term,term)
            | localRel(string,string,string,integer,term,term)
            | localCar(string,string,term,term)
            | localClass(string,string,string,integer,term,term)
            | notInMap.

  stdMap:()=>list[lyr].
  stdMap() => [lyr("",[],anon,anon,anon)].

  public makePkgMap:(pkg,list[canonDef],list[pkgSpec]) => (list[lyr],list[(string,term,tipe)]).
  makePkgMap(pkg(Pkg,_),Defs,Imports) => (Classes,[lyr(Pkg,DfList,anon,anon,anon),..stdMap()]) :-
    makeModuleMap(Pkg,Defs,DfList,Rest,Classes),
    makeImportsMap(Imports,Rest,[]).

  makeModuleMap:(string,list[canonDef],list[lyr],list[lyr],list[(string,string,tipe)]){}.
  makeModuleMap(Pkg,[Def,..Rest],Map,Mx,Classes) :-
    makeMdlEntry(Pkg,Def,Map,M0,Classes,Clx),
    makeModuleMap(Pkg,Rest,M0,Mx,Clx).
  makeModuleMap(_,[],Map,Map,[]).

  makeMdlEntry:(string,canonDef,list[(string,mapEntry)],list[(string,mapEntry)],list[(string,string,tipe)],list[(string,string,tipe)]){}.
  makeMdlEntry(Pkg,funDef(_,Nm,Tp,_,_),
      [(Nm,moduleFun(Pkg,localName(Pkg,"@",Nm),localName(Pkg,"%",Nm),localName(Pkg,"^",Nm),effectiveArity(Tp,0))),..Mx],Mx,Clx,Clx).
  makeMdlEntry(Pkg,grammDef(_,Nm,Tp,_,_),
      [(Nm,moduleRel(Pkg,localName(Pkg,"@",Nm),localName(Pkg,"%",Nm),localName(Pkg,"^",Nm),effectiveArity(Tp,0))),..Mx],Mx,Clx,Clx).
  makeMdlEntry(Pkg,relDef(_,Nm,Tp,_,_),
      [(Nm,moduleRel(Pkg,localName(Pkg,"@",Nm),localName(Pkg,"%",Nm),localName(Pkg,"^",Nm),effectiveArity(Tp,0))),..Mx],Mx,Clx,Clx).
  makeMdlEntry(Pkg,varDef(_,Nm,_,_,_,_),
      [(Nm,moduleVar(Pkg,localName(Pkg,"@",Nm),localName(Pkg,"%",Nm)))),..Mx],Mx,Clx,Clx).
  makeMdlEntry(Pkg,classDef(_,Nm,Tp,_,_,_),
      [(Nm,moduleClass(localName(Pkg,"#",Nm),localName(Pkg,"@",Nm),effectiveArity(Tp,0))),..Mx],Mx,[(Nm,localName(Pkg,"#",Nm),Tp),..Clx],Clx).
  makeMdlEntry(Pkg,_,Mx,Mx,Clx,Clx).
  
  makeImportsMap:(list[pkgSpec],list[(string,mapEntry)],list[(string,mapEntry)]){}.
  makeImportsMap([Import,..Rest],Map,Mx) :-
    makeImportMap(Import,Map,M0),
    makeImportsMap(Rest,M0,Mx).
  makeImportsMap([],Map,Map).

  makeImportMap:(pkgSpec,list[(string,mapEntry)],list[(string,mapEntry)]){}.
  makeImportMap(pkgSpec(pkg(Pkg,_),faceType(Fields),_,Classes,_,Impls,_),Map,Mx) :-
    importFields(Pkg,Classes,Fields,Map,M0),
    importImplementations(Impls,M0,Mx).

  importFields:(string,list[(string,string,tipe)],list[(string,tipe)],list[(string,mapEntry)],list[(string,mapEntry)]){}.
  importFields(_,_,[],Map,Map).
  importFields(Pkg,Classes,[(Nm,Tp)|Fields],Map,Mx) :-
    moveQuants(Tp,_,QTp),
    moveConstraints(QTp,_,Template),
    makeImportEntry(Template,Classes,Pkg,Nm,Map,M0),
    importFields(Pkg,Classes,Fields,M0,Mx).

  importImplementations:(list[implEntry],list[(string,mapEntry)],list[(string,mapEntry)]){}.
  importImplementations([],Map,Map).
  importImplementations([implEntry(Nm,Con),..L],[(Nm,moduleImpl(prg(Nm,1),Struct,prg(Nm,3))),..M],Mx) :-
    contractArity(Con,Ar),
    contractStruct(Ar,Nm,Struct),
    importImplementations(L,M,Mx).

  contractArity:(constraint,integer){}.
  contractArity(univCon(_,Con),Ar) :- contractArity(Con,Ar).
  contractArity(conCOn(Con,_),Ar) :- contractArity(Con,A), Ar is A+1.
  contractArity(_,0).

  contractStruct:(integer,string,term){}.
  contractStruct(0,Nm,enum(Nm)).
  contractStruct(Ar,Nm,strct(Nm,Ar)).

  makeImportEntry:(tipe,list[(string,string,tipe)],string,list[(string,mapEntry)],list[(string,mapEntry)]){}.
  makeImportEntry(funType(A,_),_,Pkg,Nm,
      [(Nm,moduleFun(Pkg,localName(Pkg,"@",Nm),localName(Pkg,"%",Nm),localName(Pkg,"^",Nm),effectiveArity(A,1))),..Mx],Mx).
  makeImportEntry(grammarType(A,_),_,Pkg,Nm,
      [(Nm,moduleRel(Pkg,localName(Pkg,"@",Nm),localName(Pkg,"%",Nm),localName(Pkg,"^",Nm),effectiveArity(A,2))),..Mx],Mx).
  makeImportEntry(predType(A),_,Pkg,Nm,
      [(Nm,moduleRel(Pkg,localName(Pkg,"@",Nm),localName(Pkg,"%",Nm),localName(Pkg,"^",Nm),effectiveArity(A,0))),..Mx],Mx).
  makeImportEntry(classType(A,_),_,Pkg,Nm,
      [(Nm,moduleClass(prg(AccessName,1),strct(LclName,Ar),prg(AccessName,3))),..Mx],Mx) :-
    AccessName = localName(Pkg,"@",Nm),
    LclName = localName(Pkg,"@",Nm).
  makeImportEntry(_,Classes,Pkg,Nm,
      [(Nm,moduleClass(prg(AccessName,1),enum(LclName),prg(LclName,3))),..Mx],Mx) :-
    (Nm,LclName,AccessName) in Classes.
  makeImportEntry(_,_,Pkg,Nm,[(Nm,moduleVar(Pkg,prg(localName(Pkg,"@",Nm),1))),..Mx],Mx).

  public lookup:(list[lyr],string,(string,mapEntry){},mapEntry){}.
  lookup([],_,_,notInMap).
  lookup([lyr(_Prefix,Defns,_Lc,_Lbl,_LbVr,_ThVr),.._],Nm,Filter,Reslt) :-
    filteredSearch(Defns,Filter,Nm,Reslt)!.
  lookup([_,..Layers],Nm,Filter,Reslt) :-
    lookup(Layers,Nm,Filter,Reslt).

  private filteredSearch:(list[(string,mapEntry)],(string,mapEntry){},string,mapEntry){}.
  filteredSearch(Defns,Filter,Nm,Defn) :-
    (Nm,Defn) in Defns,
    call(Filter,Defn),!.

  lookupVarName(Map,Nm,V) :-
    lookup(Map,Nm,anyDef,V).

  anyDef(moduleVar(_Pkg,_Vn)).
  anyDef(localVar(_Vn,_ClVr,_TVr)).
  anyDef(labelArg(_N,_ClVr,_TVr)).
  anyDef(localClass(_,_,_,_,_)).
  anyDef(moduleClass(_,_,_)).
  anyDef(inherit(_,_,_,_)).
  anyDef(inheritField(_,_,_)).
  anyDef(moduleContract(_,_,_)).
  anyDef(moduleImpl(_,_,_)).
  anyDef(moduleFun(_,_,_)).
  anyDef(localFun(_,_,_,_)).

  lookupRelName(Map,Nm,V) :-
    lookup(Map,Nm,relDef,V).

  relDef(localRel(_,_,_)).
  relDef(moduleRel(_,_)).
  relDef(inherit(_,_,_,_)).
  relDef(inheritField(_,_,_)).

  lookupFunName(Map,Nm,V) :-
    lookup(Map,Nm,funDef,V).

  funDef(localFun(_,_,_,_)).
  funDef(moduleFun(_,_,_)).
  funDef(inherit(_,_,_,_)).
  funDef(inheritField(_,_,_)).
  funDef(localClass(_,_,_,_,_)).
  funDef(moduleClass(_,_,_)).
  funDef(moduleImpl(_,_,_)).

  lookupClassName(Map,Nm,V) :-
    lookup(Map,Nm,classDef,V).

  classDef(localClass(_,_,_,_,_)).
  classDef(moduleClass(_,_,_)).
  classDef(inherit(_,_,_,_)).
  classDef(inheritField(_,_,_)).

  lookupTypeName(Map,Nm,T) :-
    lookup(Map,Nm,tpDef,T).

  tpDef(localType(_)).
  tpDef(inherit(_,_,_,_)).
  tpDef(moduleType(_,_)).

  lookupDefn(Map,Nm,Df) :-
    lookup(Map,Nm,nonType,Df).

  nonType(Df) :- Df \= moduleType(_,_), Df \= localType(_).

  lookupPackageRef(Map,Pkg,Nm,V) :-
    lookup(Map,Nm,pkgRef(Pkg),V).

  pkgRef(Pkg,moduleClass(Pkg,_,_)).
  pkgRef(Pkg,moduleFun(Pkg,_,_)).
  pkgRef(Pkg,moduleRel(Pkg,_)).
  pkgRef(Pkg,moduleVar(Pkg,_)).
  pkgRef(Pkg,moduleType(Pkg,_)).

  mapName(moduleFun(_,Prog,Access),Prog,Access).
  mapName(localFun(Prog,Access,_,_),Prog,Access).

  extraVars([lyr(_,_,_,_,void,void)|_],[]) :- !.
  extraVars([lyr(_,_,_,_,LbVr,ThVr)|_],[LbVr,ThVr]).

  thisVar([lyr(_,_,_,_,_,ThVr)|_],ThVr) :- ThVr \= void.

  labelAccess(Q,Q,[lyr(_,_,_,_,void,void)|_],G,G) :- !.
  labelAccess(Q,Qx,[lyr(_,_,_,LblGl,LbVr,_)|_],G,Gx) :- concat(LblGl,Gx,G),merge([LbVr],Q,Qx).

  pushOpt(Opts,Opt,[Opt|Opts]).

  isOption(Opt,Opts) :- is_member(Opt,Opts),!.

  public layerName:(list[lyr])=>string.
  layerName([lyr(Nm,_,_,_,_,_),.._]) => Nm.

  public genVar:(string)=>term.
  genVar(Prefix) => idnt(_str_gen(Prefix)).

  public genAnons:(integer) => list[term].
  genAnons(0) => [].
  genAnons(K) => [anon,..genAnons(K-1)] :-
    K>0.

  public genVars:(integer) => list[term].
  genVars(0) => [].
  genVars(K) => [genVar("V"),..genVars(K-1)] :-
    K>0.

  public localName:(string,string,string) => string.
  localName(_,Glue,Nm) => Nm :- 
    _str_find(Nm,Glue,_,_).
  localName(Pkg,Glue,Nm) => Pkg+Glue+Nm.

  public effectiveArity:(tipe,integer) => integer.
  effectiveArity(Tp,Extra) => tpArity(Tp)+Extra.

  private tpArity:(tipe) => integer.
  tpArity(funType(E,_)) => tpArity(E)+1.
  tpArity(predType(E)) => tpArity(E).
  tpArity(grammarType(E,_)) => tpArity(E)+2.
  tpArity(classType(E,_)) => tpArity(E).
  tpArity(univType(_,T)) => tpArity(T).
  tpArity(constrained(T,_)) => tpArity(T).
  tpArity(tupleType(L)) => tpArity(L).
  tpArity(faceType(F)) => tpArity(F).
  
  
}