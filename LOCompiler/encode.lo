lo.comp.encode{
  import lo.
  import lo.comp.term.
  import lo.comp.base64.
  import lo.comp.package.
  import lo.comp.types.
  import lo.comp.parseutils.
  import lo.comp.code.asm.

  public encodeTerm:(term) => list[integer].
  encodeTerm(T) => encTerm(T,[]).

  private encTerm:(term,list[integer]) => list[integer].
  encTerm(anon,L) => [0ca,..L].
  encTerm(intgr(Ix),L) => [0cx,..encInt(Ix,L)].
  encTerm(flot(Dx),L) => [0cd,..encFlot(Dx,L)].
  encTerm(enum(Nm),L) => [0ce,..encodeText(Nm,L)].
  encTerm(strng(Sx),L) => [0cs,..encodeText(Sx,L)].
  encTerm(strct(Nm,Ar),L) => [0co,..encInt(Ar,encodeText(Nm,L))].
  encTerm(prg(Nm,Ar),L) => [0cp,..encInt(Ar,encodeText(Nm,L))].
  encTerm(cons(Op,Els),L) => [0cu,..encInt(length(Els),encEls(Els,L))] :- isTupleSig(Op,size(Els)).
  encTerm(cons(Op,Els),L) => [0cn,..encInt(length(Els),encTerm(Op,encEls(Els,L)))].
  -- encTerm(code(Tp,Code,Lits),L) => [0c#,..encType(Tp,encTerm(mkTpl(Lits),encodeChars(encode64(Code),0c',L)))].

  private encInt:(integer,list[integer]) => list[integer].
  encInt(N,L) => [0c-,..encInt(-N,L)] :- N<0.
  encInt(N,L) => [D,..L] :- digitVal(D,N), N>=0, N=<9.
  encInt(N,L) => encInt(N / 10,[D,..L]) :- N>=10, digitVal(D,N%10).

  private encEls:(list[term],list[integer]) => list[integer].
  encEls([],L) => L.
  encEls([E,..M],L) => encTerm(E,encEls(M,L)).

  -- Temporary version
  private encFlot:(float,list[integer]) => list[integer].
  encFlot(Dx,L) => encodeText(Dx::string,L).

  private encodeText:(string,list[integer]) => list[integer].
  encodeText(Nm,L) => encodeChars(Chrs,Delim,L) :- Chrs = explode(Nm), findDelim(Chrs,Delim)!.

  private findDelim:(list[integer],integer){}.
  findDelim(Chrs,Delim) :-
    Delim in [0c', 0c", 0c|, 0c/, 0c%],
    \+ Delim in Chrs.
  findDelim(_,0c").

  private encodeChars:(list[integer],integer,list[integer]) => list[integer].
  encodeChars(Chars,Delim,L) => [Delim,..encodeQuoted(Chars,Delim,L)].

  private encodeQuoted:(list[integer],integer,list[integer]) => list[integer].
  encodeQuoted([],Delim,L) => [Delim,..L].
  encodeQuoted([0c\\,..M],Delim,L) => [0c\\, 0c\\,..encodeQuoted(M,Delim,L)].
  encodeQuoted([Delim,..M],Delim,L) => [0c\\, Delim,.. encodeQuoted(M,Delim,L)].
  encodeQuoted([Ch,..M],Delim,L) => [Ch,..encodeQuoted(M,Delim,L)].

  public encodeType:(tipe) => list[integer].
  encodeType(Tp) => encType(Tp,[]).

  private encType:(tipe,list[integer]) => list[integer].
  encType(anonType,L) => [0c_,..L].
  encType(voidType,L) => [0cv,..L].
  encType(thisType,L) => [0ch,..L].
  encType(tipe("lo.core*logical"),L) => [0cl,..L].
  encType(tipe("lo.core*integer"),L) => [0ci,..L].
  encType(tipe("lo.core*float"),L) => [0cf,..L].
  encType(tipe("lo.core*string"),L) => [0cS,..L].
  encType(tpFun(Nm,Ar),L) => [0cz,..encInt(Ar,encodeText(Nm,L))].
  encType(typeExp(Op,[E]),L) => [0cL,..encType(E,L)] :- deRef(Op)=tpFun("lo.core*list",1).
  encType(kVar(Nm),L) => [0ck,..encodeText(Nm,L)].
  encType(kFun(Nm,Ar),L) => [0cK,..encInt(Ar,encodeText(Nm,L))].
  encType(tipe(Nm),L) => [0ct,..encodeText(Nm,L)].
  encType(typeExp(Op,Els),L) => [0cU,..encType(deRef(Op),encTypes(Els,L))].
  encType(tupleType(Els),L) => [0cT,..encTypes(Els,L)].
  encType(funType(A,R),L) => [0cF,..encType(A,encType(R,L))].
  encType(classType(A,R),L) => [0cC,..encType(A,encType(R,L))].
  encType(predType(A),L) => [0cP,..encType(A,L)].
  encType(grammarType(A,R),L) => [0cG,..encType(A,encType(R,L))].
  encType(typeRule(A,R),L) => [0cY,..encType(A,encType(R,L))].
  encType(faceType(Els),L) => [0cI,..encFieldTypes(Els,L)].
  encType(constrained(T,C),L) => [0c|,..encType(T,encConstraint(C,L))].
  encType(univType(V,T),L) => [0c:,..encType(V,encType(T,L))].

  private encTypes:(list[tipe],list[integer]) => list[integer].
  encTypes(Els,L) => encInt(length(Els),encTps(Els,L)).

  private encTps:(list[tipe],list[integer]) => list[integer].
  encTps([],L) => L.
  encTps([T,..M],L) => encType(T,encTps(M,L)).

  private encFieldTypes:(list[(string,tipe)],list[integer]) => list[integer].
  encFieldTypes(F,L) => encInt(length(F),encFieldTps(F,L)).

  private encFieldTps:(list[(string,tipe)],list[integer]) => list[integer].
  encFieldTps([],L) => L.
  encFieldTps([(Fld,Tp),..M],L) => encodeText(Fld,encType(Tp,encFieldTps(M,L))).

  public encodeConstraint:(constraint) => list[integer].
  encodeConstraint(Con) => encConstraint(Con,[]).

  private encConstraint:(constraint,list[integer]) => list[integer].
  encConstraint(univCon(V,C),L) => [0c:,..encType(V,encConstraint(C,L))].
  encConstraint(conTract(Nm,Args,Deps),L) => [0cc,..encodeText(Nm,encType(tupleType(Args),encType(tupleType(Deps),L)))].
  encConstraint(implementsFace(Tp,Flds),L) => [0ca,..encType(Tp,encType(faceType(Flds),L))].
  encConstraint(conCon(C,E),L) => [0c|,..encConstraint(C,encConstraint(E,L))].

  public packageSig:(pkgSpec) => term.
  packageSig(pkgSpec(Pkg,Fields,Types,Enums,Contracts,Impls,Imports)) =>
    strng(implode(encodeTerm(
      mkTpl([fmtPkg(Pkg),fmtImports(Imports),
        fmtTypes(Fields),fmtTypes(Types),fmtEnums(Enums),fmtContracts(Contracts),fmtImpls(Impls)])))).

  fmtPkg:(pkg) => term.
  fmtPkg(pkg(Nm,Vers)) => cons(strct("pkg",2),[strng(Nm),fmtVer(Vers)]).

  fmtVer:(version) => term.
  fmtVer(defltVersion) => enum("*").
  fmtVer(vers(V)) => strng(fV).

  fmtImports:(list[(visibility,pkg)]) => term.
  fmtImports(Imports) => mkTpl(Imports//fmtImport).

  fmtImport:((visibility,pkg)) => term.
  fmtImport((Viz,Pkg)) => cons(strct("import",2),[fmtViz(Viz),fmtPkg(Pkg)]).

  fmtViz:(visibility) => term.
  fmtViz(priVate) => enum("private").
  fmtViz(pUblic) => enum("public").

  fmtTypes:(list[(string,tipe)]) => term.
  fmtTypes(Fields) => fmtType(faceType(Fields)).

  fmtEnums:(list[string]) => term.
  fmtEnums(Enums) => mkTpl(Enums//fmtEnum).

  fmtEnum:(string) => term.
  fmtEnum(E) => strng(E).

  fmtContracts:(list[conEntry]) => term.
  fmtContracts(L) => mkTpl(L//fmtContract).

  fmtContract:(conEntry) => term.
  fmtContract(conEntry(Nm,ConNm,Con,Face)) => mkTpl([strng(Nm),strng(ConNm),fmtConstraint(Con),fmtType(Face)]).

  fmtImpls:(list[implEntry]) => term.
  fmtImpls(L) => mkTpl(L//fmtImpl).

  fmtImpl:(implEntry) => term.
  fmtImpl(implEntry(Nm,Con)) => mkTpl([strng(Nm),fmtConstraint(Con)]).

  fmtType:(tipe) => term.
  fmtType(T) => strng(implode(encodeType(T))).

  fmtConstraint:(constraint) => term.
  fmtConstraint(Con) => strng(implode(encodeConstraint(Con))).

  -- Prepare instructions for base64 encoding
  fmtIns:(list[integer]) => list[integer].
  fmtIns([]) => [].
  fmtIns([I,..L]) => [(I.>>.24).&.255,(I.>>.16).&.255,(I.>>.8).&.255,I.&.255,..fmtIns(L)].

  LOSig:integer.
  LOSig = 0x01030507.

  -- Encode a code segment
  encCodeSeg:(codeSeg,list[integer]) => list[integer].
  encCodeSeg(codeSeg(Nm,Code,Lits),L) =>
    [0cn,..encInt(3,encTerm(strct("#code",3),encTerm(Nm,[0cs,..encodeChars(encode64(fmtIns([LOSig,..Code])),0c',encTerm(mkTpl(Lits),L))])))].

  encSegs:(list[codeSeg],list[integer]) => list[integer].
  encSegs([],L) => L.
  encSegs([S,..R],L) => encCodeSeg(S,encSegs(R,L)).

  -- encode a complete code package
  public encMdl:(codeMdl) => list[integer].
  encMdl(codeMdl(Spec,Segs)) =>
    encTerm(packageSig(Spec),encSegs(Segs,[])).
}
