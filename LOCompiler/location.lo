lo.comp.location{
  import lo.
  
  public 
  type location <~ {
    merge:(location)=>location.
  }.

  public std:location.
  std <= {
    merge(Lc) => Lc.
  }

  public loc:(integer,integer,integer,integer,string)<=>location.
  loc(Line,Off,Col,Len,Pth) <= {
    merge(loc(_,OO,C,L,_)) => loc(Line,Off,Col,OO-Off+L,Pth).
  }.

  public
  implementation display[location] <= {
    disp(L) => locDisp(L).
  }

  locDisp:(location)=>ss.
  locDisp(std) => ss("<standard>").
  locDisp(loc(Ln,Off,Col,Len,Pth)) => 
        ssSeq([ss(Pth),ss(":"),disp(Ln),ss("/"),disp(Col),ss("("),disp(Len),ss(")")]).

  public lineOf:(location) => integer.
  lineOf(loc(Line,Off,Col,Len,Pth)) => Line.

  public columnOf:(location) => integer.
  columnOf(loc(Line,Off,Col,Len,Pth)) => Col.

  public widthOf:(location) => integer.
  widthOf(loc(Line,Off,Col,Len,Pth)) => Len.

  public implementation sizeable[location] <= {
    size(loc(_,_,_,Len,_)) => Len.
    size(std) => 0.

    isEmpty(std).
  }

  public type hasLoc <~ { loc:location. }.

  public locationContext:(location,list[integer]) => list[integer].
  locationContext(loc(Ln,_,Col,Len,_),Codes) => Line <> showArrow(Col,min(Len,size(Line)-Col)) :- Line=findLine(Ln,Codes).

  private findLine:(integer,list[integer]) => list[integer].
  findLine(1,Codes) => skipLine(Codes).
  findLine(N,Codes) => findLine(N-1,skipLine(Codes)).

  private skipLine:(list[integer])=>list[integer].
  skipLine([]) => [].
  skipLine([0c\n,.._]) => [].
  skipLine([C,..L]) => [C,..skipLine(L)].

  private showArrow:(integer,integer) => list[integer].
  showArrow(Col,Len) =>
    showChars(Col,0c ,showChars(Len,0c^,[0c\n])).

  private showChars:(integer,integer,list[integer]) => list[integer].
  showChars(0,_,Tl) => Tl.
  showChars(N,C,Tl) => [C,..showChars(N-1,C,Tl)].
}