lo.comp.location{
  import lo.
  import lo.array.
  import lo.json.

  public
  location <~ {
    merge:(location)=>location.
  }.

  public std:location.
  std <= {
    merge(Lc) => Lc.
  }

  public loc:(integer,integer,integer,integer,string)<=>location.
  loc(Line,Off,Col,Len,Pth) <= {
    merge(loc(_,OO,C,L,_)) => loc(Line,Off,Col,OO-Off+L,Pth).
  }.

  public
  implementation display[location] <= {
    disp(L) => locDisp(L).
  }

  locDisp:(location)=>ss.
  locDisp(std) => ss("<standard>").
  locDisp(loc(Ln,Off,Col,Len,Pth)) =>
        ssSeq([ss(Pth),ss("@"),disp(Ln),ss(":"),disp(Col),ss("("),disp(Len),ss(")")]).

  public lineOf:(location) => integer.
  lineOf(loc(Line,Off,Col,Len,Pth)) => Line.

  public columnOf:(location) => integer.
  columnOf(loc(Line,Off,Col,Len,Pth)) => Col.

  public widthOf:(location) => integer.
  widthOf(loc(Line,Off,Col,Len,Pth)) => Len.

  public implementation sizeable[location] <= {
    size(loc(_,_,_,Len,_)) => Len.
    size(std) => 0.

    isEmpty(std).
  }

  public implementation coercion[location,json] <= {
    _coerce(lc) => loc2json(lc).
  }

  private loc2json:(location) => json.
  loc2json(loc(Line,Off,Col,Len,Pth)) =>
    jColl(["path"->jTxt(Pth),
           "line"->jNum(Line::float),
           "column"->jNum(Col::float),
           "start"->jNum(Off::float),
           "length"->jNum(Len::float)]).
  loc2json(std) => jNull.

  public hasLoc <~ { loc:location. }.

  public locationContext:(location,string) => ss.
  locationContext(loc(_,_,Col,Len,_),Line) => ssSeq([ss(Line),ss(implode(showArrow(Col-1,min(Len,size(Line)-Col))))]).

  private showArrow:(integer,integer) => list[integer].
  showArrow(Col,Len) =>
    showChars(Col,0c ,showChars(Len,0c^,[0c\n])).

  private showChars:(integer,integer,list[integer]) => list[integer].
  showChars(0,_,Tl) => Tl.
  showChars(N,C,Tl) => [C,..showChars(N-1,C,Tl)].

  -- Used to help display messages in context. We organize the source into an array of strings.
  public collectSrc:(list[integer],integer,array[string]) => array[string].
  collectSrc([],_,A) => A.
  collectSrc(Codes,Ix,A) => collectSrc(Rest,Ix+1,A[Ix->implode(Ln)]) :- findLine(Codes,Ln,Rest).

  private findLine:(list[integer],list[integer],list[integer]){}.
  findLine([],[],[]).
  findLine([0c\n,..L],[0c\n],L).
  findLine([Ch,..L],[Ch,..Ln],Rest) :- findLine(L,Ln,Rest).
}
