lo.comp.regexp{
  -- Parse a regular expression
  import lo.

  import lo.comp.ast.
  import lo.comp.lexer.
  import lo.comp.location.

  public
  regExp ::= reChars(location,list[integer])
         | reNegChars(location,list[integer])
         | reGroup(location,regExp,string)
         | reChoice(location,regExp,regExp)
         | rePlus(location,regExp)
         | reStar(location,regExp)
         | rePeriod(location)
         | reEof(location)
         | reStart(location)
         | reLiteral(location,integer)
         | reCat(location,regExp,regExp).

  public implementation display[regExp] <= {
    disp(RE) => dispRegexp(RE).
  }

  private dispRegexp:(regExp) => ss.
  dispRegexp(reChars(_,Chars)) => ssSeq([ss("["),ss(implode(Chars)),ss("]")]).
  dispRegexp(reNegChars(_,Chars)) => ssSeq([ss("[^"),ss(implode(Chars)),ss("]")]).
  dispRegexp(reGroup(_,R,"")) => ssSeq([ss("("),dispRegexp(R),ss(")")]).
  dispRegexp(reGroup(_,R,Nm)) => ssSeq([ss("("),dispRegexp(R),ss(":"),ss(Nm),ss(")")]).
  dispRegexp(reChoice(_,A,B)) => ssSeq([dispRegexp(A),ss("|"),dispRegexp(B)]).
  dispRegexp(rePlus(_,A)) => ssSeq([dispRegexp(A),ss("+")]).
  dispRegexp(reStar(_,A)) => ssSeq([dispRegexp(A),ss("*")]).
  dispRegexp(rePeriod(_)) => ss(".").
  dispRegexp(reEof(_)) => ss("$").
  dispRegexp(reStart(_)) => ss("^").
  dispRegexp(reLiteral(_,Code)) => sc(Code).
  dispRegexp(reCat(_,L,R)) => ssSeq([dispRegexp(L),dispRegexp(R)]).

  private dispSeq:(list[regExp]) => list[ss].
  dispSeq([]) => [].
  dispSeq([R,..M]) => [dispRegexp(R),..dispSeq(M)].

  public implementation located[regExp] <= {
    locOf(reChars(Lc,_)) => Lc.
    locOf(reNegChars(Lc,_)) => Lc.
    locOf(reGroup(Lc,_,_)) => Lc.
    locOf(reChoice(Lc,_,_)) => Lc.
    locOf(rePlus(Lc,_)) => Lc.
    locOf(reStar(Lc,_)) => Lc.
    locOf(rePeriod(Lc)) => Lc.
    locOf(reEof(Lc)) => Lc.
    locOf(reStart(Lc)) => Lc.
    locOf(reLiteral(Lc,_)) => Lc.
    locOf(reCat(Lc,_,_)) => Lc.
  }

  -- Parse regular expressions
  regularExp:(regExp) --> tokenState.
  regularExp(R) --> { stream.currentLocation(Start)},reExp(F,Start), reFollow(F,R).

  reExp:(regExp,(integer,integer,integer,string)) --> tokenState.
  reExp(rePeriod(makeLocation(Start,End)),Start) --> ".", { stream.currentLocation(End)}.
  reExp(reStart(makeLocation(Start,End)),Start) --> "^", { stream.currentLocation(End)}.
  reExp(reEof(makeLocation(Start,End)),Start) --> "$", { stream.currentLocation(End)}.
  reExp(reNegChars(makeLocation(Start,End),Chrs),Start) --> "[^", charClass(Chrs), "]", { stream.currentLocation(End)}.
  reExp(reChars(makeLocation(Start,End),Chrs),Start) --> "[", charClass(Chrs), "]", { stream.currentLocation(End)}.
  reExp(reGroup(makeLocation(Start,End),R,V),Start) --> "(", regularExp(R), groupVar(V), ")", { stream.currentLocation(End)}.
  reExp(reLiteral(makeLocation(Start,End),Ch),Start) --> charRef(Ch), { stream.currentLocation(End)}.

  groupVar:(string) --> tokenState.
  groupVar(implode(I)) --> ":", readIden(I).
  groupVar("") --> ")"+.

  charClass:(list[integer]) --> tokenState.
  charClass([]) --> "]"+.
  charClass(Chrs) --> charRef(St), "-", charRef(En), charClass(More), { Chrs = merge(More,charRange(St,End))}.
  charClass([Ch,..More]) --> charRef(Ch), charClass(More).

  reFollow:(regExp,regExp) --> tokenState.
  reFollow(R,F) --> "*", { stream.currentLocation(End)}, reFollow(reStar(extendLocation(locOf(R),End),R),F).
  reFollow(R,F) --> "+", { stream.currentLocation(End)}, reFollow(rePlus(extendLocation(locOf(R),End),R),F).
  reFollow(R,reChoice(Lc,R,N)) --> "|", regularExp(N), { stream.currentLocation(End)}, {Lc=extendLocation(locOf(R),End)}.
  reFollow(R,R) --> ([0c:]+ | [0c)]+ | eof).
  reFollow(L,O) --> { stream.currentLocation(Start)},reExp(R,Start), { stream.currentLocation(End)}, reFollow(reCat(extendLocation(locOf(R),End),L,R),O).

  charRange:(integer,integer) => list[integer].
  charRange(St,St) => [St].
  charRange(St,En) => [St,..charRange(St+1,En)] :-  St<En.


}
