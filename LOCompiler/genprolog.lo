lo.comp.genprolog{
  import lo.

  import lo.comp.encode.
  import lo.comp.package.
  import lo.comp.term.
  import lo.comp.types.

  public implementation coercion[prProg,string] <= {
    _coerce(P) => implode(prog2code(P,[])).
  }

  prog2code:(prProg,list[integer]) => list[integer].
  prog2code(prProg(Spec,Rels),Ox) => convertTerm(genPrologSig(Spec),[0c.,0c\n,..foldMap(convertRel,Ox,Rels)]).

  genPrologSig:(pkgSpec) => term.
  genPrologSig(Spec) => cons(strct("#pkg",1),[packageSig(Spec)]).

  convertRel:(term,trel,list[integer]) => list[integer].
  convertRel(_,trel(_,_,Fall,Clses),Ox) => foldRight(convertClause,Ox,Clses).

  convertClause:(clse,list[integer]) => list[integer].
  convertClause(clse(_,Nm,Args,[]),Ox) => convertHead(Nm,Args,[0c.,0c\n,..Ox]).
  convertClause(clse(_,Nm,Args,[C,..Rest]),Ox) => convertHead(Nm,Args,[0c:,0c-,0c ,..convertPred(C,foldRight(convertCall,[0c.,0c\n,..Ox],Rest))]).
  convertClause(gclse(_,Nm,Args,[],Body),Ox) => convertHead(Nm,Args,[0c:,0c-,0c ,0c!,..convertPreds(Body,[0c,,0c\n,0c ,0c ,0c ,0c ],[0c.,0c\n,..Ox])]).
  convertClause(gclse(_,Nm,Args,Guard,Body),Ox) => convertHead(Nm,Args,[0c:,0c-,0c ,..convertPreds(Guard,[],[0c,,0c!,..convertPreds(Body,[0c,,0c\n,0c ,0c ,0c ,0c ],[0c.,0c\n,..Ox])])]).

  convertHead:(term,list[term],list[integer]) => list[integer].
  convertHead(Nm,Args,Ox) => convertCallOp(Nm,[0c(,..convertArgs(Args,[0c),..Ox])]).

  convertCallOp:(term,list[integer]) => list[integer].
  convertCallOp(prg(Nm,_),Ox) => appId(Nm,Ox).

  convertArgs:(list[term],list[integer]) => list[integer].
  convertArgs([],Ox) => Ox.
  convertArgs([A,..L],Ox) => convertTerm(A,foldRight(convertArg,Ox,L)).

  convertArg:(term,list[integer]) => list[integer].
  convertArg(T,Ox) => [0c,, 0c ,..convertTerm(T,Ox)].

  convertPreds:(list[pred],list[integer],list[integer]) => list[integer].
  convertPreds([],_,L) => L.
  convertPreds([C,..R],Sep,L) => Sep<>convertPred(C,convertPreds(R,[0c,,0c\n,0c ,0c ,0c ,0c ],L)).

  convertCall:(pred,list[integer]) => list[integer].
  convertCall(C,Ox) => [0c,,0c\n,0c ,0c ,0c ,0c ,..convertPred(C,Ox)].

  convertPred:(pred,list[integer]) => list[integer].
  convertPred(call(_,Op,Args),Ox) => convertCallOp(Op,[0c(,..convertArgs(Args,[0c),..Ox])]).
  convertPred(ecall(_,Op,Args),Ox) => appId(Op,[0c(,..convertArgs(Args,[0c),..Ox])]).
  convertPred(unfy(_,L,R),Ox) => convertTerm(L,[0c ,0c=, 0c ,..convertTerm(R,Ox)]).
  convertPred(ocall(_,Call,Lb,Th),Ox) => appStr("ocall(",convertTerm(Call,[0c,,..convertTerm(Lb,[0c,,..convertTerm(Th,[0c),..Ox])])])).
  convertPred(neck,Ox) => [0c!,..Ox].
  convertPred(fail,Ox) => appStr("fail",Ox).
  convertPred(except(_,E),Ox) => appStr("raise_exception",[0c(,..convertTerm(E,[0c),..Ox])]).

  convertTerm:(term,list[integer]) => list[integer].
  convertTerm(anon,Ox) => [0c_,..Ox].
  convertTerm(varbl(Nm),Ox) => [0cX,..appStr(Nm,Ox)].
  convertTerm(intgr(Ix),Ox) => appStr(Ix::string,Ox).
  convertTerm(flot(Dx),Ox) => appStr(Dx::string,Ox).
  convertTerm(strng(Sx),Ox) => appQuoted(Sx,0c",Ox).
  convertTerm(enum(Ex),Ox) => appId(Ex,Ox).
  convertTerm(strct(Nm,Ar),Ox) => appId(Nm,Ox).
  convertTerm(prg(Nm,Ar),Ox) => appId(Nm,Ox).
  convertTerm(cons(Op,Args),Ox) => convertTerm(Op,[0c(,..convertArgs(Args,[0c),..Ox])]).

  appStr:(string,list[integer]) => list[integer].
  appStr(S,Ox) => explode(S)<>Ox.

  appQuoted:(string,integer,list[integer]) => list[integer].
  appQuoted(S,Qt,Ox) => [Qt,..quoteConcat(explode(S),Qt,[Qt,..Ox])].

  appId:(string,list[integer]) => list[integer].
  appId(Nm,Ox) => appQuoted(Nm,0c',Ox).

  quoteConcat:(list[integer],integer,list[integer]) => list[integer].
  quoteConcat([],_,Ox) => Ox.
  quoteConcat([Qt,..L],Qt,Ox) => [0c\\,Qt,..quoteConcat(L,Qt,Ox)].
  quoteConcat([0c",..L],Qt,Ox) => [0c\\,0c",..quoteConcat(L,Qt,Ox)].
  quoteConcat([0c\\,..L],Qt,Ox) => [0c\\,0c\\,..quoteConcat(L,Qt,Ox)].
  quoteConcat([C,..L],Qt,Ox) => [C,..quoteConcat(L,Qt,Ox)].
}
