lo.comp.genprolog{
  import lo.

  import lo.comp.encode.
  import lo.comp.flatten.
  import lo.comp.package.
  import lo.comp.term.
  import lo.comp.transutils.
  import lo.comp.types.

  public implementation coercion[prProg,string] <= {
    _coerce(P) => implode(prog2code(flattenProg(P),[])).
  }

  prog2code:(prProg,list[integer]) => list[integer].
  prog2code(prProg(Spec,Rels),Ox) => convertTerm(genPrologSig(Spec),[0c.,0c\n,..foldMap(convertRel,Ox,Rels)]).

  genPrologSig:(pkgSpec) => term.
  genPrologSig(Spec) => cons(strct("#pkg",1),[packageSig(Spec)]).

  convertRel:(term,rel,list[integer]) => list[integer].
  convertRel(_,rel(Prd,Lc,Clses),Ox) => foldRight(convertClause,Ox,Clses).

  genFailsafe:(term,option[tloc]) => clse.
  genFailsafe(prg(Nm,Ar),Lc) =>
    clse([],prg(Nm,Ar),genAnons(Ar),[except(Lc,cons(strct("error",2),[strng(Nm),genLoc(Lc)]))]).

  genLoc:(option[tloc]) => term.
  genLoc(none) => enum("lo.core#none").
  genLoc(some(tloc(Line,Off,Col,Len))) => cons(strct("lo.core#some",1),[cons(strct("()4",4),[intgr(Line),intgr(Off),intgr(Col),intgr(Len)])]).

  convertClause:(list[integer],clse) => list[integer].
  convertClause(Ox,clse(_,Nm,Args,[])) => convertHead(Nm,Args,[0c.,0c\n,..Ox]).
  convertClause(Ox,clse(_,Nm,Args,[C,..Rest])) => convertHead(Nm,Args,[0c:,0c-,0c ,..convertPred(C,foldRight(convertCall,[0c.,0c\n,..Ox],Rest))]).
  convertClause(Ox,eqn(_,Nm,Args,Rep,Body)) => convertHead(Nm,Args<>[V],[0c:,0c-,0c ,..convertBody(Body,[],[0c!,0c,,..convertPred(unfy(none,V,Rep),[0c.,0c\n,..Ox])])]) :-
    genVarbl("R",V).

  convertHead:(term,list[term],list[integer]) => list[integer].
  convertHead(Nm,Args,Ox) => convertCallOp(Nm,[0c(,..convertArgs(Args,[0c),..Ox])]).

  convertBody:(list[pred],list[integer],list[integer]) => list[integer].
  convertBody([],Sep,Tail) => Sep<>Tail.
  convertBody([C,..B],Sep,Tail) => Sep<>convertPred(C,convertBody(B,[0c,,0c\n,0c ,0c ,0c ,0c ],Tail)).

  convertCallOp:(term,list[integer]) => list[integer].
  convertCallOp(prg(Nm,_),Ox) => appId(Nm,Ox).

  convertArgs:(list[term],list[integer]) => list[integer].
  convertArgs([],Ox) => Ox.
  convertArgs([A,..L],Ox) => convertTerm(A,foldRight(convertArg,Ox,L)).

  convertArg:(list[integer],term) => list[integer].
  convertArg(Ox,T) => [0c,, 0c ,..convertTerm(T,Ox)].

  convertPreds:(list[pred],list[integer],list[integer]) => list[integer].
  convertPreds([],_,L) => L.
  convertPreds([C,..R],Sep,L) => Sep<>convertPred(C,convertPreds(R,[0c,,0c\n,0c ,0c ,0c ,0c ],L)).

  convertCall:(list[integer],pred) => list[integer].
  convertCall(Ox,C) => [0c,,0c\n,0c ,0c ,0c ,0c ,..convertPred(C,Ox)].

  convertPred:(pred,list[integer]) => list[integer].
  convertPred(call(_,Op,Args),Ox) => convertCallOp(Op,[0c(,..convertArgs(Args,[0c),..Ox])]).
  convertPred(ecall(_,Op,Args),Ox) => appId(Op,[0c(,..convertArgs(Args,[0c),..Ox])]).
  convertPred(unfy(_,L,R),Ox) => convertTerm(L,[0c ,0c=, 0c ,..convertTerm(R,Ox)]).
  convertPred(ocall(_,Call,Lb,Th),Ox) => appStr("ocall(",convertTerm(Call,[0c,,..convertTerm(Lb,[0c,,..convertTerm(Th,[0c),..Ox])])])).
  convertPred(neck,Ox) => [0c!,..Ox].
  convertPred(fail,Ox) => appStr("fail",Ox).
  convertPred(except(_,E),Ox) => appStr("raise_exception",[0c(,..convertTerm(E,[0c),..Ox])]).

  convertTerm:(term,list[integer]) => list[integer].
  convertTerm(anon,Ox) => [0c_,..Ox].
  convertTerm(varbl(Nm),Ox) => [0cX,..appStr(Nm,Ox)].
  convertTerm(intgr(Ix),Ox) => appStr(Ix::string,Ox).
  convertTerm(flot(Dx),Ox) => appStr(Dx::string,Ox).
  convertTerm(strng(Sx),Ox) => appQuoted(Sx,0c",Ox).
  convertTerm(enum(Ex),Ox) => appId(Ex,Ox).
  convertTerm(strct(Nm,Ar),Ox) => appId(Nm,Ox).
  convertTerm(prg(Nm,Ar),Ox) => appId(Nm,Ox).
  convertTerm(cons(Op,Args),Ox) => convertTerm(Op,[0c(,..convertArgs(Args,[0c),..Ox])]).

  appStr:(string,list[integer]) => list[integer].
  appStr(S,Ox) => explode(S)<>Ox.

  appQuoted:(string,integer,list[integer]) => list[integer].
  appQuoted(S,Qt,Ox) => [Qt,..quoteConcat(explode(S),Qt,[Qt,..Ox])].

  appId:(string,list[integer]) => list[integer].
  appId(Nm,Ox) => appQuoted(Nm,0c',Ox).

  quoteConcat:(list[integer],integer,list[integer]) => list[integer].
  quoteConcat([],_,Ox) => Ox.
  quoteConcat([Qt,..L],Qt,Ox) => [0c\\,Qt,..quoteConcat(L,Qt,Ox)].
  quoteConcat([0c",..L],Qt,Ox) => [0c\\,0c",..quoteConcat(L,Qt,Ox)].
  quoteConcat([0c\\,..L],Qt,Ox) => [0c\\,0c\\,..quoteConcat(L,Qt,Ox)].
  quoteConcat([C,..L],Qt,Ox) => [C,..quoteConcat(L,Qt,Ox)].
}
