lo.comp.flatten{
  import lo.
  import lo.topsort.

  import lo.comp.misc.
  import lo.comp.package.
  import lo.comp.term.
  import lo.comp.types.

  -- Flatten a program - eliminating nested function calls

  public flattenProg:(prProg) => prProg.
  flattenProg(prProg(Spec,Rels)) => prProg(Spec,Rels///((Nm,Rel)=>flattenRel(Rel))).

  flattenRel:(rel) => rel.
  flattenRel(rel(Nm,Lc,Rls)) => rel(Nm,Lc,Rls//flattenRule).
  -- flattenRel(rel(Nm,Lc,Rls)) => rel(Nm,Lc,Rls//((Cl)=>flowRewrite(flattenRule(Cl)))).

  -- First phase - replace function invoke with special equality format
  flattenRule:(clse) => clse.
  flattenRule(clse(Q,Nm,Args,Body)) => clse(NQ,Nm,NArgs,NBody<>Guard<>Post) :-
    flattenTerms(Args,Q,NArgs,Guard,[],Post,[],Q1)!,
    flattenBody(Body,Q1,NBody,[],NQ).
  flattenRule(eqn(Q,Nm,Args,guarded(Rep,G))) => eqn(NQ,Nm,NArgs,guarded(simplifyGuard(guarded(NRep,simplifyCond(conj(none,PrR)))),simplifyCond(conj(none,Guard)))) :-
    flattenTerms(Args,Q,NArgs,Guard,Pr,Prx,[],Q0)!,
    flattenPred(G,Q0,G1,Pr,[G1,..Pr0],Pr0,Prx,Q1),
    flattenTerm(Rep,Q0,NRep,PrR,PsR,PsR,[],NQ).
  flattenRule(eqn(Q,Nm,Args,Rep)) => eqn(NQ,Nm,NArgs,simplifyGuard(guarded(NRep,conj(none,Guard)))) :-
    flattenTerms(Args,Q,NArgs,Guard,Prx,Prx,PrR,Q0)!,
    flattenTerm(Rep,Q0,NRep,PrR,PsR,PsR,[],NQ).

  flattenTerm:(term,list[term],term,list[pred],list[pred],list[pred],list[pred],list[term]){}.
  flattenTerm(anon,Q,anon,Pre,Pre,Post,Post,Q).
  flattenTerm(varbl(Id),Q,varbl(Id),Pre,Pre,Post,Post,Q).
  flattenTerm(T,Q,T,Pre,Pre,Post,Post,Q) :- isGroundTerm(T).
  flattenTerm(cons(Op,Els),Q,cons(Op,NEls),Pre,Prx,Post,Psx,Qx) :-
    flattenTerms(Els,Q,NEls,Pre,Prx,Post,Psx,Qx).
  flattenTerm(invoke(Lc,Op,Args),Q,Res,Pre,Prx,Post,Psx,Qx) :-
    genVarbl("_R",Res),
    flattenTerm(Op,[Res,..Q],NOp,Pre,Pre0,Post,Pst0,Q0),
    flattenTerms(Args,Q0,NArgs,Pre0,[dfne(Lc,Res,invoke(Lc,NOp,NArgs)),..Prx],Pst0,Psx,Qx).
  flattenTerm(escvoke(Lc,Es,Args),Q,Res,Pre,Prx,Post,Psx,Qx) :-
    genVarbl("_R",Res),
    flattenTerms(Args,[Res,..Q],NArgs,Pre,[dfne(Lc,Res,escvoke(Lc,Es,NArgs)),..Prx],Post,Psx,Qx).
  flattenTerm(ovoke(Lc,Call,Lb,Th),Q,Res,Pre,Prx,Post,Psx,Qx) :-
    genVarbl("_R",Res),
    flattenTerm(Call,[Res,..Q],NCall,Pre,Pre0,Post,Pst0,Q0),
    flattenTerm(Lb,Q0,NLb,Pre0,Pre1,Pst0,Pst1,Q1),
    flattenTerm(Th,Q0,NTh,Pre1,[dfne(Lc,Res,ovoke(Lc,NCall,NLb,NTh)),..Prx],Pst1,Psx,Qx).
  flattenTerm(guarded(T,C),Q,Res,Pre,Prx,Post,Psx,Qx) :-
    flattenTerm(T,Q,Res,Pr0,Prx,Post,Ps0,Q1),
    flattenPred(C,Q1,C1,Pre,[C1,..Pr0],Ps0,Psx,Qx).

  flattenTerms:(list[term],list[term],list[term],list[pred],list[pred],list[pred],list[pred],list[term]){}.
  flattenTerms([],Q,[],Pre,Pre,Post,Post,Q).
  flattenTerms([A,..L],Q,[NA,..NL],Pr,Prx,Po,Psx,Qx) :-
    flattenTerm(A,Q,NA,Pr,Pr0,Po,Po0,Q0),
    flattenTerms(L,Q0,NL,Pr0,Prx,Po0,Psx,Qx).

  flattenBody:(list[pred],list[term],list[pred],list[pred],list[term]){}.
  flattenBody([],Q,Pr,Pr,Q).
  flattenBody([P,..L],Q,Pre,Prx,NQ) :-
    flattenPred(P,Q,NP,Pre,[NP,..Ps],Ps,P2,Q1),
    flattenBody(L,Q1,P2,Prx,NQ).

  flattenPred:(pred,list[term],pred,list[pred],list[pred],list[pred],list[pred],list[term]){}.
  flattenPred(call(TLc,Op,Args),Q,call(TLc,NOp,NArgs),Pre,Prx,Post,Psx,Qx) :-
    flattenTerm(Op,Q,NOp,Pre,Pr0,Post,Ps0,Q0),
    flattenTerms(Args,Q0,NArgs,Pr0,Prx,Ps0,Psx,Qx).
  flattenPred(ecall(TLc,Op,Args),Q,ecall(TLc,Op,NArgs),Pr,Prx,Ps,Psx,Qx) :-
    flattenTerms(Args,Q,NArgs,Pr,Prx,Ps,Psx,Qx).
  flattenPred(ocall(TLc,Cl,Lb,Th),Q,ocall(TLc,NCl,NLb,NTh),Pre,Prx,Post,Psx,Qx) :-
    flattenTerm(Cl,Q,NCl,Pre,Pr0,Post,Ps0,Q0),
    flattenTerm(Lb,Q0,NLb,Pr0,Pr1,Ps0,Ps1,Q1),
    flattenTerm(Th,Q1,NTh,Pr1,Prx,Ps1,Psx,Qx).
  flattenPred(unfy(TLc,L,R),Q,NP,Pre,Prx,Post,Psx,Qx) :-
    flattenUnify(TLc,L,R,Q,NP,Pre,Prx,Post,Psx,Qx).
  flattenPred(dfne(TLc,L,R),Q,NP,Pre,Prx,Post,Psx,Qx) :-
    flattenUnify(TLc,L,R,Q,NP,Pre,Prx,Post,Psx,Qx).
  flattenPred(neck,Q,neck,Pr,Pr,Ps,Ps,Q).
  flattenPred(fail,Q,fail,Pr,Pr,Ps,Ps,Q).
  flattenPred(succ,Q,succ,Pr,Pr,Ps,Ps,Q).
  flattenPred(except(TLc,E),Q,except(TLc,NE),Pre,Prx,Pos,Psx,Qx) :-
    flattenTerm(E,Q,NE,Pre,Prx,Post,Psx,Qx).
  flattenPred(cond(Lc,T,L,R),Q,cond(Lc,T1,simplifyCond(conj(Lc,LPs)),simplifyCond(conj(Lc,RPs))),Pre,Prx,Pos,Psx,Qx) :-
    flattenPred(T,Q,T1,Pre,Prx,Pos,Psx,Q0),
    flattenPred(L,Q0,L1,LPs,[L1,..LPx],LPx,[],Q1),
    flattenPred(R,Q1,R1,RPs,[R1,..RPx],RPx,[],Qx).
  flattenPred(conj(_,[P]),Q,Fp,Pre,Prx,Post,Psx,Qx) :-
    flattenPred(P,Q,Fp,Pre,Prx,Post,Psx,Qx).
  flattenPred(conj(Lc,L),Q,conj(Lc,FL),Pre,Pre,Post,Post,Qx) :-
    flattenBody(L,Q,FL,[],Qx).

  flattenUnify:(option[tloc],term,term,list[term],pred,list[pred],list[pred],list[pred],list[pred],list[term]){}.
  flattenUnify(Lc,varbl(V),invoke(ILc,Op,Args),Q,dfne(Lc,varbl(V),invoke(ILc,NOp,NArgs)),Pre,Prx,Pst,Pstx,Qx) :-
    flattenTerm(Op,Q,NOp,Pre,Pr0,Pst,Pst0,Q0),
    flattenTerms(Args,Q0,NArgs,Pr0,Prx,Pst0,Pstx,Qx).
  flattenUnify(Lc,invoke(ILc,Op,Args),varbl(V),Q,dfne(Lc,varbl(V),invoke(ILc,NOp,NArgs)),Pre,Prx,Pst,Pstx,Qx) :-
    flattenTerm(Op,Q,NOp,Pre,Pr0,Pst,Pst0,Q0),
    flattenTerms(Args,Q0,NArgs,Pr0,Prx,Pst0,Pstx,Qx).
  flattenUnify(Lc,L,R,Q,unfy(Lc,NL,NR),Pre,Prx,Pst,Pstx,Qx) :-
    flattenTerm(L,Q,NL,Pre,Pr0,Pst,Pst0,Q0),
    flattenTerm(R,Q0,NR,Pr0,Prx,Pst0,Pstx,Qx).
  flattenUnify(Lc,L,R,Q,dfne(Lc,NL,NR),Pre,Prx,Pst,Pstx,Qx) :-
    flattenTerm(L,Q,NL,Pre,Pr0,Pst,Pst0,Q0),
    flattenTerm(R,Q0,NR,Pr0,Prx,Pst0,Pstx,Qx).

  flowRewrite:(clse) => clse.
  flowRewrite(clse(Q,Nm,Args,Body)) => clse(Q,Nm,Args,reflowPreds(topsort(flowDepends(Body)))).
  flowRewrite(eqn(Q,Nm,Args,guarded(Rep,Body))) => eqn(Q,Nm,Args,guarded(Rep,reflowPred(Body))).
  flowRewrite(eqn(Q,Nm,Args,Rep)) => eqn(Q,Nm,Args,Rep).

  varDep ::= vars(pred,list[term],list[term]).

  implementation depends[varDep->>term] <= {
    defines(vars(_,Vs,_),V) :- V in Vs.

    references(vars(_,_,Vs)) => Vs.
  }

  reflowPred:(pred)=>pred.
  reflowPred(conj(Lc,L)) => simplifyCond(conj(Lc,reflowPreds(topsort(flowDepends(L))))).
  reflowPred(P)=>P.

  reflowPreds:(list[list[varDep]]) => list[pred].
  reflowPreds([]) => [].
  reflowPreds([Gp,..Gps]) => (Gp//((vars(P,_,_))=>P))<>reflowPreds(Gps).

  flowDepends:(list[pred]) => list[varDep].
  flowDepends(L) => flowPreds(L,[]).

  flowPreds:(list[pred],list[term]) =>list[varDep].
  flowPreds([],_) => [].
  flowPreds([P,..L],V) => [flowPred(P,V,V0),..flowPreds(L,V0)].

  flowPred:(pred,list[term],list[term]) => varDep.
  flowPred(call(Lc,Op,Args),V,Vx) => vars(call(Lc,Op,Args),[],findVarsInTerms(Args,[])) :-
    VS = toplevelVars(Args,[]),
    Vx = merge(V,VS).
  flowPred(ecall(Lc,Op,Args),V,Vx) => vars(ecall(Lc,Op,Args),[],findVarsInTerms(Args,[])) :-
    VS = toplevelVars(Args,[]),
    Vx = merge(V,VS).
  flowPred(ocall(Lc,C,L,T),V,Vx) => vars(ocall(Lc,C,L,T),[],findVarsInTerms(Args,[])) :-
    Args = [C,L,T],
    VS = toplevelVars(Args,[]),
    Vx = merge(V,VS).
  flowPred(dfne(Lc,L,R),V,Vx) => vars(dfne(Lc,L,R),VS,findVarsInTerms(Args,[])) :-
    Args = [L,R],
    VS = toplevelVars([L],[]),
    Vx = merge(V,VS).
  flowPred(unfy(Lc,L,R),V,Vx) => vars(unfy(Lc,L,R),[],findVarsInTerms(Args,[])) :-
    Args = [L,R],
    VS = toplevelVars(Args,[]),
    Vx = merge(V,VS).
  flowPred(fail,Vs,Vs) => vars(fail,[],Vs).
  flowPred(succ,Vs,Vs) => vars(succ,[],Vs).
  flowPred(neck,Vs,Vs) => vars(neck,[],Vs).
  flowPred(except(Lc,E),Vx,Vx) => vars(except(Lc,E),[],findVarsInTerm(E,[])).

  toplevelVars:(list[term],list[term]) => list[term].
  toplevelVars(Ts,Vs) => foldLeft(toplevelVrs,Vs,Ts).

  toplevelVrs:(term,list[term]) => list[term].
  toplevelVrs(anon,Vs) => Vs.
  toplevelVrs(varbl(Nm),Vs) => Vs :- varbl(Nm) in Vs.
  toplevelVrs(varbl(Nm),Vs) => [varbl(Nm),..Vs].
  toplevelVrs(intgr(_),Vs) => Vs.
  toplevelVrs(flot(_),Vs) => Vs.
  toplevelVrs(strng(_),Vs) => Vs.
  toplevelVrs(enum(_),Vs) => Vs.
  toplevelVrs(strct(_,_),Vs) => Vs.
  toplevelVrs(prg(_,_),Vs) => Vs.
  toplevelVrs(cons(_,A),Vs) => toplevelVars(A,Vs).
  toplevelVrs(invoke(_,_,_),Vs) => Vs.
  toplevelVrs(escvoke(_,_,_),Vs) => Vs.
  toplevelVrs(ovoke(_,_,_,_),Vs) => Vs.
  toplevelVrs(guarded(T,G),Vs) => toplevelVrs(T,Vs).
}
