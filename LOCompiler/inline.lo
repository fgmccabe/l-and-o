lo.comp.inline{
  import lo.
  import lo.topsort.

  import lo.comp.misc.
  import lo.comp.term.
  import lo.comp.termbase.

  -- temp def
  public inline:(prProg,map[term,rel]) => prProg.
  inline(prProg(Spec,P),M) => trace("inlined program ",prProg(Spec,inlineGroups(dependencySort(P),M))) :-
    logMsg("inline \(values(P):list[rel]) using \(M)").

  dependencySort:(map[term,rel]) => list[list[rel]].
  dependencySort(Prog) => extractGroups(topsort(depends(Prog))).

  private relEntry ::= relEntry(list[term],rel).

  depends:(map[term,rel]) => list[relEntry].
  depends(M) => values(M) // ( (R) => relEntry(getRelRefs(R,A),R)) :-
    A = keys(M).

  implementation depends[relEntry->>term] <= {
    defines(relEntry(_,rel(P,_,_)),P).

    references(relEntry(R,_)) => R.
  }

  implementation display[relEntry] <= {
    disp(R) => dispRelEntry(R).
  }

  dispRelEntry:(relEntry) => ss.
  dispRelEntry(relEntry(Refs,Rl)) => ssSeq([disp(Rl.name),ss("->"),ssSeq(Refs//disp),ss("\n")]).

  getRelRefs:(rel,list[term]) => list[term].
  getRelRefs(rel(_,_,Clses),All) => foldLeft((Refs,Cl)=>getClRefs(Cl,All,Refs),[],Clses).

  getClRefs:(clse,list[term],list[term]) => list[term].
  getClRefs(clse(_,_,A,B),All,Refs) => predRefs(B,All,termRefs(A,All,Refs)).

  predRefs:(list[pred],list[term],list[term]) => list[term].
  predRefs([],_,Refs) => Refs.
  predRefs([P,..R],A,Refs) => predRefs(R,A,predRef(P,A,Refs)).

  predRef:(pred,list[term],list[term]) => list[term].
  predRef(call(_,O,A),All,Refs) => termRefs(A,All,termRef(O,All,Refs)).
  predRef(ecall(_,_,A),All,Refs) => termRefs(A,All,Refs).
  predRef(ocall(_,C,L,S),All,Refs) => termRef(C,All,termRef(L,All,termRef(S,All,Refs))).
  predRef(except(_,E),All,Refs) => termRef(E,All,Refs).
  predRef(_,_,Refs) => Refs.

  termRef:(term,list[term],list[term]) => list[term].
  termRef(enum(Nm),All,Refs) => merge(Refs,[Prg]):- Prg = prg(Nm,3), Prg in All.
  termRef(strct(Nm,_),All,Refs) => merge(Refs,[Prg]):- Prg = prg(Nm,3), Prg in All.
  termRef(Prg,All,Refs) => merge(Refs,[Prg]):- Prg = prg(Nm,Ar), Prg in All.
  termRef(cons(O,A),All,Refs) => termRefs(A,All,termRef(O,All,Refs)).
  termRef(_,_,Refs) => Refs.

  termRefs:(list[term],list[term],list[term]) => list[term].
  termRefs(A,All,Refs) => foldLeft((Rfs,T)=>termRef(T,All,Rfs),Refs,A).

  extractGroups:(list[list[relEntry]]) => list[list[rel]].
  extractGroups([]) => [].
  extractGroups([G,..L]) => [foldLeft((M,relEntry(_,R)) => [R,..M],[],G),..extractGroups(L)].

  inlineGroups:(list[list[rel]],map[term,rel]) => map[term,rel].
  inlineGroups(Groups,I) => foldLeft((M,G)=>inlineGroup(G,M,I),[],Groups).

  inlineGroup:(list[rel],map[term,rel],map[term,rel]) => map[term,rel].
  inlineGroup(Rels,P,I) => foldLeft((M,(R:rel)) => M[R.name->R],P,fixedPoint(Rels,P,I)).

  fixedPoint:(list[rel],map[term,rel],map[term,rel]) => list[rel].
  fixedPoint(TR,P,I) => (Any ? fixedPoint(TR1,P,I) | TR) :-
    TR1 = sweep(TR,false,Any,P,I).

  sweep:(list[rel],logical,logical,map[term,rel],map[term,rel]) => list[rel].
  sweep([],Any,Any,_,_) => [].
  sweep([R,..L],Any,Res,P,I) => [inlineRel(R,Any,Any0,P,I),..sweep(L,Any0,Res,P,I)].

  inlineRel:(rel,logical,logical,map[term,rel],map[term,rel]) => rel.
  inlineRel(rel(Prg,TLc,Clses),Any,RReslt,P,I) => rel(Prg,TLc,OClses) :-
    logMsg("inlining clauses \(Clses)"),
    Inlined = inlineClauses(Clses,false,Reslt,P,I),
    (Reslt ? Inlined=OClses, RReslt=true | Clses=OClses, RReslt=Any),
    logMsg("result of inlining is \(OClses)").

  inlineClauses:(list[clse],logical,logical,map[term,rel],map[term,rel]) => list[clse].
  inlineClauses([],Any,Any,_,_) => [].
  inlineClauses([Cl,..Cls],SoFar,Any,P,I) =>
    (some(NCl) = inlineClause(Cl,P,I) ?
      [NCl,..inlineClauses(Cls,true,Any,P,I)] |
      [Cl,..inlineClauses(Cls,SoFar,Any,P,I)]).

  inlineClause:(clse,map[term,rel],map[term,rel]) => option[clse].
  inlineClause(Cl,P,I) =>  passOverCond(Cl,false,0,countBody(Cl),P,I).

  passOverCond:(clse,logical,integer,integer,map[term,rel],map[term,rel]) => option[clse].
  passOverCond(Cl,Any,Ix,Mx,P,I) => NCl :-
    Ix<Mx,
    ( inlineable(Cl,Ix,P,I) = some([Cand]),resolve(Cl,Ix,Cand,C2) ?
        NCl = passOverCond(C2,true,0,countBody(C2),P,I) |
        NCl = passOverCond(Cl,Any,Ix+1,Mx,P,I)).
  passOverCond(Cl,true,_,_,_,_) => some(Cl).
  passOverCond(Cl,false,_,_,_,_) => none.

  countBody:(clse) => integer.
  countBody(clse(_,_,_,B)) => size(B).

  inlineable:(clse,integer,map[term,rel],map[term,rel]) => option[list[clse]].
  inlineable(Cl,Ix,P,I) => some(resolveableClauses(Cl,Ix,Cls)) :-
    inlineableCall(nthPred(Cl,Ix),P,I,Cls).
  inlineable(_,_,_,_) => none.

  inlineableCall:(pred,map[term,rel],map[term,rel],list[clse]){}.
  inlineableCall(call(_,Pr,_),P,I,Cls) :- (present(P,Pr,rel(_,_,Cls)) | present(I,Pr,rel(_,_,Cls))).
  inlineableCall(ocall(_,_,Lb,_),P,I,Cls) :-
    consistentLbl(Pr,Lb),
    (present(P,Pr,rel(_,_,Cls)) | present(I,Pr,rel(_,_,Cls))).
  inlineableCall(unfy(_,L,R),_,_,[clse([varbl("X")],prg("=",2),[varbl("X"),varbl("X")],[])]).

  resolveableClauses:(clse,integer,list[clse]) => list[clse].
  resolveableClauses(Cl,Ix,[]) => [].
  resolveableClauses(Cl,Ix,[C,..L]) => [C,..resolveableClauses(Cl,Ix,L)] :-
    resolveable(Cl,Ix,C).
  resolveableClauses(Cl,Ix,[_,..L]) => resolveableClauses(Cl,Ix,L).

  resolveable:(clse,integer,clse){}.
  resolveable(C1,Ix,C2) :-
    renameClse(C2,NC2,_),
    checkCall(nthPred(C1,Ix),clName(NC2),A2),
    unifyEls(A2,clArgs(NC2),[],_).

  -- resolve the Ixth goal in C1 with the head of C2, resulting in the new clause C3.
  public resolve:(clse,integer,clse,clse){}.
  resolve(clse(Q,Prd,Args,Body),Ix,C2,findSingletons(Resolvant)) :-
    logMsg("resolving \(clse(Q,Prd,Args,Body))@\(Ix) with \(C2)"),
    split(Body,Ix,Lhs,Call,Rhs),
    -- logMsg("lhs=\(Lhs), rhs=\(Rhs)"),
    (Call = unfy(_,_,_) ?
      resolveEquality(Q,Prd,Args,Lhs,Call,Rhs,Resolvant)
    | resolveCall(Q,Prd,Args,Lhs,Call,Rhs,C2,Resolvant))!,
    logMsg("resolves to \(Resolvant)").

  resolveEquality:(list[term],term,list[term],list[pred],pred,list[pred],clse){}.
  resolveEquality(Q,Prd,Args,Lhs,unfy(_,L,R),Rhs,Resolvant) :-
    (L = anon | \+ containsAnons(L)),
    (R = anon | \+ containsAnons(R)),
    unifyTerm(L,R,[],Mx)!,
    NQ = foldLeft(collectVar,otherVars(Q,Mx),pairs(Mx)),
    (neck in Lhs ?
      varbl(Nm) in findVarsInPreds(Lhs,findVarsInList(Args,[])) *> \+ present(Mx,Nm,_)
    | true),
    Resolvant = clse(NQ,Prd,renameEls(Args,Mx),renamePreds(Lhs,Mx)<>renamePreds(Rhs,Mx)).

  resolveCall:(list[term],term,list[term],list[pred],pred,list[pred],clse,clse){}.
  resolveCall(Q,Prd,Args,Lhs,Call,Rhs,C2,Resolvant) :-
    renameClse(C2,clse(Q2,P2,A2,B2),V),
    checkCall(Call,P2,CArgs),
    unifyEls(CArgs,A2,[],Mx)!,
    NQ = foldLeft(collectVar,otherVars(Q,Mx),pairs(Mx+V)),
    resolvant(NQ,Prd,Args,Lhs,B2,Rhs,Mx,Resolvant).

  -- There are many cases to consider when computing the body of the resolvant,
  -- mostly due to the complex semantics of cut/neck.

  resolvant:(list[term],term,list[term],list[pred],list[pred],list[pred],map[string,term],clse){}.
  resolvant(NQ,Prd,Args,Lhs,[neck,..B],Rhs,Mx,clse(NQ,Prd,renameEls(Args,Mx),renamePreds(Lhs<>B<>Rhs,Mx))) :- \+ neck in Lhs.
  resolvant(NQ,Prd,Args,Lhs,[neck,..B],Rhs,Mx,clse(merge(NQ,AV),Prd,Args,NBody)) :-
    concat(FL,[neck,..BL],Lhs),
    AV = findVarsInList(Args,[]),
    NBody = FL<>[neck,..genEqualities(findVarsInPreds(FL,AV),Mx)]<>renamePreds(BL,Mx)<>renamePreds(B,Mx)<>renamePreds(Rhs,Mx).
  resolvant(NQ,Prd,Args,Lhs,B,Rhs,Mx,clse(NQ,Prd,renameEls(Args,Mx),renamePreds(Lhs<>B<>Rhs,Mx))) :- \+ neck in Lhs, \+ neck in B.
  resolvant(NQ,Prd,Args,Lhs,B,Rhs,Mx,clse(merge(NQ,AV),Prd,Args,NBody)) :-
    concat(FL,[neck,..BL],Lhs),
    \+neck in B,
    AV = findVarsInList(Args,[]),
    NBody = FL<>[neck,..genEqualities(findVarsInPreds(FL,AV),Mx)]<>renamePreds(BL,Mx)<>renamePreds(B,Mx)<>renamePreds(Rhs,Mx).

  genEqualities:(list[term],map[string,term]) => list[pred].
  genEqualities([],_) => [].
  genEqualities([varbl(Nm),..V],Mx) => [unfy(none,varbl(Nm),renameTerm(Nt,Mx)),..genEqualities(V,Mx)]:-
    present(Mx,Nm,Nt).
  genEqualities([_,..V],Mx) => genEqualities(V,Mx).

  checkCall:(pred,term,list[term]){}.
  checkCall(call(_,Prd,Els),Prd,Els).
  checkCall(ocall(_,C,Lb,Th),Prd,[C,Lb,Th]) :-
    consistentLbl(Prd,Lb).
  checkCall(unfy(_,L,R),prg("=",2),[L,R]).

  consistentLbl:(term,term){}.
  consistentLbl(prg(Nm,3),enum(Nm)).
  consistentLbl(prg(Nm,3),cons(strct(Nm,_),_)).

  collectVar:(list[term],(string,term)) => list[term].
  collectVar(Q,(Nm,varbl(XX))) => [varbl(XX),..Q].
  collectVar(Q,_) => Q.

  otherVars:(list[term],map[string,term])=>list[term].
  otherVars(Q,Mx) => Q^/((varbl(Nm)):-\+present(Mx,Nm,_)). -- select variables not in unify map.

  mkVars:(list[term]) => map[string,term].
  mkVars(Els) => foldLeft((M,varbl(Nm))=>M[Nm->varbl(_str_gen(Nm))],[],Els).

  renameTerm:(term,map[string,term]) => term.
  renameTerm(varbl(Nm),V) => renameTerm(VV,V) :- present(V,Nm,VV).
  renameTerm(varbl(Nm),V) => varbl(Nm) :- \+ present(V,Nm,_).
  renameTerm(anon,_) => anon.
  renameTerm(T,_) => T :- isGroundTerm(T).
  renameTerm(cons(Op,Els),V) => cons(renameTerm(Op,V),renameEls(Els,V)).

  renameEls:(list[term],map[string,term])=> list[term].
  renameEls([],_) => [].
  renameEls([T,..L],V) => [renameTerm(T,V),..renameEls(L,V)].

  renamePred:(pred,map[string,term]) => pred.
  renamePred(call(TLc,O,A),V) => call(TLc,renameTerm(O,V),renameEls(A,V)).
  renamePred(ecall(TLc,O,A),V) => ecall(TLc,O,renameEls(A,V)).
  renamePred(ocall(TLc,O,A,T),V) => ocall(TLc,renameTerm(O,V),renameTerm(A,V),renameTerm(T,V)).
  renamePred(unfy(TLc,L,R),V) => unfy(TLc,renameTerm(L,V),renameTerm(R,V)).
  renamePred(except(TLc,A),V) => except(TLc,renameTerm(A,V)).
  renamePred(neck,_) => neck.
  renamePred(fail,_) => fail.

  renamePreds:(list[pred],map[string,term])=> list[pred].
  renamePreds([],_) => [].
  renamePreds([T,..L],V) => [renamePred(T,V),..renamePreds(L,V)].

  renameClse:(clse,clse,map[string,term]){}.
  renameClse(clse(Q,Nm,A,B),clse(renameEls(Q,V),Nm,renameEls(A,V),renamePreds(B,V)),V) :-
    V = mkVars(Q).

  unifyTerm:(term,term,map[string,term],map[string,term]){}.
  unifyTerm(T1,T2,M,Mx) :-
    unifyT(deRef(T1,M),deRef(T2,M),M,Mx).

  unifyT:(term,term,map[string,term],map[string,term]){}.
  unifyT(anon,_,M,M).
  unifyT(_,anon,M,M).
  unifyT(varbl(N1),T2,M,Mx) :- bind(N1,T2,M,Mx).
  unifyT(T1,varbl(N2),M,Mx) :- bind(N2,T1,M,Mx).
  unifyT(T,T,M,M) :- isGroundTerm(T).
  unifyT(cons(O1,E1),cons(O2,E2),M,Mx) :-
    unifyTerm(O1,O2,M,M1),
    unifyEls(E1,E2,M1,Mx).

  -- We write this recursion by hand to facilitate debugging
  unifyEls:(list[term],list[term],map[string,term],map[string,term]){}.
  unifyEls([],[],M,M).
  unifyEls([E1,..L1],[E2,..L2],M,Mx) :-
    unifyTerm(E1,E2,M,M1),
    unifyEls(L1,L2,M1,Mx).

  bind:(string,term,map[string,term],map[string,term]){}.
  bind(Nm,varbl(Nm),M,M).
  bind(Nm,T,M,M[Nm->T]) :- T\=varbl(Nm).

  deRef:(term,map[string,term]) => term.
  deRef(varbl(Nm),M) => deRef(V,M) :- present(M,Nm,V).
  deRef(T,_) => T.

  -- Finding variables
  findVars:(term,list[term]) => list[term].
  findVars(varbl(Nm),V) => mergeEl(V,varbl(Nm)).
  findVars(T,V) => V :- isGroundTerm(T).
  findVars(anon,V) => V.
  findVars(cons(_,A),V) => findVarsInList(A,V).

  findVarsInList:(list[term],list[term]) => list[term].
  findVarsInList([],V) => V.
  findVarsInList([T,..L],V) => findVarsInList(L,findVars(T,V)).

  findVarsInPred:(list[term],pred) => list[term].
  findVarsInPred(V,call(_,_,A)) => findVarsInList(A,V).
  findVarsInPred(V,ecall(_,_,A)) => findVarsInList(A,V).
  findVarsInPred(V,ocall(_,C,L,T)) => findVars(C,findVars(L,findVars(T,V))).
  findVarsInPred(V,unfy(_,L,T)) => findVars(L,findVars(T,V)).
  findVarsInPred(V,except(_,E)) => findVars(E,V).
  findVarsInPred(V,fail) => V.
  findVarsInPred(V,neck) => V.

  findVarsInPreds:(list[pred],list[term]) => list[term].
  findVarsInPreds(Ps,V) => foldLeft(findVarsInPred,V,Ps).

  countVars:(term,map[string,integer]) => map[string,integer].
  countVars(varbl(Nm),V) => V[Nm->Cnt+1] :- present(V,Nm,Cnt).
  countVars(varbl(Nm),V) => V[Nm->1].
  countVars(T,V) => V :- isGroundTerm(T).
  countVars(anon,V) => V.
  countVars(cons(_,A),V) => countVarsInList(A,V).

  countVarsInList:(list[term],map[string,integer]) => map[string,integer].
  countVarsInList([],V) => V.
  countVarsInList([T,..L],V) => countVarsInList(L,countVars(T,V)).

  countVarsInPreds:(list[pred],map[string,integer]) => map[string,integer].
  countVarsInPreds(Ps,V) => foldRight(countVarsInPred,V,Ps).

  countVarsInPred:(map[string,integer],pred) => map[string,integer].
  countVarsInPred(V,call(_,_,A)) => countVarsInList(A,V).
  countVarsInPred(V,ecall(_,_,A)) => countVarsInList(A,V).
  countVarsInPred(V,ocall(_,C,L,T)) => countVars(C,countVars(L,countVars(T,V))).
  countVarsInPred(V,unfy(_,L,T)) => countVars(L,countVars(T,V)).
  countVarsInPred(V,except(_,E)) => countVars(E,V).
  countVarsInPred(V,fail) => V.
  countVarsInPred(V,neck) => V.

  findSingletons:(clse) => clse.
  findSingletons(clse(Q,Nm,Args,Preds)) => clse(Q^/((varbl(V)) :- present(M,V,Cnt), Cnt>1),Nm,renameEls(Args,Mx),renamePreds(Preds,Mx)) :-
    M = countVarsInList(Args,countVarsInPreds(Preds,foldLeft((Mp,varbl(Vn))=>Mp[Vn->0],[],Q))),
    Mx = singletonMap(M).

  singletonMap:(map[string,integer]) => map[string,term].
  singletonMap(M) => foldMap((Nm,Cnt,Mx) => (Cnt>1 ? Mx | Mx[Nm->anon]),[],M).

  containsAnons:(term){}.
  containsAnons(anon).
  containsAnons(cons(_,Els)) :- E in Els, containsAnons(E).
}
