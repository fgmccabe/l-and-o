lo.comp.inline{
  import lo.
  import lo.topsort.

  import lo.comp.misc.
  import lo.comp.term.
  import lo.comp.termbase.

  -- temp def
  public inline:(prProg,map[term,rel]) => prProg.
  inline(prProg(Spec,P),M) => trace("inlined program:\n",prProg(Spec,inlineGroups(dependencySort(P),M))) :-
    logMsg("inline:\n\(prProg(Spec,P))])\nusing \(M)").

  dependencySort:(map[term,rel]) => list[list[rel]].
  dependencySort(Prog) => extractGroups(topsort(depends(Prog))).

  private relEntry ::= relEntry(list[term],rel).

  depends:(map[term,rel]) => list[relEntry].
  depends(M) => values(M) // ( (R) => relEntry(getRelRefs(R,A),R)) :-
    A = keys(M).

  implementation depends[relEntry->>term] <= {
    defines(relEntry(_,rel(P,_,_)),P).

    references(relEntry(R,_)) => R.
  }

  implementation display[relEntry] <= {
    disp(R) => dispRelEntry(R).
  }

  dispRelEntry:(relEntry) => ss.
  dispRelEntry(relEntry(Refs,Rl)) => ssSeq([disp(Rl.name),ss("->"),ssSeq(Refs//disp),ss("\n")]).

  getRelRefs:(rel,list[term]) => list[term].
  getRelRefs(rel(_,_,Clses),All) => foldLeft((Cl,Refs)=>getClRefs(Cl,All,Refs),[],Clses).

  getClRefs:(clse,list[term],list[term]) => list[term].
  getClRefs(clse(_,_,A,B),All,Refs) => predRefs(B,All,termRefs(A,All,Refs)).
  getClRefs(eqn(_,_,A,R),All,Refs) => termRefs(A,All,termRef(R,All,Refs)).

  predRefs:(list[pred],list[term],list[term]) => list[term].
  predRefs([],_,Refs) => Refs.
  predRefs([P,..R],A,Refs) => predRefs(R,A,predRef(P,A,Refs)).

  predRef:(pred,list[term],list[term]) => list[term].
  predRef(call(_,O,A),All,Refs) => termRefs(A,All,termRef(O,All,Refs)).
  predRef(ecall(_,_,A),All,Refs) => termRefs(A,All,Refs).
  predRef(ocall(_,C,L,S),All,Refs) => termRef(C,All,termRef(L,All,termRef(S,All,Refs))).
  predRef(except(_,E),All,Refs) => termRef(E,All,Refs).
  predRef(unfy(_,L,R),All,Refs) => termRef(L,All,termRef(R,All,Refs)).
  predRef(_,_,Refs) => Refs.

  termRef:(term,list[term],list[term]) => list[term].
  termRef(enum(Nm),All,Refs) => merge(Refs,[Prg]):- Prg = prg(Nm,3), Prg in All.
  termRef(strct(Nm,_),All,Refs) => merge(Refs,[Prg]):- Prg = prg(Nm,3), Prg in All.
  termRef(Prg,All,Refs) => merge(Refs,[Prg]):- Prg = prg(Nm,Ar), Prg in All.
  termRef(cons(O,A),All,Refs) => termRefs(A,All,termRef(O,All,Refs)).
  termRef(invoke(_,O,A),All,Refs) => termRefs(A,All,termRef(O,All,Refs)).
  termRef(ovoke(_,C,L,T),All,Refs) => termRef(C,All,termRef(L,All,termRef(T,All,Refs))).
  termRef(escvoke(_,_,A),All,Refs) => termRefs(A,All,Refs).
  termRef(guarded(T,C),All,Refs) => termRef(T,All,predRefs(C,All,Refs)).
  termRef(_,_,Refs) => Refs.

  termRefs:(list[term],list[term],list[term]) => list[term].
  termRefs(A,All,Refs) => foldLeft((T,Rfs)=>termRef(T,All,Rfs),Refs,A).

  extractGroups:(list[list[relEntry]]) => list[list[rel]].
  extractGroups([]) => [].
  extractGroups([G,..L]) => [foldLeft((relEntry(_,R),M) => [R,..M],[],G),..extractGroups(L)].

  inlineGroups:(list[list[rel]],map[term,rel]) => map[term,rel].
  inlineGroups(Groups,I) => foldLeft((G,M)=>inlineGroup(G,M,I),[],Groups).

  inlineGroup:(list[rel],map[term,rel],map[term,rel]) => map[term,rel].
  inlineGroup(Rels,P,I) => foldLeft(((R:rel),M) => M[R.name->R],P,relFxPt(Rels,P,I)).

  relFxPt:(list[rel],map[term,rel],map[term,rel]) => list[rel].
  relFxPt(TR,P,I) => (Any ? relFxPt(TR1,P,I) | TR) :-
    TR1 = sweep(TR,false,Any,P,I).

  sweep:(list[rel],logical,logical,map[term,rel],map[term,rel]) => list[rel].
  sweep([],Any,Any,_,_) => [].
  sweep([R,..L],Any,Res,P,I) => [inlineRel(R,Any,Any0,P,I),..sweep(L,Any0,Res,P,I)].

  inlineRel:(rel,logical,logical,map[term,rel],map[term,rel]) => rel.
  inlineRel(rel(Prg,TLc,Clses),Any,RReslt,P,I) => rel(Prg,TLc,OClses) :-
    logMsg("inlining clauses \(Clses)"),
    Inlined = inlineRules(Clses,false,Reslt,P,I),
    (Reslt ? Inlined=OClses, RReslt=true | Clses=OClses, RReslt=Any),
    logMsg("result of inlining is \(OClses)").

  inlineRules:(list[clse],logical,logical,map[term,rel],map[term,rel]) => list[clse].
  inlineRules([],Fx,Fx,_,_) => [].
  inlineRules([Cl,..Cls],SoFar,Fx,P,I) => [Rl,..inlineRules(Cls,F0,Fx,P,I)] :-
    Rl = fixedPoint(((Cin,Cout) => inlineRule(Cin,Cout,P,I)),Cl,SoFar,F0).

  inlineRule:(clse,clse,map[term,rel],map[term,rel])=>logical.
  inlineRule(clse(Q,Nm,A,B),Cout,P,I) => Fx :-
    NA = inlineTerms(A,P,I,false,F0,[],U0),
    NB = inlinePreds(B,P,I,F0,Fx,U0,Ux),
    Cout = tidyUpRule(clse(Q,Nm,NA,NB),Ux).
  inlineRule(eqn(Q,Nm,A,R),Cout,P,I) => Fx :-
    NA = inlineTerms(A,P,I,false,F0,[],U0),
    NR = simplifyGuard(inlineTerm(R,P,I,F0,Fx,U0,Ux)),
    Cout = tidyUpRule(eqn(Q,Nm,NA,NR),Ux).

  tidyUpRule:(clse,map[string,term]) => clse.
  tidyUpRule(Cl,Ux) => requant(applyUxToClse(Cl,Ux)).

  requant:(clse) => clse.
  requant(clse(Q,Nm,A,B)) => clse(findVarsInClse(clse(Q,Nm,A,B)),Nm,A,B).
  requant(eqn(Q,Nm,A,R)) => eqn(findVarsInClse(eqn(Q,Nm,A,R)),Nm,A,R).

  inlineTerm:(term,map[term,rel],map[term,rel],logical,logical,map[string,term],map[string,term]) => term.
  inlineTerm(T,_,_,S,S,U,U) => T :- isGroundTerm(T).
  inlineTerm(varbl(Nm),P,I,F,Fx,U,Ux) => inlineTerm(Rep,P,I,true,Fx,U,Ux) :- present(U,Nm,Rep).
  inlineTerm(varbl(Nm),_,_,S,S,U,U) => varbl(Nm).
  inlineTerm(anon,_,_,S,S,U,U) => anon.
  inlineTerm(cons(Op,A),P,I,S,O,U,Ux) => cons(Op,inlineTerms(A,P,I,S,O,U,Ux)).
  inlineTerm(escvoke(Lc,Op,A),P,I,S,O,U,Ux) => escvoke(Lc,Op,inlineTerms(A,P,I,S,O,U,Ux)).
  inlineTerm(invoke(Lc,Op,A),P,I,S,O,U,Ux) => checkInline(invoke(Lc,Op,inlineTerms(A,P,I,S,S0,U,U0)),P,I,S0,O,U0,Ux).
  inlineTerm(ovoke(Lc,Cl,Lb,Th),P,I,S,O,U,Ux) => checkInline(ovoke(Lc,inlineTerm(Cl,P,I,S,S0,U,U0),inlineTerm(Lb,P,I,S0,S1,U0,U1),inlineTerm(Th,P,I,S1,S2,U1,U2)),P,I,S2,O,U2,Ux).
  inlineTerm(guarded(T,C),P,I,F,Fx,U,Ux) => simplifyGuard(guarded(checkInline(inlineTerm(T,P,I,F,F0,U,U0),P,I,F0,F1,U0,U1),inlinePreds(C,P,I,F1,Fx,U1,Ux))).

  inlineTerms:(list[term],map[term,rel],map[term,rel],logical,logical,map[string,term],map[string,term]) => list[term].
  inlineTerms([],_,_,Fx,Fx,U,U) => [].
  inlineTerms([T,..A],P,I,F,Fx,U,Ux) => [checkInline(inlineTerm(applyToTerm(T,U),P,I,F,F0,U,U0),P,I,F0,F1,U0,U1),..inlineTerms(A,P,I,F1,Fx,U1,Ux)].

  checkInline:(term,map[term,rel],map[term,rel],logical,logical,map[string,term],map[string,term]) => term.
  checkInline(T,P,I,S,O,U,Ux) => inlineTerm(applyToTerm(Nt,U),P,I,true,O,mergeTheta(Th,U),Ux):-
    inlineableTerm(T,P,I) = [(Nt,Th)].
  checkInline(T,_,_,S,S,U,U) => T.

  inlineableTerm:(term,map[term,rel],map[term,rel]) => list[(term,map[string,term])].
  inlineableTerm(invoke(Lc,Op,Args),P,I) => Choices :-
    (present(P,Op,rel(_,_,Cls)) | present(I,Op,rel(_,_,Cls))),
    attemptRewrites(Args,Cls,[],Choices).
  inlineableTerm(ovoke(Lc,Call,Lb,Th),P,I) => Choices :-
    consistentLbl(Pr,Lb),
    (present(P,Pr,rel(_,_,Cls)) | present(I,Pr,rel(_,_,Cls))),
    attemptRewrites([Call,Lb,Th],Cls,[],Choices).
  inlineableTerm(_,_,_) => [].

  attemptRewrites:(list[term],list[clse],list[(term,map[string,term])],list[(term,map[string,term])]){}.
  attemptRewrites(_,[],Rew,Rew).
  attemptRewrites(Args,[Eq,..L],S,C) :-
    attemptEqn(Args,Eq,S,S0),
    attemptRewrites(Args,L,S0,C).

  attemptEqn:(list[term],clse,list[(term,map[string,term])],list[(term,map[string,term])]){}.
  attemptEqn(Args,Eq,SoFar,[(applyToTerm(R,Th),Th),..SoFar]) :-
    renameClse(Eq,eqn(_,_,NA,R),_),
    unifyEls(Args,NA,[],Th).
  attemptEqn(_,_,SoFar,SoFar).

  inlinePreds:(list[pred],map[term,rel],map[term,rel],logical,logical,map[string,term],map[string,term]) => list[pred].
  inlinePreds([],_,_,S,S,U,U) => [].
  inlinePreds([Pr,..L],P,I,S,O,U,Ux) => inlinePred(applyToPred(Pr,U),P,I,S,S0,U,U0)<>inlinePreds(L,P,I,S0,O,U0,Ux).

  inlinePred:(pred,map[term,rel],map[term,rel],logical,logical,map[string,term],map[string,term]) => list[pred].
  inlinePred(Pr,P,I,_,true,U,Ux) => applyToPreds(B,Ux):-
    inlineable(Pr,P,I,Cls),
    checkCall(Pr,clName(Cls),A2),
    renameClse(Cls,clse(_,_,NA,B),_),
    unifyEls(A2,NA,U,Ux).
  inlinePred(Pr,_,_,S,S,U,U) => [Pr].

  inlineable:(pred,map[term,rel],map[term,rel],clse){}.
  inlineable(Pr,P,I,Cls) :-
    inlineableCall(Pr,P,I,Clses),
    [Cls] = resolveableClauses(Pr,Clses).

  inlineableCall:(pred,map[term,rel],map[term,rel],list[clse]){}.
  inlineableCall(call(_,Pr,_),P,I,Cls) :- (present(P,Pr,rel(_,_,Cls)) | present(I,Pr,rel(_,_,Cls))).
  inlineableCall(ocall(_,_,Lb,_),P,I,Cls) :-
    consistentLbl(Pr,Lb),
    (present(P,Pr,rel(_,_,Cls)) | present(I,Pr,rel(_,_,Cls))).
  inlineableCall(unfy(_,L,R),_,_,[clse([varbl("X")],prg("=",2),[varbl("X"),varbl("X")],[])]).

  resolveableClauses:(pred,list[clse]) => list[clse].
  resolveableClauses(_,[]) => [].
  resolveableClauses(Pr,[C,..L]) => [C,..resolveableClauses(Pr,L)] :-
    resolveable(Pr,C).
  resolveableClauses(Pr,[_,..L]) => resolveableClauses(Pr,L).

  resolveable:(pred,clse){}.
  resolveable(Pr,C2) :-
    renameClse(C2,NC2,_),
    checkCall(Pr,clName(NC2),A2),
    unifyEls(A2,clArgs(NC2),[],_).

  checkCall:(pred,term,list[term]){}.
  checkCall(call(_,Prd,Els),Prd,Els).
  checkCall(ocall(_,C,Lb,Th),Prd,[C,Lb,Th]) :-
    consistentLbl(Prd,Lb).
  checkCall(unfy(_,L,R),prg("=",2),[L,R]).

  consistentLbl:(term,term){}.
  consistentLbl(prg(Nm,3),enum(Nm)).
  consistentLbl(prg(Nm,3),cons(strct(Nm,_),_)).

  mkVars:(list[term]) => map[string,term].
  mkVars(Els) => foldLeft((varbl(Nm),M)=>M[Nm->varbl(_str_gen(Nm))],[],Els).

  applyToTerm:(term,map[string,term]) => term.
  applyToTerm(varbl(Nm),V) => applyToTerm(VV,V) :- present(V,Nm,VV).
  applyToTerm(varbl(Nm),V) => varbl(Nm) :- \+ present(V,Nm,_).
  applyToTerm(anon,_) => anon.
  applyToTerm(T,_) => T :- isGroundTerm(T).
  applyToTerm(cons(Op,Els),V) => cons(applyToTerm(Op,V),applyToTerms(Els,V)).
  applyToTerm(invoke(Lc,Op,A),V) => invoke(Lc,Op,applyToTerms(A,V)).
  applyToTerm(ovoke(Lc,C,L,T),V) => ovoke(Lc,applyToTerm(C,V),applyToTerm(L,V),applyToTerm(T,V)).
  applyToTerm(escvoke(Lc,Op,A),V) => escvoke(Lc,Op,applyToTerms(A,V)).
  applyToTerm(guarded(T,[]),V) => applyToTerm(T,V).
  applyToTerm(guarded(T,C),V) => guarded(applyToTerm(T,V),applyToPreds(C,V)).

  applyToTerms:(list[term],map[string,term])=> list[term].
  applyToTerms([],_) => [].
  applyToTerms([T,..L],V) => [applyToTerm(T,V),..applyToTerms(L,V)].

  applyToPred:(pred,map[string,term]) => pred.
  applyToPred(call(TLc,O,A),V) => call(TLc,applyToTerm(O,V),applyToTerms(A,V)).
  applyToPred(ecall(TLc,O,A),V) => ecall(TLc,O,applyToTerms(A,V)).
  applyToPred(ocall(TLc,O,A,T),V) => ocall(TLc,applyToTerm(O,V),applyToTerm(A,V),applyToTerm(T,V)).
  applyToPred(unfy(TLc,L,R),V) => unfy(TLc,applyToTerm(L,V),applyToTerm(R,V)).
  applyToPred(except(TLc,A),V) => except(TLc,applyToTerm(A,V)).
  applyToPred(neck,_) => neck.
  applyToPred(fail,_) => fail.

  applyToPreds:(list[pred],map[string,term])=> list[pred].
  applyToPreds([],_) => [].
  applyToPreds([T,..L],V) => [applyToPred(T,V),..applyToPreds(L,V)].

  applyUxToClse:(clse,map[string,term]) => clse.
  applyUxToClse(clse(Q,Nm,A,B),Ux) => clse(applyToTerms(Q,Ux),Nm,applyToTerms(A,Ux),applyToPreds(B,Ux)).
  applyUxToClse(eqn(Q,Nm,A,R),Ux) => eqn(applyToTerms(Q,Ux),Nm,applyToTerms(A,Ux),applyToTerm(R,Ux)).

  renameClse:(clse,clse,map[string,term]){}.
  renameClse(clse(Q,Nm,A,B),clse(applyToTerms(Q,V),Nm,applyToTerms(A,V),applyToPreds(B,V)),V) :-
    V = mkVars(Q).
  renameClse(eqn(Q,Nm,A,R),eqn(applyToTerms(Q,V),Nm,applyToTerms(A,V),applyToTerm(R,V)),V) :-
    V = mkVars(Q).

  unifyTerm:(term,term,map[string,term],map[string,term]){}.
  unifyTerm(T1,T2,M,Mx) :-
    unifyT(deRef(T1,M),deRef(T2,M),M,Mx).

  unifyT:(term,term,map[string,term],map[string,term]){}.
  unifyT(anon,_,M,M).
  unifyT(_,anon,M,M).
  unifyT(varbl(N1),T2,M,Mx) :- bind(N1,T2,M,Mx).
  unifyT(T1,varbl(N2),M,Mx) :- bind(N2,T1,M,Mx).
  unifyT(T,T,M,M) :- isGroundTerm(T).
  unifyT(cons(O1,E1),cons(O2,E2),M,Mx) :-
    unifyTerm(O1,O2,M,M1),
    unifyEls(E1,E2,M1,Mx).

  -- We write this recursion by hand to facilitate debugging
  unifyEls:(list[term],list[term],map[string,term],map[string,term]){}.
  unifyEls([],[],M,M).
  unifyEls([E1,..L1],[E2,..L2],M,Mx) :-
    unifyTerm(E1,E2,M,M1),
    unifyEls(L1,L2,M1,Mx).

  mergeTheta:(map[string,term],map[string,term]) => map[string,term].
  mergeTheta(T1,T2) => foldMap(mergeBind,T2,T1).

  mergeBind:(string,term,map[string,term]) => map[string,term].
  mergeBind(Nm,T,Th) => Th1[Nm->T]:- present(Th,Nm,T2), unifyT(T,T2,Th,Th1).
  mergeBind(Nm,T,Th) => Th[Nm->T].

  bind:(string,term,map[string,term],map[string,term]){}.
  bind(Nm,varbl(Nm),M,M).
  bind(Nm,T,M,M[Nm->T]) :- T\=varbl(Nm).

  deRef:(term,map[string,term]) => term.
  deRef(varbl(Nm),M) => deRef(V,M) :- present(M,Nm,V).
  deRef(T,_) => T.

  countVars:(term,map[string,integer]) => map[string,integer].
  countVars(varbl(Nm),V) => V[Nm->Cnt+1] :- present(V,Nm,Cnt).
  countVars(varbl(Nm),V) => V[Nm->1].
  countVars(T,V) => V :- isGroundTerm(T).
  countVars(anon,V) => V.
  countVars(cons(_,A),V) => countVarsInList(A,V).

  countVarsInList:(list[term],map[string,integer]) => map[string,integer].
  countVarsInList([],V) => V.
  countVarsInList([T,..L],V) => countVarsInList(L,countVars(T,V)).

  countVarsInPreds:(list[pred],map[string,integer]) => map[string,integer].
  countVarsInPreds(Ps,V) => foldRight(countVarsInPred,V,Ps).

  countVarsInPred:(pred,map[string,integer]) => map[string,integer].
  countVarsInPred(call(_,_,A),V) => countVarsInList(A,V).
  countVarsInPred(ecall(_,_,A),V) => countVarsInList(A,V).
  countVarsInPred(ocall(_,C,L,T),V) => countVars(C,countVars(L,countVars(T,V))).
  countVarsInPred(unfy(_,L,T),V) => countVars(L,countVars(T,V)).
  countVarsInPred(except(_,E),V) => countVars(E,V).
  countVarsInPred(fail,V) => V.
  countVarsInPred(neck,V) => V.

  findSingletons:(clse) => clse.
  findSingletons(clse(Q,Nm,Args,Preds)) => clse(Q^/((varbl(V)) :- present(M,V,Cnt), Cnt>1),Nm,applyToTerms(Args,Mx),applyToPreds(Preds,Mx)) :-
    M = countVarsInList(Args,countVarsInPreds(Preds,foldLeft((varbl(Vn),Mp)=>Mp[Vn->0],[],Q))),
    Mx = singletonMap(M).

  singletonMap:(map[string,integer]) => map[string,term].
  singletonMap(M) => foldMap((Nm,Cnt,Mx) => (Cnt>1 ? Mx | Mx[Nm->anon]),[],M).

  containsAnons:(term){}.
  containsAnons(anon).
  containsAnons(cons(_,Els)) :- E in Els, containsAnons(E).

  fixedPoint:all t ~~ ((t,t)=>logical,t,logical,logical) => t.
  fixedPoint(F,X,Ix,Ixx) => checkFxPt(F(X,X0),F,X0,Ix,Ixx).

  checkFxPt:all t ~~ (logical,(t,t)=>logical,t,logical,logical) => t.
  checkFxPt(false,_,X,Fx,Fx) => X.
  checkFxPt(true,F,X,_,Fx) => fixedPoint(F,X,true,Fx).
}
