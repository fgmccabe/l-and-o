lo.comp.inline{
  import lo.
  import lo.topsort.

  import lo.comp.misc.
  import lo.comp.term.
  import lo.comp.termbase.

  -- temp def
  public inline:(prProg,map[term,trel]) => prProg.
  inline(prProg(Spec,P),M) => prProg(Spec,inlineGroups(dependencySort(P),M)) :-
    logMsg("inline \(values(P):list[trel]) using \(M)").

  dependencySort:(map[term,trel]) => list[list[trel]].
  dependencySort(Prog) => G :-
    G = extractGroups(topsort(depends(Prog))),
    showGroups(G).

  showGroups:(list[list[trel]]){}.
  showGroups([]).
  showGroups([G,..L]) :-
    logMsg("inline group:\n\(G)"),
    showGroups(L).

  private type relEntry ::= rel(list[term],trel).

  depends:(map[term,trel]) => list[relEntry].
  depends(M) => values(M) // ( (R) => rel(getRelRefs(R,A),R)) :-
    A = keys(M).

  implementation depends[relEntry->>term] <= {
    defines(rel(_,trel(P,_,_,_)),P).

    references(rel(R,_)) => R.
  }

  implementation display[relEntry] <= {
    disp(R) => dispRelEntry(R).
  }

  dispRelEntry:(relEntry) => ss.
  dispRelEntry(rel(Refs,Rl)) => ssSeq([disp(Rl.name),ss("->"),ssSeq(Refs//disp),ss("\n")]).

  getRelRefs:(trel,list[term]) => list[term].
  getRelRefs(trel(_,_,_,Clses),All) => foldLeft((Refs,Cl)=>getClRefs(Cl,All,Refs),[],Clses).

  getClRefs:(clse,list[term],list[term]) => list[term].
  getClRefs(clse(_,_,A,B),All,Refs) => predRefs(B,All,termRefs(A,All,Refs)).
  getClRefs(gclse(_,_,A,G,B),All,Refs) => predRefs(B,All,predRefs(G,All,termRefs(A,All,Refs))).

  predRefs:(list[pred],list[term],list[term]) => list[term].
  predRefs([],_,Refs) => Refs.
  predRefs([P,..R],A,Refs) => predRefs(R,A,predRef(P,A,Refs)).

  predRef:(pred,list[term],list[term]) => list[term].
  predRef(call(_,O,A),All,Refs) => termRefs(A,All,termRef(O,All,Refs)).
  predRef(ecall(_,_,A),All,Refs) => termRefs(A,All,Refs).
  predRef(ocall(_,C,L,S),All,Refs) => termRef(C,All,termRef(L,All,termRef(S,All,Refs))).
  predRef(except(_,E),All,Refs) => termRef(E,All,Refs).
  predRef(_,_,Refs) => Refs.

  termRef:(term,list[term],list[term]) => list[term].
  termRef(enum(Nm),All,Refs) => merge(Refs,[Prg]):- Prg = prg(Nm,3), Prg in All.
  termRef(strct(Nm,_),All,Refs) => merge(Refs,[Prg]):- Prg = prg(Nm,3), Prg in All.
  termRef(Prg,All,Refs) => merge(Refs,[Prg]):- Prg = prg(Nm,Ar), Prg in All.
  termRef(cons(O,A),All,Refs) => termRefs(A,All,termRef(O,All,Refs)).
  termRef(_,_,Refs) => Refs.

  termRefs:(list[term],list[term],list[term]) => list[term].
  termRefs(A,All,Refs) => foldLeft((Rfs,T)=>termRef(T,All,Rfs),Refs,A).

  extractGroups:(list[list[relEntry]]) => list[list[trel]].
  extractGroups([]) => [].
  extractGroups([G,..L]) => [foldLeft((M,rel(_,R)) => [R,..M],[],G),..extractGroups(L)].

  inlineGroups:(list[list[trel]],map[term,trel]) => map[term,trel].
  inlineGroups(Groups,I) => foldLeft((M,G)=>inlineGroup(G,M,I),[],Groups).

  inlineGroup:(list[trel],map[term,trel],map[term,trel]) => map[term,trel].
  inlineGroup(Rels,P,I) => foldLeft((M,(R:trel)) => M[R.name->R],P,fixedPoint(trace("inlining ",Rels),P,I)).

  fixedPoint:(list[trel],map[term,trel],map[term,trel]) => list[trel].
  fixedPoint(TR,P,I) => (Any ? fixedPoint(TR1,P,I) | TR) :-
    TR1 = sweep(TR,false,Any,P,I).

  sweep:(list[trel],logical,logical,map[term,trel],map[term,trel]) => list[trel].
  sweep([],Any,Any,_,_) => [].
  sweep([R,..L],Any,Res,P,I) => [inlineRel(R,Any,Any0,P,I),..sweep(L,Any0,Res,P,I)].

  inlineRel:(trel,logical,logical,map[term,trel],map[term,trel]) => trel.
  inlineRel(trel(Prg,TLc,Fall,Clses),Any,RReslt,P,I) => trel(Prg,TLc,Fall,OClses) :-
    Inlined = inlineClauses(Clses,false,Reslt,P,I),
    (Reslt ? Inlined=OClses, RReslt=true | Clses=OClses, RReslt=Any),
    logMsg("result of inlining is \(OClses)").

  inlineClauses:(list[clse],logical,logical,map[term,trel],map[term,trel]) => list[clse].
  inlineClauses([],Any,Any,_,_) => [].
  inlineClauses([Cl,..Cls],SoFar,Any,P,I) =>
    (some(NCl) = inlineClause(Cl,P,I) ?
      [NCl,..inlineClauses(Cls,true,Any,P,I)] |
      [Cl,..inlineClauses(Cls,SoFar,Any,P,I)]).

  inlineClause:(clse,map[term,trel],map[term,trel]) => option[clse].
  inlineClause(Cl,P,I) =>  passOverCond(Cl,false,0,countBody(Cl),P,I).

  passOverCond:(clse,logical,integer,integer,map[term,trel],map[term,trel]) => option[clse].
  passOverCond(Cl,Any,Ix,Mx,P,I) => NCl :-
    Ix<Mx,
    ( inlineable(Cl,Ix,P,I) = some([Cand]),resolve(Cl,Ix,Cand,C2),logMsg("resolved \(Cl) is clause:\(C2)") ?
        NCl = passOverCond(C2,true,0,countBody(C2),P,I) |
        NCl = passOverCond(Cl,Any,Ix+1,Mx,P,I)).
  passOverCond(Cl,true,_,_,_,_) => some(Cl).
  passOverCond(Cl,false,_,_,_,_) => none.

  countBody:(clse) => integer.
  countBody(clse(_,_,_,B)) => size(B).
  countBody(gclse(_,_,_,G,B)) => size(G)+size(B).

  inlineable:(clse,integer,map[term,trel],map[term,trel]) => option[list[clse]].
  inlineable(Cl,Ix,P,I) => some(resolveableClauses(Cl,Ix,Clses)) :-
    checkCall(Cl.nth(Ix),Pr,_),
    (present(P,Pr,trel(_,_,Fall,Cls)) | present(I,Pr,trel(_,_,Fall,Cls))),
    (Fall = fallible ? Clses=Cls | dropLast(Cls,Clses)).
  inlineable(_,_,_,_) => none.

  resolveableClauses:(clse,integer,list[clse]) => list[clse].
  resolveableClauses(Cl,Ix,[]) => [].
  resolveableClauses(Cl,Ix,[C,..L]) => [C,..resolveableClauses(Cl,Ix,L)] :-
    resolveable(Cl,Ix,C).
  resolveableClauses(Cl,Ix,[_,..L]) => resolveableClauses(Cl,Ix,L).

  resolveable:(clse,integer,clse){}.
  resolveable(C1,Ix,C2) :-
    renameClse(C2,NC2,_),
    checkCall(C1.nth(Ix),NC2.name,A2),
    unifyEls(A2,NC2.args,[],_).

  -- resolve the head of C1 with the Ixth goal in C2, resulting in the new clause C3.
  public resolve:(clse,integer,clse,clse){}.
  resolve(clse(Q,Prd,Args,Body),Ix,C2,clse(NQ,Prd,renameEls(Args,Mx),renamePreds(Lhs,Mx)<>renamePreds(B2,Mx)<>renamePreds(Rhs,Mx))) :-
    renameClse(C2,clse(_,P2,E2,B2),_),
    split(Body,Ix,Lhs,Call,Rhs),
    checkCall(Call,P2,A2),
    unifyEls(A2,E2,[],Mx),
    NQ = otherVars(Q,Mx)<>foldLeft(collectVar,[],pairs(Mx)).
  resolve(gclse(Q,Prd,Args,Guard,Body),Ix,C2,gclse(NQ,Prd,NArgs,NGuard,NBody)) :-
    renameClse(C2,NC2,V),
    ( Ix<size(Guard) ?
        split(Guard,Ix,Lhs,Call,Rhs),
        checkCall(Call,C2.name,A2),
        unifyEls(A2,NC2.args,[],Mx),
        mergeBody(Lhs,C2,Rhs,Mx,NGuard),
        NArgs = renameEls(Args,Mx),
        NBody = renamePreds(Body,Mx) |
        split(Body,Ix-size(Guard),Lhs,Call,Rhs),
        checkCall(Call,C2.name,A2),
        unifyEls(A2,NC2.args,[],Mx),
        mergeBody(Lhs,C2,Rhs,Mx,NB),
        genEqualities(findVarsInPreds(Guard,findVars(Args,[]),V,Mx,Eqs)),
        NBody = Eqs<>NB,
        NArgs = Args,
        NGuard = Guard).


  checkCall:(pred,term,list[term]){}.
  checkCall(call(_,Prd,Els),Prd,Els).
  checkCall(ocall(_,C,Lb,Th),Prd,[C,Lb,Th]) :-
    consistentLbl(Prd,Lb).

  consistentLbl:(term,term){}.
  consistentLbl(prg(Nm,3),enum(Nm)).
  consistentLbl(prg(Nm,3),cons(strct(Nm,_),_)).

  collectVar:(list[term],(string,term)) => list[term].
  collectVar(Q,(Nm,varbl(XX))) => [varbl(XX),..Q].
  collectVar(Q,_) => Q.

  otherVars:(list[term],map[string,term])=>list[term].
  otherVars(Q,Mx) => Q^/((varbl(Nm)):-\+present(Mx,Nm,_)).

  mkVars:(list[term]) => map[string,term].
  mkVars(Els) => foldLeft((M,varbl(Nm))=>M[Nm->varbl(_str_gen(Nm))],[],Els).

  renameTerm:(term,map[string,term]) => term.
  renameTerm(varbl(Nm),V) => VV :- present(V,Nm,VV).
  renameTerm(varbl(Nm),V) => varbl(Nm) :- \+ present(V,Nm,_).
  renameTerm(anon,_) => anon.
  renameTerm(T,_) => T :- isGroundTerm(T).
  renameTerm(cons(Op,Els),V) => cons(renameTerm(Op,V),renameEls(Els,V)).

  renameEls:(list[term],map[string,term])=> list[term].
  renameEls([],_) => [].
  renameEls([T,..L],V) => [renameTerm(T,V),..renameEls(L,V)].

  renamePred:(pred,map[string,term]) => pred.
  renamePred(call(TLc,O,A),V) => call(TLc,renameTerm(O,V),renameEls(A,V)).
  renamePred(ecall(TLc,O,A),V) => ecall(TLc,O,renameEls(A,V)).
  renamePred(ocall(TLc,O,A,T),V) => ocall(TLc,renameTerm(O,V),renameTerm(A,V),renameTerm(T,V)).
  renamePred(unfy(TLc,L,R),V) => unfy(TLc,renameTerm(L,V),renameTerm(R,V)).
  renamePred(except(TLc,A),V) => except(TLc,renameTerm(A,V)).
  renamePred(neck,_) => neck.
  renamePred(fail,_) => fail.

  renamePreds:(list[pred],map[string,term])=> list[pred].
  renamePreds([],_) => [].
  renamePreds([T,..L],V) => [renamePred(T,V),..renamePreds(L,V)].

  renameClse:(clse,clse,map[string,term]){}.
  renameClse(clse(Q,Nm,A,B),clse(renameEls(Q,V),Nm,renameEls(A,V),renamePreds(B,V)),V) :-
    V = mkVars(Q).
  renameClse(gclse(Q,Nm,A,G,B),gclse(renameEls(Q,V),Nm,renameEls(A,V),renamePreds(G,V),renamePreds(B,V)),V) :-
    V = mkVars(Q).

  unifyTerm:(term,term,map[string,term],map[string,term]){}.
  unifyTerm(T1,T2,M,Mx) :-
    unifyT(deRef(T1,M),deRef(T2,M),M,Mx).

  unifyT:(term,term,map[string,term],map[string,term]){}.
  unifyT(anon,_,M,M).
  unifyT(_,anon,M,M).
  unifyT(varbl(N1),T2,M,Mx) :- bind(N1,T2,M,Mx).
  unifyT(T1,varbl(N2),M,Mx) :- bind(N2,T1,M,Mx).
  unifyT(T,T,M,M) :- isGroundTerm(T).
  unifyT(cons(O1,E1),cons(O2,E2),M,Mx) :-
    unifyTerm(O1,O2,M,M1),
    unifyEls(E1,E2,M1,Mx).

  -- We write this recursion by hand to facilitate debugging
  unifyEls:(list[term],list[term],map[string,term],map[string,term]){}.
  unifyEls([],[],M,M).
  unifyEls([E1,..L1],[E2,..L2],M,Mx) :-
    unifyTerm(E1,E2,M,M1),
    unifyEls(L1,L2,M1,Mx).

  bind:(string,term,map[string,term],map[string,term]){}.
  bind(Nm,T,M,M[Nm->T]).

  deRef:(term,map[string,term]) => term.
  deRef(varbl(Nm),M) => deRef(V,M) :- present(M,Nm,V).
  deRef(T,_) => T.

  trace:all x ~~ display[x] |: (string,x)=>x.
  trace(M,X) => X :-
    logMsg(M+"\(X)").
}
