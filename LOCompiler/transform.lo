lo.comp.transform{
  import lo.
  import lo.comp.args.
  import lo.comp.canon.
  import lo.comp.debug.
  import lo.comp.errors.
  import lo.comp.escapes.
  import lo.comp.freevars.
  import lo.comp.location.
  import lo.comp.misc.
  import lo.comp.package.
  import lo.comp.term.
  import lo.comp.transutils.
  import lo.comp.types.

  /*
   * Implement a semantic reduction from L&O to Prolog-style rules
   */

  public transformProg:(canonPkg,compOption,prProg,report,report){}.
  transformProg(canonPkg(PkSpec,Imports,Defs,Others),Opt,prProg(PkSpec,Rules),Rp,Rpx) :-
    PkSpec = pkgSpec(pkg(Pkg,Vers),_,_,_,_,_,_),
    makePkgMap(Pkg,Defs,Imports) = (Enums,Map),
    POpts = trOpts(Opt,Pkg),
    transformModuleDefs(Defs,Map,POpts,[],R0,Rp,Rp0),
    transformOthers(Others,Map,POpts,Inits,R0,R1,Rp0,Rpx),
    thetaInit(Map,Inits,R1,Rules).

  transformModuleDefs:(list[canonDef],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformModuleDefs([],_,_,Rules,Rules,Rp,Rp).
  transformModuleDefs([Def,..Defs],Map,Opts,R0,Rx,Rp,Rpx) :-
    transformMdlDef(Def,Map,Opts,R0,R1,Rp,Rp0),
    transformModuleDefs(Defs,Map,Opts,R1,Rx,Rp0,Rpx).

  transformMdlDef:(canonDef,list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformMdlDef(funDef(Lc,Nm,Tp,Cx,Eqns),Map,Opts,R,Rx,Rp,Rpx) :-
    transformFunction(funDef(Lc,Nm,Tp,Cx,Eqns),Map,Opts,R,Rx,Rp,Rpx).
  transformMdlDef(grammDef(Lc,Nm,Tp,Cx,Rls),Map,Opts,R,Rx,Rp,Rpx) :-
    transformGrammar(grammDef(Lc,Nm,Tp,Cx,Rls),Map,Opts,R,Rx,Rp,Rpx).
  transformMdlDef(relDef(Lc,Nm,Tp,Cx,Clses),Map,Opts,R,Rx,Rp,Rpx) :-
    transformPredicate(relDef(Lc,Nm,Tp,Cx,Clses),Map,Opts,R,Rx,Rp,Rpx).
  transformMdlDef(varDef(Lc,Nm,_,_,Value,Cond),Map,Opts,R,Rx,Rp,Rpx) :-
    transformDefn(Map,Opts,Lc,Nm,Cond,Value,R,Rx,Rp,Rpx).
  transformMdlDef(classDef(Lc,Nm,Tp,_,Defs,Face),Map,Opts,R,Rx,Rp,Rpx) :-
    transformClass(Lc,Nm,Defs,Face,Map,Opts,R,Rx,Rp,Rpx).
  transformMdlDef(typeDef(_,_,_,_),_,_,Rules,Rules,Rp,Rp).
  transformMdlDef(cnDefn(_,_,_),_,_,Rules,Rules,Rp,Rp).
  transformMdlDef(implDef(Lc,_,ImplName,_,_,Hd,Body,Face),Map,Opts,R,Rx,Rp,Rpx) :-
    transformImplementation(Lc,ImplName,Hd,Body,Face,Map,Opts,R,Rx,Rp,Rpx).

  private extraArity:(integer,list[term],integer){}.
  extraArity(Arity,Vars,size(Vars)+Arity).

  transformFunction:(canonDef,list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformFunction(funDef(Lc,Nm,Tp,[],Eqns),Map,Opts,P,Px,Rp,Rpx) :-
    lookupFunName(Map,Nm,Reslt),
    programAccess(Reslt,LclFun,_,Closure,_),
    extraVars(Map,Extra),
    transformEquations(Map,Opts,LclFun,Ar,Extra,Eqns,1,Clses,P,P0,Rp,Rpx),
    AAr = Ar+size(Extra),
    LPrg = prg(LclFun,AAr),
    P1 = P0[LPrg->rel(LPrg,some(Lc::tloc),Clses)],
    closureEntry(Map,some(Lc::tloc),LclFun,Closure,Ar,P1,Px).

  transformEquations:(list[lyr],trOptions,string,integer,list[term],list[canonRule],integer,list[clse],map[term,rel],map[term,rel],report,report){}.
  transformEquations(_,_,_,_,_,[],_,[],Ex,Ex,Rp,Rp).
  transformEquations(Map,Opts,LclFun,Arity,Extra,[Eqn,..Defs],No,Rules,Ex,Exx,Rp,Rpx) :-
    transformEqn(Eqn,Map,Opts,LclFun,Arity,Extra,No,Rules,R0,Ex,Ex0,Rp,Rp0),
    transformEquations(Map,Opts,LclFun,_,Extra,Defs,No+1,R0,Ex0,Exx,Rp0,Rpx).

  transformEqn:(canonRule,list[lyr],trOptions,string,integer,list[term],integer,list[clse],list[clse],map[term,rel],map[term,rel],report,report){}.
  transformEqn(equation(Lc,Nm,tpl(A),Value,Cond),Map,Opts,LclFun,Arity,Extra,QNo,[clse(Q,prg(LclFun,Arity+size(Extra)),Args,Guard<>[neck,..Body]),..Rx],Rx,Ex,Exx,Rp,Rpx) :-
    debugPreamble(Nm,Extra,Q0,LbLx,FBg,Opts,ClOpts),        -- are we debugging?
    genVarbl("Reslt",Reslt),
    trPtns(A,Args,[Reslt,..Extra],Q0,Q1,PreG,PreGx,PostG,PreV,Map,ClOpts,Ex,Ex0,Rp,Rp0), -- head args
    trGoal(Cond,PreGx,[],merge([Reslt],Q1),Q2,Map,ClOpts,Ex0,Ex1,Rp0,Rp1),   -- condition goals
    trExp(Value,Rep,Q2,Q3,PreV,PVx,PVx,Px,Map,ClOpts,Ex1,Exx,Rp1,Rpx),  -- replacement expression
    labelAccess(Q3,Q,Map,Guard,LbLx),                        -- generate label access goals
    frameDebug(Nm,QNo,Q,FBg,LG,ClOpts),                     -- generate frame entry debugging
    lineDebug(Lc,LG,PreG,ClOpts),                           -- line debug after setting up frame
    deframeDebug(Nm,QNo,Px,[],ClOpts),                      -- generate frame exit debugging
    breakDebug(Nm,Body,PostG,ClOpts),                        -- generate break point debugging
    Arity = size(A)+1.

  transformPredicate:(canonDef,list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformPredicate(relDef(Lc,Nm,_,[],Rules),Map,Opts,P,Px,Rp,Rpx) :-
    lookupRelName(Map,Nm,Reslt),
    programAccess(Reslt,PrdNme,_,Closure,_),
    extraVars(Map,Extra),
    transformClauses(Map,Opts,PrdNme,Arity,Extra,Rules,1,Clses,P,P0,Rp,Rpx),
    Prg = prg(PrdNme,Arity),
    P1 = P0[Prg->rel(Prg,some(Lc::tloc),Clses)],
    closureEntry(Map,some(Lc::tloc),PrdNme,Closure,Arity,P1,Px).

  transformClauses:(list[lyr],trOptions,string,integer,list[term],list[canonRule],integer,list[clse],map[term,rel],map[term,rel],report,report){}.
  transformClauses(_,_,_,_,_,[],No,[],Ex,Ex,Rpx,Rpx).
  transformClauses(Map,Opts,PrdNme,Arity,Extra,[Cl,..Defs],No,Rules,Ex,Exx,Rp,Rpx) :-
    transformClause(Cl,Map,Opts,PrdNme,Arity,Extra,No,Rules,R0,Ex,Ex0,Rp,Rp0),
    transformClauses(Map,Opts,PrdNme,_,Extra,Defs,No+1,R0,Ex0,Exx,Rp0,Rpx).

  transformClause:(canonRule,list[lyr],trOptions,string,integer,list[term],integer,list[clse],list[clse],map[term,rel],map[term,rel],report,report){}.
  transformClause(clause(Lc,Nm,tpl(A),Body),Map,Opts,PrdNme,Arity,Extra,QNo,[clse(Q,prg(PrdNme,Arity),Args,Goals),..Rx],Rx,Ex,Exx,Rp,Rpx) :-
    debugPreamble(Nm,Extra,Q0,G0,G1,Opts,ClOpts),        -- are we debugging?
    trPtns(A,Args,Extra,Q0,Q1,G4,G5,G7,G8,Map,ClOpts,Ex,Ex0,Rp,Rp0), -- head args
    trGoal(Body,G5,G7,Q1,Q3,Map,ClOpts,Ex0,Exx,Rp0,Rpx),
    labelAccess(Q3,Q,Map,Goals,G0),                       -- generate label access goals
    frameDebug(Nm,QNo,Q,G1,G2,ClOpts),                    -- generate frame entry debugging
    lineDebug(Lc,G2,G3,ClOpts),                           -- line debug after setting up frame
    deframeDebug(Nm,QNo,G8,[],ClOpts),                    -- generate frame exit debugging
    breakDebug(Nm,G3,G4,ClOpts),                          -- generate break point debugging
    Arity = size(Args).

  transformDefn:(list[lyr],trOptions,location,string,canonCond,canonTerm,map[term,rel],map[term,rel],report,report){}.
  transformDefn(Map,Opts,Lc,Nm,Cond,lambda(equation(_,_,tpl(CVars),Value,_)),P,Px,Rp,Rpx) :-
    extraVars(Map,Extra),
    trPtns(CVars,Args,[Rep,..Extra],Extra,Q0,PreG,G0,G7,G8,Map,Opts,P,P0,Rp,Rp0), -- head args
    LclPrg = prg(LclName,length(Extra)+1),
    lookupVarName(Map,Nm,Reslt),
    programAccess(Reslt,LclName,_,_,_),                    -- extra variables coming from labels
    debugPreamble(Nm,Extra,Q0,G0,G1,Opts,ClOpts),          -- are we debugging?
    trGoal(Cond,G4,[],Q0,Q2,Map,ClOpts,P0,P1,Rp0,Rp1), -- condition goals
    trExp(Value,Rep,Q2,Q3,Body,G6,G6,G7,Map,ClOpts,P1,P2,Rp1,Rpx),         -- replacement expression
    labelAccess(Q3,Q,Map,Guard,PreG),                        -- generate label access goals
    frameDebug(Nm,0,Q,G1,G2,ClOpts),                      -- generate frame entry debugging
    lineDebug(Lc,G2,G3,ClOpts),                           -- line debug after setting up frame
    deframeDebug(Nm,0,G8,[],ClOpts),                      -- generate frame exit debugging
    breakDebug(Nm,G3,G4,ClOpts),                          -- generate break point debugging
    Px = P2[LclPrg->rel(LclPrg,some(Lc::tloc),[clse(Q,LclPrg,Args,Guard<>Body)])].
  transformDefn(Map,Opts,Lc,Nm,Cond,Value,P,Px,Rp,Rpx) :-
    extraVars(Map,Extra),
    LclPrg = prg(LclName,length(Extra)+1),
    lookupVarName(Map,Nm,Reslt),
    programAccess(Reslt,LclName,_,_,_),                    -- extra variables coming from labels
    debugPreamble(Nm,Extra,Q0,G0,G1,Opts,ClOpts),          -- are we debugging?
    trGoal(Cond,G4,[],Q0,Q2,Map,ClOpts,P,P0,Rp,Rp0), -- condition goals
    trExp(Value,Rep,Q2,Q3,Body,G6,G6,G7,Map,ClOpts,P0,P1,Rp0,Rpx),         -- replacement expression
    labelAccess(Q3,Q,Map,Guard,G0),                        -- generate label access goals
    frameDebug(Nm,0,Q,G1,G2,ClOpts),                      -- generate frame entry debugging
    lineDebug(Lc,G2,G3,ClOpts),                           -- line debug after setting up frame
    deframeDebug(Nm,0,G7,[],ClOpts),                      -- generate frame exit debugging
    breakDebug(Nm,G3,G4,ClOpts),                          -- generate break point debugging
    Px = P1[LclPrg->rel(LclPrg,some(Lc::tloc),[clse(Q,LclPrg,[Rep,..Extra],Guard<>Body)])].

  transformGrammar:(canonDef,list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformGrammar(grammDef(Lc,Nm,_,[],Rls),Map,Opts,P,Px,Rp,Rpx) :-
    lookupRelName(Map,Nm,Reslt),
    programAccess(Reslt,LclFun,_,Closure,_),
    extraVars(Map,Extra),
    transformGrammarRules(Map,Opts,LclFun,Arity,Extra,Rls,1,Clses,P,P0,Rp,Rpx),
    closureEntry(Map,some(Lc::tloc),LclFun,Closure,Arity,P0,P1),
    Px = P1[prg(LclFun,Arity)->rel(prg(LclFun,Arity),some(Lc::tloc),Clses)].

  transformGrammarRules:(list[lyr],trOptions,string,integer,list[term],list[canonRule],integer,list[clse],map[term,rel],map[term,rel],report,report){}.
  transformGrammarRules(_,_,_,_,_,[],No,[],Ex,Ex,Rp,Rp).
  transformGrammarRules(Map,Opts,LclFun,Arity,Extra,[Rl,..Defs],No,Rules,Ex,Exx,Rp,Rpx) :-
    transformGrammarRule(Rl,Map,Opts,LclFun,Arity,Extra,No,Rules,R0,Ex,Ex0,Rp,Rp0),
    transformGrammarRules(Map,Opts,LclFun,_,Extra,Defs,No+1,R0,Ex0,Exx,Rp0,Rpx).

  transformGrammarRule:(canonRule,list[lyr],trOptions,string,integer,list[term],integer,list[clse],list[clse],map[term,rel],map[term,rel],report,report){}.
  transformGrammarRule(grRule(Lc,Nm,tpl(A),grTerms(PB),Body),Map,Opts,LclFun,Arity,Extra,QNo,
        [clse(Q,prg(LclFun,Arity),[StIn,StX,..Args],Goals),..Rx],Rx,Ex,Exx,Rp,Rpx) :-
    debugPreamble(Nm,Extra,Q0,G0,G1,Opts,ClOpts),                     -- are we debugging?
    trPtns(A,Args,Extra,Q0,Q1,G4,G5,G6,G7,Map,ClOpts,Ex,Ex0,Rp,Rp0),  -- head args
    genVarbl("StIn",StIn),
    dcgBody(Body,Map,ClOpts,G5,G6,StIn,StOut,[StIn,..Q1],Q2,Ex0,Ex1,Rp0,Rp1), -- grammar body
    pushTerminals(PB,Map,ClOpts,G7,G8,StOut,StX,Q2,Q4,Ex1,Exx,Rp1,Rpx),     -- push back
    labelAccess(Q4,Q,Map,Goals,G0),                        -- generate label access goals
    frameDebug(Nm,QNo,Q,G1,G2,ClOpts),                     -- generate frame entry debugging
    lineDebug(Lc,G2,G3,ClOpts),                            -- line debug after setting up frame
    deframeDebug(Nm,QNo,G8,[],ClOpts),                     -- generate frame exit debugging
    breakDebug(Nm,G3,G4,ClOpts),                           -- generate break point debugging
    Arity = size(Args)+2.

  dcgBody:(canonNT,list[lyr],trOptions,list[pred],list[pred],term,term,list[term],list[term],map[term,rel],map[term,rel],report,report){}.
  dcgBody(grTerms(Terms),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    pushTerminals(Terms,Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx).
  dcgBody(grConj(Lhs,Rhs),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    dcgBody(Lhs,Map,Opts,G,G0,Strm,Strm0,Q,Q0,Ex,Ex0,Rp,Rp0),
    dcgBody(Rhs,Map,Opts,G0,Gx,Strm0,Strmx,Q0,Qx,Ex0,Exx,Rp0,Rpx).
  dcgBody(grDisj(Lhs,Rhs),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    dcgDisj(Lhs,Rhs,Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx).
  dcgBody(grCond(Tst,Lhs,Rhs),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    dcgConditional(Tst,Lhs,Rhs,Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx).
  dcgBody(grOne(Tst),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    dcgOne(Tst,Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx).
  dcgBody(grNeg(Tst),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    joinStream(Strm,Strmx,G,G0),
    dcgNeg(Tst,Map,Opts,G0,Gx,Strm,Q,Qx,Ex,Exx,Rp,Rpx).
  dcgBody(grAhed(Tst),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    joinStream(Strm,Strmx,G,G0),
    dcgAhead(Tst,Map,Opts,G0,Gx,Strm,Q,Qx,Ex,Exx,Rp,Rpx).
  dcgBody(grTest(Goal),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    joinStream(Strm,Strmx,G,G0),
    trGoal(Goal,G0,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx).
  dcgBody(grDip(V,Cond),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    joinStream(Strm,Strmx,G,G0),
    trExp(V,StrmVr,Q,Q0,G0,G1,G1,[unfy(none,Strm,StrmVr),..G2],Map,Opts,Ex,Ex0,Rp,Rp0),
    trGoal(Cond,G2,Gx,Q0,Qx,Map,Opts,Ex0,Exx,Rp0,Rpx).
  dcgBody(grCall(Lc,NT,tpl(Args)),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    lineDebug(Lc,G,G0,Opts),
    trExps(Args,AG,[],Q,Q0,G0,Pr,Pr,G3,Map,Opts,Ex,Ex0,Rp,Rpx),
    (var(Strmx) ? genVarbl("Stx",Strmx), Q1=[Strmx,..Q0] | Q0=Q1),
    trGoalCall(NT,[Strm,Strmx,..AG],G3,Gx,Q1,Qx,Map,Opts,Ex0,Exx,Rp,Rpx).

  dcgDisj:(canonNT,canonNT,list[lyr],trOptions,list[pred],list[pred],term,term,list[term],list[term],map[term,rel],map[term,rel],report,report){}.
  dcgDisj(Lhs,Rhs,Map,Opts,[call(none,DisProg,[Strm,Strmx,..DQ]),..G],G,Strm,Strmx,Q,merge(DQ,Q0),Ex,Exx,Rp,Rpx) :-
    (var(Strmx) ? genVarbl("DjOut",Strmx), Q0=[Strmx,..Q] | Q0=Q),
    genVarbl("DjStrm",DjStrm),
    dcgBody(Lhs,Map,Opts,LG,[],DjStrm,DjStrmx,[],LQ,Ex,Ex0,Rp,Rp0),
    dcgBody(Rhs,Map,Opts,RG,[],DjStrm,DjStrmy,LQ,DQ,Ex0,Ex1,Rp0,Rpx),
    genNewName(Map,"Disj",length(DQ)+2,DisProg),
    C1 = clse([DjStrm,..DQ],DisProg,[DjStrm,DjStrmx,..DQ],LG),
    C2 = clse([DjStrm,..DQ],DisProg,[DjStrm,DjStrmy,..DQ],RG),
    Exx = Ex1[DisProg->rel(DisProg,none,[C1,C2])].

  dcgOne:(canonNT,list[lyr],trOptions,list[pred],list[pred],term,term,list[term],list[term],map[term,rel],map[term,rel],report,report){}.
  dcgOne(Lhs,Map,Opts,[call(none,OneProg,[Strm,Strmx,..DQ]),..G],G,Strm,Strmx,Q,merge(DQ,Q),P,Px,Rp,Rpx) :-
    genVarbl("OneStm",OneStm),
    (var(Strmx) ? genVarbl("DjOut",Strmx) | true),
    dcgBody(Lhs,Map,Opts,LG,[neck],OneStm,OneStmx,[],DQ,P,P0,Rp,Rpx),
    genNewName(Map,"One",length(DQ)+2,OneProg),
    C1 = clse([OneStm,..DQ],OneProg,[OneStm,OneStmx,..DQ],LG),
    Px = P0[OneProg->rel(OneProg,none,[C1])].

  dcgNeg:(canonNT,list[lyr],trOptions,list[pred],list[pred],term,list[term],list[term],map[term,rel],map[term,rel],report,report){}.
  dcgNeg(Tst,Map,Opts,[call(none,NegProg,[Strm,..TQ]),..G],G,Strm,Q,merge(TQ,Q),P,Px,Rp,Rpx) :-
    genVarbl("NegStrm",NegStrm),
    dcgBody(Tst,Map,Opts,TG,[],NegStrm,_,[],TQ,P,P0,Rp,Rpx),
    genNewName(Map,"Neg",length(TQ)+1,NegProg),
    C1 = clse([NegStrm,..TQ],NegProg,[NegStrm,..TQ],TG<>[neck,fail]),
    C2 = clse([NegStrm,..TQ],NegProg,[NegStrm,..TQ],[]),
    Px = P0[NegProg->rel(NegProg,none,[C1,C2])].

  dcgConditional:(canonNT,canonNT,canonNT,list[lyr],trOptions,list[pred],list[pred],term,term,list[term],list[term],map[term,rel],map[term,rel],report,report){}.
  dcgConditional(Tst,Lhs,Rhs,Map,Opts,[call(none,CondProg,[Strm,Strmx,..DQ]),..G],G,Strm,Strmx,Q,merge(DQ,Q),P,Px,Rp,Rpx) :-
    (var(Strmx) ? genVarbl("CndOut",Strmx) | true),
    genVarbl("CondStrm",CndStrm),
    dcgBody(Tst,Map,Opts,TG,[],CndStrm,CndStrm0,[],TQ,P,P0,Rp,Rp0),
    dcgBody(Lhs,Map,Opts,LG,[],CndStrm0,CndStrmx,TQ,LQ,P0,P1,Rp0,Rp1),
    dcgBody(Rhs,Map,Opts,RG,[],CndStrm,CndStrmy,LQ,DQ,P1,P2,Rp1,Rpx),
    genNewName(Map,"Cond",length(DQ)+2,CondProg),
    C1 = clse([CndStrm,..DQ],CondProg,[CndStrm,CndStrmx,..DQ],TG<>[neck,..LG]),
    C2 = clse([CndStrm,..DQ],CondProg,[CndStrm,CndStrmy,..DQ],RG),
    Px = P2[CondProg->rel(CondProg,none,[C1,C2])].

  dcgAhead:(canonNT,list[lyr],trOptions,list[pred],list[pred],term,list[term],list[term],map[term,rel],map[term,rel],report,report){}.
  dcgAhead(Tst,Map,Opts,[call(none,HdProg,[Strm,..TQ]),..G],G,Strm,Q,merge(TQ,Q),P,Px,Rp,Rpx) :-
    genVarbl("HedStrm",HedStrm),
    dcgBody(Tst,Map,Opts,TG,[],HedStrm,_,[],TQ,P,P0,Rp,Rpx),
    genNewName(Map,"Hed",length(TQ)+1,HdProg),
    C1 = clse([HedStrm,..TQ],HdProg,[HedStrm,..TQ],TG),
    Px = P0[HdProg->rel(HdProg,none,[C1])].

  pushTerminals:(list[(location,canonTerm,canonTerm)],list[lyr],trOptions,list[pred],list[pred],term,term,list[term],list[term],map[term,rel],map[term,rel],report,report){}.
  pushTerminals([],_,_,G,Gx,Strm,Strmx,Q,Q,Ex,Ex,Rp,Rp) :-
    joinStream(Strm,Strmx,G,Gx).
  pushTerminals([(Lc,SV,T),..More],Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    genVarbl("NStrm",NStrm),
    trGoal(callCond(Lc,SV,tpl([mkCanon(Strm),T,mkCanon(NStrm)])),G,G0,Q,Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    pushTerminals(More,Map,Opts,G0,Gx,NStrm,Strmx,[NStrm,..Q0],Qx,Ex0,Exx,Rp0,Rpx).

  mkCanon:(term)=>canonTerm.
  mkCanon(varbl(Nm))=>v(std,Nm).

  joinStream:(term,term,list[pred],list[pred]){}.
  joinStream(X,X,G,G).
  joinStream(Strm,Strmx,[unfy(none,Strm,Strmx),..Gx],Gx).

  transformOthers:(list[canonOther],list[lyr],trOptions,list[pred],map[term,rel],map[term,rel],report,report){}.
  transformOthers([],_,_,[],Rx,Rx,Rp,Rp).
  transformOthers([integrity(Lc,G),..Others],Map,Opts,[call(some(Lc::tloc),AssertName,[]),..Inits],P,Px,Rp,Rpx) :-
    collect(Others,isAssertion,Asserts,Rest),
    transformAssertions([integrity(Lc,G),..Asserts],Map,Opts,Lc,AssertName,P,P0,Rp,Rp0),
    transformOthers(Rest,Map,Opts,Inits,P0,Px,Rp0,Rpx).
  transformOthers([expShow(Lc,E),..Others],Map,Opts,[call(some(Lc::tloc),ShowName,[]),..Inits],P,Px,Rp,Rpx) :-
    collect(Others,isShow,Shows,Rest),
    transformShows([expShow(Lc,E),..Shows],Map,Opts,Lc,ShowName,P,P0,Rp,Rp0),
    transformOthers(Rest,Map,Opts,Inits,P0,Px,Rp0,Rpx).

  private isAssertion:(canonOther){}.
  isAssertion(integrity(_,_)).

  private isShow:(canonOther){}.
  isShow(expShow(_,_)).

  transformAssertions:(list[canonOther],list[lyr],trOptions,location,term,map[term,rel],map[term,rel],report,report){}.
  transformAssertions(Asserts,Map,Opts,Lc,prg(AssertNm,Arity),P,Px,Rp,Rpx) :-
    extraVars(Map,Extra),
    AssertNm = localName(layerName(Map),"@","assert"),
    transformClause(clause(Lc,"assert",tpl([]),foldRight(collectGoal,trueCond,Asserts)),Map,Opts,AssertNm,Arity,Extra,1,[ACl],[],P,P0,Rp,Rpx),
    Px = addCl(P0,ACl).

  collectGoal:(canonCond,canonOther)=>canonCond.
  collectGoal(trueCond,integrity(_,G)) => G.
  collectGoal(O,integrity(_,G)) => conjCond(G,O).

  transformShows:(list[canonOther],list[lyr],trOptions,location,term,map[term,rel],map[term,rel],report,report){}.
  transformShows(Shows,Map,Opts,Lc,prg(ShowNm,Arity),P,Px,Rp,Rpx) :-
    extraVars(Map,Extra),
    ShowNm = localName(layerName(Map),"@","show"),
    transformClause(clause(Lc,"show",tpl([]),(foldRight(collectShow,trueCond,Shows):canonCond)),Map,Opts,ShowNm,Arity,Extra,1,[SCl],[],P,P0,Rp,Rpx),
    Px = addCl(P0,SCl).

  collectShow:(canonCond,canonOther)=>canonCond.
  collectShow(trueCond,expShow(Lc,S)) => callCond(Lc,v(Lc,"_logmsg"),tpl([S])).
  collectShow(O,expShow(Lc,S)) => conjCond(callCond(Lc,v(Lc,"_logmsg"),tpl([S])),O).

  trLocation:(location) => canonTerm.
  trLocation(Lc) => tpl([int(lineOf(Lc)),int(columnOf(Lc)),int(widthOf(Lc))]).

  thetaInit:(list[lyr],list[pred],map[term,rel],map[term,rel]){}.
  thetaInit(Map,Inits,P,Px) :-
    Px = addCl(P,clse([],prg(localName(layerName(Map),"@","init"),0),[],Inits<>[neck])).

  transformClass:(location,string,list[canonRule],tipe,list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformClass(Lc,Nm,Defs,Face,Map,Opts,P,Px,Rp,Rpx) :-
    P0 = addCl(P,labelDefn(Map,Nm,LclName)),
    genClassMap(Map,Opts,Lc,LclName,Defs,Face,CMap,P0,P1,Rp,Rp0)!,
    transformClassBody(Defs,CMap,Opts,P1,Px,Rp0,Rpx).

  enumAccess:(list[lyr],string,list[clse],list[clse]){}.
  enumAccess(Map,Name,[clse(Extra,prg(AccessName,length(Extra)+1),[LamCons,..Extra],[]),..Rx],Rx) :-
    lookupVarName(Map,Name,Reslt),
    programAccess(Reslt,LclName,AccessName,_,0),
    extraVars(Map,Extra),
    (Extra=[] ? LamCons=enum(LclName) | LamCons=cons(strct(LclName,size(Extra)),Extra)).
  enumAccess(_,_,Rls,Rls).

  labelDefn:(list[lyr],string,string) => clse.
  labelDefn(Map,Nm,LclName) => clse(Extra,prg(Access,size(Extra)+1),[cons(trCons(Nm,1),[LblTerm]),..Extra],[]) :-
    lookupVarName(Map,Nm,Spec),
    extraVars(Map,Extra),                                   -- extra variables coming from labels
    extraArity(1,Extra,ArA),
    makeLabelTerm(Spec,Access,LblTerm,LclName).

  makeLabelTerm:(mapEntry,string,term,string){}.
  makeLabelTerm(localClass(LclName,Strct,_,LblVr,ThVr),LclName,cons(strct(Strct,2),[LblVr,ThVr]),LclName).
  makeLabelTerm(moduleClass(Access,Strct,0),Access,enum(Strct),Access).
  makeLabelTerm(moduleClass(Access,Strct,Ar),Access,cons(strct(Strct,0),[]),Access).
  makeLabelTerm(moduleImpl(Access,Strct),Access,Strct,Access).

  /* A class body of the form
  lbl(A1,..,Ak) <= {
    prog1 :- ...
  }
  is mapped to

  pkg#lbl(prog1(X1,..,Xm),Lb,Th) :- pkg#lbl@prog(X1,..,Xm,Lb,Th)

  together with the specific translations of prog1
  */
  transformClassBody:(list[canonRule],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformClassBody(Defs,Map,Opts,P,Px,Rp,Rpx) :-
    findClassBody(Defs,Stmts)!,
    transformClassDefs(Stmts,Map,Opts,P,Px,Rp,Rpx).
  transformClassBody(_,_,_,P,P,Rp,Rp).

  findClassBody:(list[canonRule],list[canonDef]){}.
  findClassBody(Defs,Stmts) :-
    clRule(_,_,_,theta(Stmts,_),_,_) in Defs.

  transformClassDefs:(list[canonDef],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformClassDefs([],_,_,Px,Px,Rp,Rp).
  transformClassDefs([Def,..Defs],Map,Opts,P,Px,Rp,Rpx) :-
    transformClassDef(Def,Map,Opts,P,P0,Rp,Rp0),
    transformClassDefs(Defs,Map,Opts,P0,Px,Rp0,Rpx).

  transformClassDef:(canonDef,list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformClassDef(funDef(Lc,Nm,Tp,Cx,Eqns),Map,Opts,P,Px,Rp,Rpx) :-
    transformFunction(funDef(Lc,Nm,Tp,Cx,Eqns),Map,Opts,P,P0,Rp,Rpx),
    entryClause(Map,Nm,some(Lc::tloc),P0,P1),
    closureAccess(Map,Nm,P1,Px).
  transformClassDef(relDef(Lc,Nm,Tp,Cx,Clses),Map,Opts,P,Px,Rp,Rpx) :-
    transformPredicate(relDef(Lc,Nm,Tp,Cx,Clses),Map,Opts,P,P0,Rp,Rpx),
    entryClause(Map,Nm,some(Lc::tloc),P0,P1),
    closureAccess(Map,Nm,P1,Px).
  transformClassDef(grammDef(Lc,Nm,Tp,Cx,Clses),Map,Opts,P,Px,Rp,Rpx) :-
    transformGrammar(grammDef(Lc,Nm,Tp,Cx,Clses),Map,Opts,P,P0,Rp,Rpx),
    entryClause(Map,Nm,some(Lc::tloc),P0,P1),
    closureAccess(Map,Nm,P1,Px).
  transformClassDef(varDef(Lc,Nm,_,_,Value,Cond),Map,Opts,P,Px,Rp,Rpx) :-
    transformDefn(Map,Opts,Lc,Nm,Cond,Value,P,P0,Rp,Rpx),
    entryClause(Map,Nm,some(Lc::tloc),P0,Px).
  transformClassDef(classDef(Lc,Nm,Tp,Cx,Defs,Face),Map,Opts,P1,Px,Rp,Rpx) :-
    transformClass(Lc,Nm,Defs,Face,Map,Opts,P,P0,Rp,Rpx),
    entryClause(Map,Nm,some(Lc::tloc),P0,Px).

  entryClause:(list[lyr],string,option[tloc],map[term,rel],map[term,rel]){}.
  entryClause(Map,Name,TLc,P,Px) :-
    lookupVarName(Map,Name,Reslt),
    programAccess(Reslt,Prog,_,_,Arity),
    Args = genVars(Arity),
    genVarbl("This",ThVr),
    genVarbl("Lbl",LblVr),
    Q = Args<>[LblVr,ThVr],
    Px = addCl(P,clse(Q,prg(layerName(Map),3),
          [cons(trCons(Name,Arity),Args),LblVr,ThVr],[call(TLc,prg(Prog,Arity+2),Q)])).

  closureAccess:(list[lyr],string,map[term,rel],map[term,rel]){}.
  closureAccess(Map,Name,P,Px) :-
    lookupVarName(Map,Name,Reslt),
    programAccess(Reslt,_,_,Closure,_),
    genVarbl("This",ThVr),
    genVarbl("Lbl",LblVr),
    LamCons = cons(trCons(Name,1),[cons(strct(Closure,2),[LblVr,ThVr])]),
    Px = addCl(P,clse([LblVr,ThVr],prg(layerName(Map),3),[LamCons,LblVr,ThVr],[])).

  closureEntry:(list[lyr],option[tloc],string,string,integer,map[term,rel],map[term,rel]){}.
  closureEntry(Map,TLc,Prog,Closure,Arity,P,Px) :-
    extraVars(Map,Extra),
    Args = genVars(Arity),
    Q = Args<>Extra,
    CallStrct = cons(trCons("_call",Arity),Args),
    (Extra=[] ? ClosureCons = enum(Closure) | ClosureCons = cons(strct(Closure,size(Extra)),Extra)),
    Px = addCl(P,clse(Q,prg(Closure,3),[CallStrct,ClosureCons,anon],[call(TLc,prg(Prog,length(Q)),Q)])).

  transformImplementation:(location,string,canonTerm,canonTerm,tipe,list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformImplementation(Lc,ImplName,tpl([]),Body,Face,Map,Opts,P,Px,Rp,Rpx) :-
    transformClass(Lc,ImplName,[clRule(Lc,ImplName,v(Lc,ImplName),Body,trueCond,Face)],Face,Map,Opts,P,Px,Rp,Rpx).
  transformImplementation(Lc,ImplName,Hd,Body,Face,Map,Opts,P,Px,Rp,Rpx) :-
    transformClass(Lc,ImplName,[clRule(Lc,ImplName,apply(Lc,v(Lc,ImplName),Hd),Body,trueCond,Face)],Face,Map,Opts,P,Px,Rp,Rpx).

  trPtns:(list[canonTerm],list[term],list[term],list[term],list[term],list[pred],list[pred],list[pred],list[pred],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trPtns([],Args,Args,Q,Q,Pre,Pre,Post,Post,_,_,Ex,Ex,Rp,Rp).
  trPtns([P,..More],[A,..Args],Ax,Q,Qx,Pre,Prx,Post,Psx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trPtn(P,A,Q,Q0,Pre,Pre0,Post,Pst0,Map,Opts,Ex,Ex0,Rp,Rp0)!,
    trPtns(More,Args,Ax,Q0,Qx,Pre0,Prx,Pst0,Psx,Map,Opts,Ex0,Exx,Rp0,Rpx).

  trPtn:(canonTerm,term,list[term],list[term],list[pred],list[pred],list[pred],list[pred],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trPtn(v(_,"this"),ThVr,Q,merge([ThVr],Q),Pre,Pre,Post,Post,Map,_,Ex,Ex,Rp,Rp) :-
    thisVar(Map,ThVr).
  trPtn(v(Lc,"this"),anon,Q,Q,Pre,Pre,Post,Post,_,_,Ex,Ex,Rp,Rpx) :-
    reportError("'this' not defined here",Lc,Rp,Rpx).
  trPtn(v(Lc,Nm),A,Q,Qx,Pre,Prx,Post,Pstx,Map,Opts,Ex,Ex,Rp,Rpx) :-
    trVarPtn(Lc,Nm,A,Q,Qx,Pre,Prx,Post,Pstx,Map,Opts,Rp,Rpx).
  trPtn(int(Ix),intgr(Ix),Q,Q,Pre,Pre,Post,Post,_,_,Ex,Ex,Rp,Rp).
  trPtn(flt(Ix),flot(Ix),Q,Q,Pre,Pre,Post,Post,_,_,Ex,Ex,Rp,Rp).
  trPtn(str(Ix),strng(Ix),Q,Q,Pre,Pre,Post,Post,_,_,Ex,Ex,Rp,Rp).
  trPtn(dot(Lc,Rc,Fld),Exp,Q,Qx,Pre,Px,Post,Post,Map,Opts,Ex,Exx,Rp,Rpx) :-
    genVarbl("XV",X),
    trDotExp(Lc,Rc,cons(trCons(Fld,1),[X]),X,Exp,Q,Qx,Pre,Pi,Pi,Px,Map,Opts,Ex,Exx,Rp,Rpx).
  trPtn(tpl(Ptns),mkTpl(P),Q,Qx,Pre,Px,Post,Postx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trPtns(Ptns,P,[],Q,Qx,Pre,Px,Post,Postx,Map,Opts,Ex,Exx,Rp,Rpx).
  trPtn(apply(Lc,v(_,Nm),tpl(A)),Ptn,Q,Qx,Pre,Px,Post,Pstx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trPtns(A,Args,[],Q,Q0,APre,AP0,APost,APs0,Map,Opts,Ex,Ex0,Rp,Rp0),
    trPtnCallOp(Nm,some(Lc::tloc),Args,Ptn,Q0,Qx,APre,AP0,APost,APs0,Pre,Px,Post,Pstx,Map,Opts,Ex0,Exx,Rp0,Rpx).
  trPtn(whre(P,C),Ptn,Q,Qx,Pre,Px,Post,Pstx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trPtn(P,Ptn,Q,Q0,Pre,P0,Post,Pstx,Map,Opts,Ex,Ex0,Rp,Rp0),
    trGoal(C,P0,Px,Q0,Qx,Map,Opts,Ex0,Exx,Rp0,Rpx).
  trPtn(XX,Exp,Q,Qx,Pre,Pre,Post,Postx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(XX,Exp,Q,Qx,Post,Pi,Pi,Postx,Map,Opts,Ex,Exx,Rp,Rpx).

  trVarPtn:(location,string,term,list[term],list[term],list[pred],list[pred],list[pred],list[pred],list[lyr],trOptions,report,report){}.
  trVarPtn(_,"_",anon,Q,Q,Pre,Pre,Post,Post,_,_,Rp,Rp).
  trVarPtn(Lc,Nm,A,Q,Qx,Pre,Prx,Post,Pstx,Map,_,Rp,Rpx) :-
    lookupVarName(Map,Nm,V),
    implementVarPtn(V,Nm,some(Lc::tloc),A,Q,Qx,Pre,Prx,Post,Pstx,Rp,Rpx).
  trVarPtn(Lc,Nm,anon,Q,Q,Pre,Pre,Post,Post,_,_,Rp,Rpx) :-
    reportError("'\(Nm)' not defined",Lc,Rp,Rpx).

  implementVarPtn:(mapEntry,string,option[tloc],term,list[term],list[term],list[pred],list[pred],list[pred],list[pred],report,report){}.
  implementVarPtn(localVar(Vn,_,ClVr,TVr),Nm,TLc,X,Q,merge([X,ClVr,TVr],Q),[call(TLc,prg(Vn,3),[X,ClVr,TVr]),..Pre],Pre,Post,Post,Rp,Rp) :- genVarbl(Nm,X).  -- instance var
  implementVarPtn(moduleVar(_,Vn,_),Nm,TLc,X,Q,[X,..Q],[call(TLc,prg(Vn,1),[X]),..Pre],Pre,Post,Post,Rp,Rp) :- genVarbl(Nm,X). -- module variable
  implementVarPtn(labelArg(N,ClVr,TVr),_,_,N,Q,merge([N,ClVr,TVr],Q),Pre,Pre,Post,Post,Rp,Rp).            -- argument from label
  implementVarPtn(moduleClass(Enum,_,0),_,_,enum(Enum),Q,Q,Pre,Pre,Post,Post,Rp,Rp).
  implementVarPtn(localClass(Enum,_,0,LbVr,ThVr),_,_,cons(strct(Enum,2),[LbVr,ThVr]),Q,merge([LbVr,ThVr],Q),Pre,Pre,Post,Post,Rp,Rp).
  implementVarPtn(inherit(Nm,_,LbVr,ThVr),_,_,cons(strct(Nm,2),[LbVr,ThVr]),Q,merge([LbVr,ThVr],Q),Pre,Pre,Post,Post,Rp,Rp).
  implementVarPtn(inheritField(Super,LblVr,ThVr),Nm,Lc,X,Q,merge([X,LblVr,ThVr],Q),
        [call(Lc,Super,[cons(trCons(Nm,1),[X]),LblVr,ThVr]),..Pre],Pre,Tail,Tail,Rp,Rp) :- genVarbl(Nm,X).
  implementVarPtn(notInMap,Nm,_,varbl(Nm),Q,merge([varbl(Nm)],Q),Pre,Pre,Post,Post,Rp,Rp).                -- variable local to clause

  trPtnCallOp:(string,option[tloc],list[term],term,list[term],list[term],list[pred],list[pred],list[pred],list[pred],list[pred],list[pred],list[pred],list[pred],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trPtnCallOp(Nm,TLc,Args,X,Q,merge([X],Q),Pre,Px,Tail,[ecall(TLc,Nm,Args<>[X]),..Tailx],Pre,Px,Tail,Tailx,_,_,Ex,Ex,Rp,Rp) :-
    isEscape(Nm),
    genVarbl("Xa",X).
  trPtnCallOp(Nm,TLc,Args,Ptn,Q,Qx,APre,APx,APost,APstx,Pre,Px,Tail,Tailx,Map,_,Ex,Ex,Rp,Rpx) :-
    lookupFunName(Map,Nm,Reslt),
    genVarbl("Xb",X),
    implementPtnCall(Reslt,Nm,TLc,X,Args,Ptn,Q,Qx,APre,APx,APost,APstx,Pre,Px,Tail,Tailx,Rp,Rpx).

  implementPtnCall:(mapEntry,string,option[tloc],term,list[term],term,list[term],list[term],list[pred],list[pred],list[pred],list[pred],list[pred],list[pred],list[pred],list[pred],report,report){}.
  implementPtnCall(localFun(Fn,_,_,Ar,LblVr,ThVr),_,TLc,X,Args,X,Q,merge([X,LblVr,ThVr],Q),Pre,Px,Tail,[call(TLc,prg(Fn,size(Args)+3),Args<>[X,LblVr,ThVr]),..Tailx],Pre,Px,Tail,Tailx,Rp,Rp).
  implementPtnCall(moduleFun(_,Fn,_,_,Ar),_,TLc,X,Args,X,Q,merge([X],Q),Pre,Px,Tail,[call(TLc,prg(Fn,size(Args)+1),Args<>[X]),..Tailx],Pre,Px,Tail,Tailx,Rp,Rp).
  implementPtnCall(inheritField(Super,LblVr,ThVr),Nm,TLc,X,Args,X,Q,merge([X,LblVr,ThVr],Q),Pre,Px,Tail,
        [call(TLc,Super,[cons(trCons(Nm,length(Args)+1),Args<>[X]),LblVr,ThVr]),..Tailx],Pre,Px,Tail,Tailx,Rp,Rp).
  implementPtnCall(moduleClass(Mdl,_,_),_,_,_,Args,cons(strct(Mdl,size(Args)),Args),Q,Q,Pre,Px,Tail,Tailx,Pre,Px,Tail,Tailx,Rp,Rp).
  implementPtnCall(localClass(Acc,_,_,LbVr,ThVr),_,_,_,Args,
        cons(strct(Acc,size(Args)+2),Args<>[LbVr,ThVr]),Q,merge([LbVr,ThVr],Q),Pre,Px,Tail,Tailx,Pre,Px,Tail,Tailx,Rp,Rp).
  implementPtnCall(inherit(Nm,_,LbVr,ThVr),_,_,_,Args,
        cons(strct(Nm,size(Args)),Args),Q,merge([LbVr,ThVr],Q),Pre,Px,Tail,Tailx,Pre,Px,Tail,Tailx,Rp,Rp).
  implementPtnCall(moduleImpl(_,Mdl),_,_,_,Args,cons(Mdl,Args),Q,Q,Pre,Px,Tail,Tailx,Pre,Px,Tail,Tailx,Rp,Rp).

  implementPkgRefPtn:(mapEntry,location,string,string,term,term,list[term],list[term],list[pred],list[pred],report,report){}.
  implementPkgRefPtn(moduleVar(_,Vn,_),Lc,_,_,Xi,Xi,Q,[Xi,..Q],[call(some(Lc::tloc),prg(Vn,1),[Xi]),..Tail],Tail,Rp,Rp).
  implementPkgRefPtn(moduleClass(Enum,_,0),_,_,_,_,enum(Enum),Q,Q,Tail,Tail,Rp,Rp).
  implementPkgRefPtn(_,Lc,Pkg,Rf,_,anon,Q,Q,Post,Post,Rp,Rpx) :-
    reportError("illegal access to \(Pkg)#\(Rf)",Lc,Rp,Rpx).

  trExps:(list[canonTerm],list[term],list[term],list[term],list[term],list[pred],list[pred],list[pred],list[pred],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trExps([],Args,Args,Q,Q,Pre,Pre,Post,Post,_,_,Ex,Ex,Rp,Rp).
  trExps([P,..More],[A,..Args],Extra,Q,Qx,Pre,Prx,Post,Psx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(P,A,Q,Q0,Pre,Pre0,Post,Pst0,Map,Opts,Ex,Ex0,Rp,Rp0)!,
    trExps(More,Args,Extra,Q0,Qx,Pre0,Prx,Pst0,Psx,Map,Opts,Ex0,Exx,Rp0,Rpx).

  trExp:(canonTerm,term,list[term],list[term],list[pred],list[pred],list[pred],list[pred],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trExp(v(_,"this"),ThVr,Q,merge([ThVr],Q),Pre,Pre,Post,Post,Map,_,Ex,Ex,Rp,Rp) :-
    thisVar(Map,ThVr).
  trExp(v(Lc,Nm),Vr,Q,Qx,Pre,Px,Post,Pstx,Map,Opts,Ex,Ex,Rp,Rpx) :-
    trVarExp(Lc,Nm,Vr,Q,Qx,Pre,Px,Post,Pstx,Map,Opts,Rp,Rpx).
  trExp(int(Ix),intgr(Ix),Q,Q,Pre,Pre,Post,Post,_,_,Ex,Ex,Rp,Rp).
  trExp(flt(Ix),flot(Ix),Q,Q,Pre,Pre,Post,Post,_,_,Ex,Ex,Rp,Rp).
  trExp(str(Ix),strng(Ix),Q,Q,Pre,Pre,Post,Post,_,_,Ex,Ex,Rp,Rp).
  trExp(tpl(A),mkTpl(TA),Q,Qx,Pre,Px,Post,Pstx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExps(A,TA,[],Q,Qx,Pre,Px,Post,Pstx,Map,Opts,Ex,Exx,Rp,Rpx).
  trExp(apply(Lc,Op,tpl(A)),Exp,Q,Qx,Pre,Px,Post,Pstx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExps(A,Args,[],Q,Q0,APre,APx,APost,APostx,Map,Opts,Ex,Ex0,Rp,Rp0),
    trExpCallOp(Lc,Op,Args,Exp,Q0,Qx,APre,APx,APost,APostx,Pre,Px,Post,Pstx,Map,Opts,Ex0,Exx,Rp0,Rpx).
  trExp(dot(Lc,Rec,Fld),Exp,Q,merge([X],Qx),Pre,Px,Tail,Tailx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    genVarbl("XV",X),
    trDotExp(Lc,Rec,cons(trCons(Fld,1),[X]),X,Exp,Q,Qx,Pre,Px,Tail,Tailx,Map,Opts,Ex,Exx,Rp,Rpx).
  trExp(whre(P,C),Ptn,Q,Qx,Pre,Px,Post,Pstx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(P,Ptn,Q,Q0,Pre,P0,Post,Pstx,Map,Opts,Ex,Ex0,Rp,Rp0),
    trGoal(C,P0,Px,Q0,Qx,Map,Opts,Ex0,Exx,Rp0,Rpx).
  trExp(condExp(T,L,R),Rslt,Q,merge([Rslt,..LQ],Q),Pre,Prx,Post,Post,Map,Opts,Ex,Exx,Rp,Rpx) :-
    genVarbl("CndV",Rslt),
    lineDebug(Lc,Pre,[call(none,CondPr,[Rslt,..LQ]),..Prx],Opts),
    trGoal(T,TG,[],[],Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    trExp(L,LRslt,Q0,Q1,LG,Lx,Lx,[],Map,Opts,Ex0,Ex1,Rp0,Rp1),
    trExp(R,RRslt,Q1,LQ,RG,Rx,Rx,[],Map,Opts,Ex1,Ex2,Rp1,Rpx),
    genNewName(Map,"condExp",length(LQ)+1,CondPr),
    Cl1 = clse(LQ,CondPr,[LRslt,..LQ],TG<>[neck,..LG]),
    Cl2 = clse(LQ,CondPr,[RRslt,..LQ],RG),
    Exx = Ex2[CondPr->rel(CondPr,none,[Cl1,Cl2])].
  trExp(lambda(Rl),Rslt,Q,Q,Pr,Pr,Post,Post,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trLambda(Rl,Rslt,merge(allLabelArgs(Map,[]),Q),Map,Opts,Ex,Exx,Rp,Rpx).
  trExp(XX,anon,Q,Q,Pre,Pre,Post,Post,_,_,Ex,Ex,Rp,Rpx) :-
    reportError("internal: cannot transform \(XX) as expression",std,Rp,Rpx).

  trDotExp:(location,canonTerm,term,term,term,list[term],list[term],list[pred],list[pred],list[pred],list[pred],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trDotExp(Lc,v(_,Nm),C,X,Exp,Q,Qx,Pre,Px,Tail,Tailx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    lookupVarName(Map,Nm,Reslt),
    implementDotExp(Reslt,v(Lc,Nm),some(Lc::tloc),C,X,Exp,Q,Qx,Pre,Px,Tail,Tailx,Map,Opts,Ex,Exx,Rp,Rpx).
  trDotExp(Lc,R,C,X,X,Q,merge([X],Q0),Pre,Px,Tail,Tailx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(R,Rc,Q,Q0,Pre,Px,Tail,[ocall(some(Lc::tloc),C,Rc,Rc),..Tailx],Map,Opts,Ex,Exx,Rp,Rpx).

  implementDotExp:(mapEntry,canonTerm,option[tloc],term,term,term,list[term],list[term],list[pred],list[pred],list[pred],list[pred],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  implementDotExp(inherit(_,Super,ClVr,ThVr),_,TLc,C,X,X,Q,merge([X,ClVr,ThVr],Q),Pre,Pre,[call(TLc,Super,[C,ClVr,ThVr]),..Tail],Tail,_,_,Ex,Ex,Rp,Rp).
  implementDotExp(_,R,TLc,C,X,X,Q,merge([X],Q0),Pre,Px,Tail,Tailx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(R,Rc,Q,Q0,Pre,Px,Tail,[ocall(TLc,C,Rc,Rc),..Tailx],Map,Opts,Ex,Exx,Rp,Rpx).

  trVarExp:(location,string,term,list[term],list[term],list[pred],list[pred],list[pred],list[pred],list[lyr],trOptions,report,report){}.
  trVarExp(_,"_",anon,Q,Q,Pre,Pre,Post,Post,_,_,Rp,Rp).
  trVarExp(Lc,Nm,Exp,Q,Qx,Pre,Prx,Post,Pstx,Map,_,Rp,Rpx) :-
    lookupVarName(Map,Nm,V),
    implementVarExp(V,Lc,Nm,Exp,Q,Qx,Pre,Prx,Post,Pstx,Rp,Rpx).
  trVarExp(Lc,Nm,anon,Q,Q,Pre,Pre,Post,Post,_,_,Rp,Rpx) :-
    reportError("'\(Nm)' not defined",Lc,Rp,Rpx).

  implementVarExp:(mapEntry,location,string,term,list[term],list[term],list[pred],list[pred],list[pred],list[pred],report,report){}.
  implementVarExp(localVar(Vn,_,LblVr,ThVr),Lc,Nm,X,Q,merge([X,LblVr,ThVr],Q),[call(some(Lc::tloc),prg(Vn,3),[X,LblVr,ThVr]),..Pre],Pre,Tail,Tail,Rp,Rp) :- genVarbl(Nm,X).
  implementVarExp(moduleVar(_,V,_),Lc,Nm,X,Q,merge([X],Q),[call(some(Lc::tloc),prg(V,1),[X]),..Pre],Pre,Tail,Tail,Rp,Rp) :- genVarbl(Nm,X).
  implementVarExp(labelArg(N,LblVr,ThVar),_,_,N,Q,merge([N,LblVr,ThVar],Q),Pre,Pre,Tail,Tail,Rp,Rp).
  implementVarExp(inheritField(Super,LblVr,ThVr),Lc,Nm,X,Q,merge([X,LblVr,ThVr],Q),
        [call(some(Lc::tloc),Super,[cons(trCons(Nm,1),[X]),LblVr,ThVr]),..Pre],Pre,Tail,Tail,Rp,Rp) :- genVarbl(Nm,X).
  implementVarExp(moduleClass(Enum,_,0),_,_,enum(Enum),Q,Q,Pre,Pre,Tail,Tail,Rp,Rp).
  implementVarExp(moduleImpl(_,enum(Enum)),_,_,enum(Enum),Q,Q,Pre,Pre,Tail,Tail,Rp,Rp).
  implementVarExp(localClass(Enum,_,_,LbVr,ThVr),_,_,cons(strct(Enum,2),[LbVr,ThVr]),Q,merge([LbVr,ThVr],Q),Pre,Pre,Tail,Tail,Rp,Rp).
  implementVarExp(inherit(Nm,_,LbVr,ThVr),_,_,cons(strct(Nm,2),[LbVr,ThVr]),Q,merge([LbVr,ThVr],Q),Pre,Pre,Tail,Tail,Rp,Rp).
  implementVarExp(notInMap,_,Nm,varbl(Nm),Q,merge([varbl(Nm)],Q),Pre,Pre,Tail,Tail,Rp,Rp).
  implementVarExp(moduleFun(_,_,_,Acc,_),_,_,enum(Acc),Q,Q,Pre,Pre,Tail,Tail,Rp,Rp).
  implementVarExp(moduleRel(_,_,_,Acc,_),_,_,enum(Acc),Q,Q,Pre,Pre,Tail,Tail,Rp,Rp).
  implementVarExp(localFun(_,_,Closure,_,LblVr,ThVr),_,_,cons(strct(Closure,2),[LblVr,ThVr]),Q,Q,Pre,Pre,Tail,Tail,Rp,Rp).
  implementVarExp(_,Lc,Nm,varbl(Nm),Q,Q,Pre,Pre,Tail,Tail,Rp,Rpx) :-
    reportError("cannot handle \(Nm) in expression",Lc,Rp,Rpx).

  trExpCallOp:(location,canonTerm,list[term],term,list[term],list[term],list[pred],list[pred],list[pred],list[pred],list[pred],list[pred],list[pred],list[pred],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trExpCallOp(Lc,v(_,Nm),Args,X,Q,merge([X],Q),Pre,Px,Tail,[ecall(some(Lc::tloc),Nm,Args<>[X]),..Tailx],Pre,Px,Tail,Tailx,_,_,Ex,Ex,Rp,Rp) :-
    isEscape(Nm),
    genVarbl("Xc",X).
  trExpCallOp(Lc,v(_,Nm),Args,Exp,Q,merge([X],Qx),APre,APx,APost,APstx,Pre,Px,Tail,Tailx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    lookupFunName(Map,Nm,Reslt),
    genVarbl("Xd",X),
    implementFunCall(Reslt,Lc,Nm,X,Args,Exp,Q,Qx,APre,APx,APost,APstx,Pre,Px,Tail,Tailx,Map,Opts,Ex,Exx,Rp,Rpx).
  trExpCallOp(Lc,T,Args,X,Q,merge([X],Qx),Pre,APx,Tail,[ocall(some(Lc::tloc),C,Cl,Cl),..Tailx],Pre,Px,Tail,Tailx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(T,Cl,Q,Qx,APx,Rx,Rx,Px,Map,Opts,Ex,Exx,Rp,Rpx),
    genVarbl("Xe",X),
    XArgs = Args<>[X],
    C = cons(trCons("_call",length(XArgs)),XArgs).

  implementFunCall:(mapEntry,location,string,term,list[term],term,list[term],list[term],list[pred],list[pred],list[pred],list[pred],list[pred],list[pred],list[pred],list[pred],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  implementFunCall(localFun(Fn,_,_,Ar,LblVr,ThVr),Lc,_,X,Args,X,Q,merge([X,LblVr,ThVr],Q),Pre,Px,Tail,[call(some(Lc::tloc),prg(Fn,size(Args)+3),Args<>[X,LblVr,ThVr]),..Tailx],Pre,Px,Tail,Tailx,_,_,Ex,Ex,Rp,Rp).
  implementFunCall(moduleFun(_,Fn,_,_,Ar),Lc,_,X,Args,X,Q,merge([X],Q),Pre,Px,Tail,[call(some(Lc::tloc),prg(Fn,size(Args)+1),Args<>[X]),..Tailx],Pre,Px,Tail,Tailx,_,_,Ex,Ex,Rp,Rp).
  implementFunCall(inheritField(Super,LblVr,ThVr),Lc,Nm,X,Args,X,Q,merge([X,LblVr,ThVr],Q),Pre,Px,Tail,
        [call(some(Lc::tloc),Super,[cons(trCons(Nm,length(Args)+1),Args<>[X]),LblVr,ThVr]),..Tailx],Pre,Px,Tail,Tailx,_,_,Ex,Ex,Rp,Rp).
  implementFunCall(moduleClass(Mdl,_,_),_,_,_,Args,cons(strct(Mdl,size(Args)),Args),Q,Q,Pre,Px,Tail,Tailx,Pre,Px,Tail,Tailx,_,_,Ex,Ex,Rp,Rp).
  implementFunCall(localClass(Mdl,_,_,LbVr,ThVr),_,_,_,Args,cons(strct(Mdl,size(Args)+2),Args<>[LbVr,ThVr]),Q,merge([Lbvr,ThVr],Q),Pre,Px,Tail,Tailx,Pre,Px,Tail,Tailx,_,_,Ex,Ex,Rp,Rp).
  implementFunCall(inherit(Mdl,_,LbVr,ThVr),_,_,_,Args,
        cons(strct(Mdl,size(Args)),Args),Q,merge([LbVr,ThVr],Q),Pre,Px,Tail,Tailx,Pre,Px,Tail,Tailx,_,_,Ex,Ex,Rp,Rp).
  implementFunCall(moduleImpl(_,Mdl),_,_,_,[],Mdl,Q,Q,Pre,Px,Tail,Tailx,Pre,Px,Tail,Tailx,_,_,Ex,Ex,Rp,Rp).
  implementFunCall(moduleImpl(_,Mdl),_,_,_,Args,cons(Mdl,Args),Q,Q,Pre,Px,Tail,Tailx,Pre,Px,Tail,Tailx,_,_,Ex,Ex,Rp,Rp).

  implementPkgRefExp:(mapEntry,location,string,string,term,term,list[term],list[term],list[pred],list[pred],report,report){}.
  implementPkgRefExp(moduleVar(_,Vn,_),Lc,_,_,Xi,Xi,Q,[Xi,..Q],[call(some(Lc::tloc),prg(Vn,1),[Xi]),..Pre],Pre,Rp,Rp).
  implementPkgRefExp(moduleClass(Enum,_,0),_,_,_,_,enum(Enum),Q,Q,Pre,Pre,Rp,Rp).
  implementPkgRefExp(_,Lc,Pkg,Ref,Xi,Xi,Q,Q,Pre,Pre,Rp,Rpx) :-
    reportError("illegal access to \(Pkg)#\(Ref)",Lc,Rp,Rpx).

  trLambda:(canonRule,term,list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
   -- We build $$(_call(Args<>Rep),$$(Free),_) :- Cond, !, replacement
  trLambda(equation(Lc,Nm,tpl(A),Exp,Cond),Closure,Q,Map,Opts,Ex,Exx,Rp,Rpx) :-
    FreeVars = freeVarsInRule(equation(Lc,Nm,tpl(A),Exp,Cond),Q,[]),
    genNewName(Map,Nm,3,prg(Lam,_)),
    genVarbl("Reslt",Reslt),
    trPtns(A,Args,[Reslt],[Reslt],Q1,Goals,PreGx,PostG,[unfy(some(Lc::tloc),Reslt,Rep)],Map,Opts,Ex,Ex0,Rp,Rp0), -- head of lambda
    trGoal(Cond,PreGx,[],Q1,Q2,Map,Opts,Ex0,Ex1,Rp0,Rp1),       -- condition goals
    trExp(Exp,Rep,Q2,Q3,PostGx,PVx,PVx,PostG,Map,Opts,Ex1,Ex2,Rp1,Rpx),      -- replacement expression
    Closure = mkClosure(Lam,FreeVars),
    LmPrg = prg(Lam,3),
    LamBody = (Goals=[] ? PostGx | Goals<>[neck,..PostGx]),
    Code = [clse(merge(FreeVars,Q3),LmPrg,[cons(trCons("_call",size(Args)),Args),Closure,anon],LamBody)],
    Exx = Ex2[LmPrg->rel(LmPrg,none,Code)].
  trLambda(clause(Lc,Nm,tpl(A),Cond),Closure,Q,Map,Opts,Ex,Exx,Rp,Rpx) :-
    FreeVars = freeVarsInRule(clause(Lc,Nm,tpl(A),Cond),Q,[]),
    genNewName(Map,Nm,3,prg(Lam,_)),
    trPtns(A,Args,[],[],Q1,Goals,PreGx,PostG,[],Map,Opts,Ex,Ex0,Rp,Rp0), -- head of lambda
    trGoal(Cond,PreGx,PostG,Q1,Q2,Map,Opts,Ex0,Ex1,Rp0,Rpx),       -- condition goals
    Closure = mkClosure(Lam,FreeVars),
    LmPrg = prg(Lam,3),
    Exx = Ex1[LmPrg->rel(LmPrg,none,[clse(merge(FreeVars,Q2),LmPrg,[cons(trCons("_call",size(Args)),Args),Closure,anon],Goals)])].
  trLambda(grRule(Lc,Nm,tpl(A),grTerms(PB),Body),Closure,Q,Map,Opts,Ex,Exx,Rp,Rpx) :-
    FreeVars = freeVarsInRule(grRule(Lc,Nm,tpl(A),grTerms(PB),Body),Q,[]),
    genNewName(Map,Nm,3,prg(Lam,_)),
    trPtns(A,Args,[],[],Q1,Goals,PreGx,PostG,G7,Map,ClOpts,Ex,Ex0,Rp,Rp0),  -- head args
    genVarbl("StIn",StIn),
    dcgBody(Body,Map,Opts,PreGx,PostG,StIn,StOut,[StIn,..Q1],Q2,Ex0,Ex1,Rp0,Rp1), -- grammar body
    pushTerminals(PB,Map,Opts,G7,[],StOut,StX,Q2,Q4,Ex1,Ex2,Rp1,Rpx),     -- push back
    Closure = mkClosure(Lam,FreeVars),
    LmPrg = prg(Lam,3),
    CallStrct = cons(trCons("_call",size(Args)+2),[StIn,StX,..Args]),
    Exx = Ex2[LmPrg->rel(LmPrg,none,[clse(merge(FreeVars,Q4),LmPrg,[CallStrct,Closure,anon],Goals)])].

  mkClosure:(string,list[term])=>term.
  mkClosure(Lam,[]) => enum(Lam).
  mkClosure(Lam,FreeVars) => cons(strct(Lam,size(FreeVars)),FreeVars).

  trGoal:(canonCond,list[pred],list[pred],list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trGoal(trueCond,Goals,Goals,Q,Q,_,_,Ex,Ex,Rp,Rp).
  trGoal(falseCond,[fail,..Rest],Rest,Q,Q,_,_,Ex,Ex,Rp,Rp).
  trGoal(conjCond(L,R),Goals,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trGoal(L,Goals,G0,Q,Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    trGoal(R,G0,Gx,Q0,Qx,Map,Opts,Ex0,Exx,Rp0,Rpx).
  trGoal(disjCond(L,R),[call(none,DisjPr,LQ),..Gx],Gx,Q,merge(LQ,Q),Map,Opts,Ex,Exx,Rp,Rpx) :-
    trGoal(L,LG,[],[],Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    trGoal(R,RG,[],Q0,LQ,Map,Opts,Ex0,Ex1,Rp0,Rpx),
    genNewName(Map,"or",length(LQ),DisjPr),
    Cl1 = clse(LQ,DisjPr,LQ,LG),
    Cl2 = clse(LQ,DisjPr,LQ,RG),
    Exx = Ex1[DisjPr->rel(DisjPr,none,[Cl1,Cl2])].
  trGoal(condCond(T,L,R),[call(none,CondPr,LQ),..Gx],Gx,Q,merge(LQ,Q),Map,Opts,Ex,Exx,Rp,Rpx) :-
    trGoal(T,TG,[],[],Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    trGoal(L,LG,[],Q0,Q1,Map,Opts,Ex0,Ex1,Rp0,Rp1),
    trGoal(R,RG,[],Q1,LQ,Map,Opts,Ex1,Ex2,Rp1,Rpx),
    genNewName(Map,"cond",length(LQ),CondPr),
    Cl1 = clse(LQ,CondPr,LQ,TG<>[neck,..LG]),
    Cl2 = clse(LQ,CondPr,LQ,RG),
    Exx = Ex2[CondPr->rel(CondPr,none,[Cl1,Cl2])].
  trGoal(oneCond(T),[call(none,OnePr,LQ),..Gx],Gx,Q,merge(LQ,Q),Map,Opts,Ex,Exx,Rp,Rpx) :-
    trGoal(T,TG,[neck],[],LQ,Map,Opts,Ex,Ex0,Rp,Rpx),
    genNewName(Map,"one",length(LQ),OnePr),
    Cl1 = clse(LQ,OnePr,LQ,TG),
    Exx = Ex0[OnePr->rel(OnePr,none,[Cl1])].
  trGoal(negCond(T),[call(none,NegPr,LQ),..Gx],Gx,Q,merge(LQ,Q),Map,Opts,Ex,Exx,Rp,Rpx) :-
    trGoal(T,TG,[],[],LQ,Map,Opts,Ex,Ex0,Rp,Rpx),
    genNewName(Map,"neg",length(LQ),NegPr),
    Cl1 = clse(LQ,NegPr,LQ,TG<>[neck,fail]),
    Cl2 = clse(LQ,NegPr,LQ,[]),
    Exx = Ex0[NegPr->rel(NegPr,none,[Cl1,Cl2])].
  trGoal(forallCond(L,R),[call(none,APr,LQ),..Gx],Gx,Q,merge(LQ,Q),Map,Opts,Ex,Exx,Rp,Rpx) :-
    trGoal(L,LG,[call(none,BPr,LQ)],[],Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    trGoal(R,RG,[],Q0,LQ,Map,Opts,Ex0,Ex1,Rp0,Rpx),
    QAr = length(LQ),
    genNewName(Map,"forallA",QAr,APr),
    genNewName(Map,"forallB",QAr,BPr),
    ACl1 = clse(LQ,APr,LQ,LG<>[neck,fail]),
    ACl2 = clse(LQ,APr,LQ,[]),
    BCl1 = clse(LQ,BPr,LQ,RG<>[neck,fail]),
    BCl2 = clse(LQ,BPr,LQ,[]),
    Ex2 = Ex1[APr->rel(APr,none,[ACl1,ACl2])],
    Exx = Ex2[BPr->rel(BPr,none,[BCl1,BCl2])].
  trGoal(unifyCond(Lc,L,R),G,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    lineDebug(Lc,G3,[unfy(some(Lc::tloc),Lx,Rx),..Gx],Opts),
    trExp(L,Lx,Q,Q0,G,G0,G0,G1,Map,Opts,Ex,Ex0,Rp,Rp0),
    trExp(R,Rx,Q0,Qx,G1,G2,G2,G3,Map,Opts,Ex0,Exx,Rp0,Rpx).
  trGoal(phraseCond(Lc,NT,Strm,Rem),G,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(Strm,StIn,Q,Q0,G,G0,G0,G1,Map,Opts,Ex,Ex0,Rp,Rp0),
    lineDebug(Lc,G1,G2,Opts),
    dcgBody(NT,Map,Opts,G2,G3,StIn,StOut,Q0,Q2,Ex0,Ex1,Rp0,Rp1), -- grammar body
    trExp(Rem,Out,Q2,Qx,G3,G4,G4,G5,Map,Opts,Ex1,Exx,Rp1,Rpx),
    joinStream(Out,StOut,G5,Gx).
  trGoal(callCond(Lc,Pred,tpl(Args)),G,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    lineDebug(Lc,G,G0,Opts),
    trExps(Args,AG,[],Q,Q0,G0,Pr,Pr,G3,Map,Opts,Ex,Ex0,Rp,Rp0),
    trGoalCall(Pred,AG,G3,Gx,Q0,Qx,Map,Opts,Ex0,Exx,Rp0,Rpx).
  trGoal(isTrue(E),G,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(E,Exp,Q,Qx,G,G0,G0,[unfy(none,Exp,enum("lo.core#true")),..Gx],Map,Opts,Ex,Exx,Rp,Rpx).

  trGoalCall:(canonTerm,list[term],list[pred],list[pred],list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trGoalCall(v(Lc,Nm),Args,[ecall(some(Lc::tloc),Nm,Args),..Tail],Tail,Q,Q,_,_,Ex,Ex,Rp,Rp) :-
    isEscape(Nm).
  trGoalCall(v(Lc,Nm),Args,G,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    lookupRelName(Map,Nm,RSpec),
    implementGoalCall(RSpec,Lc,Nm,Args,G,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx).
  trGoalCall(dot(Lc,Rec,Pred),Args,G,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trGoalDot(Lc,Rec,cons(trCons(Pred,length(Args)),Args),G,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx).

  implementGoalCall:(mapEntry,location,string,list[term],list[pred],list[pred],list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  implementGoalCall(localRel(Fn,_,_,Ar,LblVr,ThVr),Lc,_,Args,[call(some(Lc::tloc),prg(Fn,size(Args)+2),Args<>[LblVr,ThVr]),..Tail],Tail,Q,merge([LblVr,ThVr],Q),_,_,Ex,Ex,Rp,Rp).
  implementGoalCall(moduleRel(_,Fn,_,_,Ar),Lc,_,Args,[call(some(Lc::tloc),prg(Fn,size(Args)),Args),..Tail],Tail,Q,Q,_,_,Ex,Ex,Rp,Rp).
  implementGoalCall(inheritField(Super,LblVr,ThVr),Lc,Pred,Args,
        [call(some(Lc::tloc),Super,[cons(trCons(Pred,length(Args)),Args),LblVr,ThVr]),..Tail],Tail,Q,merge([LblVr,ThVr],Q),_,_,Ex,Ex,Rp,Rp).
  implementGoalCall(notInMap,Lc,Pred,Args,G,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trGoalDot(Lc,v(Lc,Pred),cons(trCons("_call",length(Args)),Args),G,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx).
  implementGoalCall(_,Lc,Pred,_,G,G,Q,Q,_,_,Ex,Ex,Rp,Rpx) :-
    reportError("cannot handle source for \(Pred)",Lc,Rp,Rpx).

  trGoalDot:(location,canonTerm,term,list[pred],list[pred],list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trGoalDot(_,v(Lc,Nm),C,[call(some(Lc::tloc),Super,[C,LbVr,ThVr]),..Gx],Gx,Q,merge([LbVr,ThVr],Q),Map,_,Ex,Ex,Rp,Rp) :-
    lookupVarName(Map,Nm,inherit(_,Super,LbVr,ThVr)).
  trGoalDot(Lc,Rec,C,G,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(Rec,NR,Q,Qx,G,G0,G0,[ocall(some(Lc::tloc),C,NR,NR),..Gx],Map,Opts,Ex,Exx,Rp,Rpx).

  genClassMap:(list[lyr],trOptions,location,string,list[canonRule],tipe,list[lyr],map[term,rel],map[term,rel],report,report){}.
  genClassMap(Map,Opts,Lc,LclName,Defs,Face,[lyr(LclName,List,LblGl,LbVr,ThVr),..Map],P,Px,Rp,Rpx) :-
    genVarbl("LbV",LbVr),
    genVarbl("ThV",ThVr),
    pickAllFieldsFromFace(Face,Fields),
    makeClassMtdMap(Defs,LclName,LbVr,ThVr,LblGl,[],L0,Fields,Map,Opts,P,P0,Rp,Rp0),
    makeInheritanceMap(Defs,LclName,LbVr,ThVr,Map,Opts,L0,List,Fields,P0,Px,Rp0,Rpx).

  pickAllFieldsFromFace:(tipe,list[(string,tipe)]){}.
  pickAllFieldsFromFace(Tp,Fields) :-
    moveQuants(Tp,_,QTp),
    moveConstraints(QTp,_,faceType(Fields)).

  makeClassMtdMap:(list[canonRule],string,term,term,list[pred],list[(string,mapEntry)],list[(string,mapEntry)],list[(string,tipe)],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  makeClassMtdMap([],_,_,_,_,List,List,_,_,_,Ex,Ex,Rp,Rp).
  makeClassMtdMap([clRule(Lc,_,v(_,_),theta(Stmts,_),_,_),..Rules],LclName,LbVr,ThVr,LblGl,List,Lx,Fields,Map,Opts,Ex,Exx,Rp,Rpx) :-
    collectMtds(Stmts,LclName,LbVr,ThVr,List,L0,Fields),
    collectLabelVars([],LbVr,ThVr,L0,L1),
    extraVars(Map,Extra),
    makeLblTerm(enum(LclName),Extra,LblTerm),
    (Extra =[] ? LblGl = [] | LblGl = [unfy(some(Lc::tloc),LbVr,LblTerm)]),
    makeClassMtdMap(Rules,LclName,LbVr,ThVr,_,L1,Lx,Fields,Map,Opts,Ex,Exx,Rp,Rpx).
  makeClassMtdMap([clRule(Lc,_,Hd,theta(Stmts,_),_,_),..Rules],LclName,LbVr,ThVr,LblGl,List,Lx,Fields,Map,Opts,Ex,Exx,Rp,Rpx) :-
    collectMtds(Stmts,LclName,LbVr,ThVr,List,L0,Fields),
    trPtn(Hd,Lbl,[],Vs,LblGl,Px,Px,[unfy(some(Lc::tloc),LbVr,LblTerm)],Map,Opts,Ex,Ex0,Rp,Rp0),
    collectLabelVars(Vs,LbVr,ThVr,L0,L1),
    extraVars(Map,Extra),
    makeLblTerm(Lbl,Extra,LblTerm),
    makeClassMtdMap(Rules,LclName,LbVr,ThVr,_,L1,Lx,Fields,Map,Opts,Ex0,Exx,Rp0,Rpx).
  makeClassMtdMap([clRule(_,_,_,_,_,_),..Rules],LclName,LbVr,ThVr,LblGl,List,L0,Fields,Map,Opts,Ex,Exx,Rp,Rpx) :-
    makeClassMtdMap(Rules,LclName,LbVr,ThVr,LblGl,List,L0,Fields,Map,Opts,Ex,Exx,Rp,Rpx).

  makeLblTerm:(term,list[term],term){}.
  makeLblTerm(enum(Nm),[],enum(Nm)).
  makeLblTerm(enum(Nm),Extra,cons(strct(Nm,size(Extra)),Extra)).
  makeLblTerm(cons(strct(Nm,_),Args),Extra,cons(strct(Nm,size(Args)+size(Extra)),Args<>Extra)).

  makeInheritanceMap:(list[canonRule],string,term,term,list[lyr],trOptions,list[(string,mapEntry)],list[(string,mapEntry)],list[(string,tipe)],map[term,rel],map[term,rel],report,report){}.
  makeInheritanceMap([],_,_,_,_,_,List,List,_,Px,Px,Rp,Rp).
  makeInheritanceMap([clRule(_,_,_,theta(_,_),_,_),..Defs],LclName,LbVr,ThVr,Map,Opts,List,Lx,Fields,P,Px,Rp,Rpx) :-
    makeInheritanceMap(Defs,LclName,LbVr,ThVr,Map,Opts,List,Lx,Fields,P,Px,Rp,Rpx).
  makeInheritanceMap([clRule(Lc,_,Pt,R,_,FaceTp),..Defs],LclName,LbVr,ThVr,Map,Opts,List,Lx,Fields,P,Prx,Rp,Rpx) :-
    pickAllFieldsFromFace(FaceTp,InhFields),
    extraVars(Map,Extra),
    genVarbl("CV",CV),
    trPtn(Pt,Ptn,Extra,Q0,Body,Pre0,Pre0,Prex,Map,Opts,P,Pr0,Rp,Rp0),
    trExp(R,Repl,Q0,Q1,Prex,Px,Px,[ocall(some(Lc::tloc),CV,Repl,ThVr)],Map,Opts,Pr0,Pr1,RP0,Rp1),
    genNewName(Map,"^",3,Super),
    Pr2 = addCl(Pr1,clse(merge(Q1,[CV,ThVr]),Super,[CV,Ptn,ThVr],Body)),
    makeInheritFields(InhFields,LclName,some(Lc::tloc),Super,Fields,Map,LbVr,ThVr,Pr2,Pr3,List,L1),
    makeInheritanceMap(Defs,LclName,LbVr,ThVr,Map,Opts,L1,Lx,Fields,Pr3,Prx,Rp1,Rpx).

  makeInheritFields:(list[(string,tipe)],string,option[tloc],term,list[(string,tipe)],list[lyr],term,term,
        map[term,rel],map[term,rel],list[(string,mapEntry)],list[(string,mapEntry)]){}.
  makeInheritFields([],_,_,_,_,_,_,_,Entry,Entry,List,List).
  makeInheritFields([(Nm,Tp),..InhFields],LclName,TLc,Super,Fields,Map,LbVr,ThVr,Entry,En,List,Lx) :-
    (Nm,_) in List,
    \+ isPredType(Tp), -- we dont allow overriding of relations
    makeInheritFields(InhFields,LclName,TLc,Super,Fields,Map,LbVr,ThVr,Entry,En,List,Lx).
  makeInheritFields([(Nm,Tp),..InhFields],LclName,TLc,Super,Fields,Map,LbVr,ThVr,Entry,En,List,Lx) :-
    inheritClause(Nm,Tp,TLc,LclName,Map,Super,Entry,En0),
    makeInheritFields(InhFields,LclName,TLc,Super,Fields,Map,LbVr,ThVr,En0,En,[(Nm,inheritField(Super,LbVr,ThVr)),..List],Lx).

  inheritClause:(string,tipe,option[tloc],string,list[lyr],term,map[term,rel],map[term,rel]){}.
  inheritClause(Name,Tp,TLc,Prefix,Map,Super,P,Px) :-
    Arity = (isProgramType(Tp) ? effectiveArity(Tp,0) | 1),
    Args = genVars(Arity),
    genVarbl("This",ThVr),
    genVarbl("Lbl",LbVr),
    Con = cons(trCons(Name,Arity),Args),
    Px =addCl(P,clse(Args<>[LblVr,ThVr],prg(Prefix,3),[Con,LbVr,ThVr],[call(TLc,Super,[Con,LbVr,ThVr])])).

  collectMtds:(list[canonDef],string,term,term,list[(string,mapEntry)],list[(string,mapEntry)],list[(string,tipe)]){}.
  collectMtds([],_,_,_,List,List,_).
  collectMtds([Entry,..Defs],OuterNm,LbVr,ThVr,List,Lx,Fields) :-
    collectMtd(Entry,OuterNm,LbVr,ThVr,List,L0),
    collectMtds(Defs,OuterNm,LbVr,ThVr,L0,Lx,Fields).

  collectMtd:(canonDef,string,term,term,list[(string,mapEntry)],list[(string,mapEntry)]){}.
  collectMtd(funDef(_,Nm,Tp,_,_),OuterNm,Lbl,ThV,List,
        [(Nm,localFun(localName(OuterNm,"@",Nm),localName(OuterNm,"%",Nm),localName(OuterNm,"^",Nm),effectiveArity(Tp,0),Lbl,ThV)),..List]).
  collectMtd(relDef(_,Nm,Tp,_,_),OuterNm,Lbl,ThV,List,
        [(Nm,localRel(localName(OuterNm,"@",Nm),localName(OuterNm,"%",Nm),localName(OuterNm,"^",Nm),effectiveArity(Tp,0),Lbl,ThV)),..List]).
  collectMtd(grammDef(_,Nm,Tp,_,_),OuterNm,Lbl,ThV,List,
        [(Nm,localRel(localName(OuterNm,"@",Nm),localName(OuterNm,"%",Nm),localName(OuterNm,"^",Nm),effectiveArity(Tp,0),Lbl,ThV)),..List]).
  collectMtd(varDef(_,Nm,_,_,_,_),OuterNm,Lbl,ThV,List,[(Nm,localVar(localName(OuterNm,"@",Nm),localName(OuterNm,"%",Nm),Lbl,ThV)),..List]).
  collectMtd(classDef(_,Nm,Tp,_,_,_),OuterNm,Lbl,ThV,List,
        [(Nm,localClass(localName(OuterNm,"@",Nm),localName(OuterNm,"%",Nm),0,Lbl,ThV)),..List]) :- \+ isClassType(Tp).
  collectMtd(classDef(_,Nm,Tp,_,_,_),OuterNm,Lbl,ThV,List,
        [(Nm,localClass(localName(OuterNm,"@",Nm),localName(OuterNm,"%",Nm),effectiveArity(Tp,0),Lbl,ThV)),..List]).

  collectLabelVars:(list[term],term,term,list[(string,mapEntry)],list[(string,mapEntry)]){}.
  collectLabelVars([],_,_,List,List).
  collectLabelVars([varbl(Nm),..Args],LbVr,ThVr,List,Lx) :-
    collectLabelVars(Args,LbVr,ThVr,[(Nm,labelArg(varbl(Nm),LbVr,ThVr)),..List],Lx).

  public implementation coercion[location,tloc] <= {
    _coerce(loc(Line,Off,Col,Len,Pth)) => tloc(Line,Off,Col,Len).
  }

  addCl:(map[term,rel],clse)=>map[term,rel].
  addCl(M,Cl) => (present(M,Nm,rel(_,Lc,Clses)) ?
          M[Nm->rel(Nm,Lc,Clses<>[Cl])] |
          M[Nm->rel(Nm,none,[Cl])]) :-
    Nm = clName(Cl).
}
