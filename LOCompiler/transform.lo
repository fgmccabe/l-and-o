lo.comp.transform{
  import lo.
  import lo.comp.args.
  import lo.comp.canon.
  import lo.comp.debug.
  import lo.comp.errors.
  import lo.comp.escapes.
  import lo.comp.freevars.
  import lo.comp.location.
  import lo.comp.misc.
  import lo.comp.package.
  import lo.comp.term.
  import lo.comp.transutils.
  import lo.comp.types.

  /*
   * Implement a semantic reduction from L&O to Prolog-style rules
   */

  public transformProg:(canonPkg,compOption,prProg,report,report){}.
  transformProg(canonPkg(PkSpec,Imports,Defs,Others),Opt,prProg(PkSpec,Rules),Rp,Rpx) :-
    PkSpec = pkgSpec(pkg(Pkg,Vers),_,_,_,_,_,_),
    makePkgMap(Pkg,Defs,Imports) = (Enums,Map),
    POpts = trOpts(Opt,Pkg),
    transformModuleDefs(Defs,Map,POpts,[],R0,Rp,Rp0),
    transformOthers(Others,Map,POpts,Inits,R0,R1,Rp0,Rpx),
    thetaInit(Map,Inits,R1,Rules).

  transformModuleDefs:(list[canonDef],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformModuleDefs([],_,_,Rules,Rules,Rp,Rp).
  transformModuleDefs([Def,..Defs],Map,Opts,R0,Rx,Rp,Rpx) :-
    transformMdlDef(Def,Map,Opts,R0,R1,Rp,Rp0),
    transformModuleDefs(Defs,Map,Opts,R1,Rx,Rp0,Rpx).

  transformMdlDef:(canonDef,list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformMdlDef(funDef(Lc,Nm,Tp,Cx,Eqns),Map,Opts,R,Rx,Rp,Rpx) :-
    transformFunction(funDef(Lc,Nm,Tp,Cx,Eqns),Map,Opts,R,Rx,Rp,Rpx).
  transformMdlDef(grammDef(Lc,Nm,Tp,Cx,Rls),Map,Opts,R,Rx,Rp,Rpx) :-
    transformGrammar(grammDef(Lc,Nm,Tp,Cx,Rls),Map,Opts,R,Rx,Rp,Rpx).
  transformMdlDef(relDef(Lc,Nm,Tp,Cx,Clses),Map,Opts,R,Rx,Rp,Rpx) :-
    transformPredicate(relDef(Lc,Nm,Tp,Cx,Clses),Map,Opts,R,Rx,Rp,Rpx).
  transformMdlDef(varDef(Lc,Nm,_,_,Value,Cond),Map,Opts,R,Rx,Rp,Rpx) :-
    transformDefn(Map,Opts,Lc,Nm,Cond,Value,R,Rx,Rp,Rpx).
  transformMdlDef(classDef(Lc,Nm,Tp,_,Defs,Face),Map,Opts,R,Rx,Rp,Rpx) :-
    transformClass(Lc,Nm,Defs,Face,Map,Opts,R,Rx,Rp,Rpx).
  transformMdlDef(typeDef(_,_,_,_),_,_,Rules,Rules,Rp,Rp).
  transformMdlDef(cnDefn(_,_,_),_,_,Rules,Rules,Rp,Rp).
  transformMdlDef(implDef(Lc,_,ImplName,_,_,Hd,Body,Face),Map,Opts,R,Rx,Rp,Rpx) :-
    transformImplementation(Lc,ImplName,const0(Hd,inMode),Body,Face,Map,Opts,R,Rx,Rp,Rpx).

  private extraArity:(integer,list[term],integer){}.
  extraArity(Arity,Vars,size(Vars)+Arity).

  transformFunction:(canonDef,list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformFunction(funDef(Lc,Nm,Tp,[],Eqns),Map,Opts,P,Px,Rp,Rpx) :-
    lookupFunName(Map,Nm,Reslt),
    programAccess(Reslt,LclFun,_,Closure,_),
    extraVars(Map,Extra),
    transformEquations(Map,Opts,LclFun,Ar,Extra,Eqns,1,Clses,P,P0,Rp,Rpx),
    AAr = Ar+size(Extra),
    LPrg = prg(LclFun,AAr),
    P1 = P0[LPrg->rel(LPrg,some(Lc::tloc),Clses)],
    funClosureEntry(Map,some(Lc::tloc),LclFun,Closure,Ar,P1,Px).

  transformEquations:(list[lyr],trOptions,string,integer,list[term],list[canonRule],integer,list[clse],map[term,rel],map[term,rel],report,report){}.
  transformEquations(_,_,_,_,_,[],_,[],Ex,Ex,Rp,Rp).
  transformEquations(Map,Opts,LclFun,Arity,Extra,[Eqn,..Defs],No,Rules,Ex,Exx,Rp,Rpx) :-
    transformEqn(Eqn,Map,Opts,LclFun,Arity,Extra,No,Rules,R0,Ex,Ex0,Rp,Rp0),
    transformEquations(Map,Opts,LclFun,_,Extra,Defs,No+1,R0,Ex0,Exx,Rp0,Rpx).

  transformEqn:(canonRule,list[lyr],trOptions,string,integer,list[term],integer,list[clse],list[clse],map[term,rel],map[term,rel],report,report){}.
  transformEqn(equation(Lc,Nm,A,Value,Cond),Map,Opts,LclFun,Arity,Extra,QNo,
    [eqn(Q,prg(LclFun,Arity+size(Extra)),Args,simplifyGuard(guarded(Rep,simplifyCond(conj(none,Guard<>Body))))),..Rx],Rx,Ex,Exx,Rp,Rpx) :-
    debugPreamble(Nm,Extra,Q0,LbLx,FBg,Opts,ClOpts),        -- are we debugging?
    trArgPtns(A,Args,const0(Extra,inMode),Q0,Q1,Map,ClOpts,Ex,Ex0,Rp,Rp0), -- head args
    trGoal(Cond,PreG,[],Q1,Q2,Map,ClOpts,Ex0,Ex1,Rp0,Rp1), -- condition goals
    trExp(Value,Rep,Q2,Q3,Map,ClOpts,Ex1,Exx,Rp1,Rpx),  -- replacement expression
    labelAccess(Q3,Q,Map,Guard,LbLx),                       -- generate label access goals
    frameDebug(Nm,QNo,Q,FBg,LG,ClOpts),                     -- generate frame entry debugging
    lineDebug(Lc,LG,PreG,ClOpts),                           -- line debug after setting up frame
    deframeDebug(Nm,QNo,PostG,[],ClOpts),                      -- generate frame exit debugging
    breakDebug(Nm,Body,PostG,ClOpts),                       -- generate break point debugging
    Arity = size(A).

  transformPredicate:(canonDef,list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformPredicate(relDef(Lc,Nm,_,[],Rules),Map,Opts,P,Px,Rp,Rpx) :-
    lookupRelName(Map,Nm,Reslt),
    programAccess(Reslt,PrdNme,_,Closure,Ar),
    extraVars(Map,Extra),
    transformClauses(Map,Opts,PrdNme,Arity,Extra,Rules,1,Clses,P,P0,Rp,Rpx),
    Prg = prg(PrdNme,Arity),
    P1 = P0[Prg->rel(Prg,some(Lc::tloc),Clses)],
    predClosureEntry(Map,some(Lc::tloc),PrdNme,Closure,Ar,P1,Px).

  transformClauses:(list[lyr],trOptions,string,integer,list[term],list[canonRule],integer,list[clse],map[term,rel],map[term,rel],report,report){}.
  transformClauses(_,_,_,_,_,[],No,[],Ex,Ex,Rpx,Rpx).
  transformClauses(Map,Opts,PrdNme,Arity,Extra,[Cl,..Defs],No,Rules,Ex,Exx,Rp,Rpx) :-
    transformClause(Cl,Map,Opts,PrdNme,Arity,Extra,No,Rules,R0,Ex,Ex0,Rp,Rp0),
    transformClauses(Map,Opts,PrdNme,_,Extra,Defs,No+1,R0,Ex0,Exx,Rp0,Rpx).

  transformClause:(canonRule,list[lyr],trOptions,string,integer,list[term],integer,list[clse],list[clse],map[term,rel],map[term,rel],report,report){}.
  transformClause(clause(Lc,Nm,A,Body),Map,Opts,PrdNme,Arity,Extra,QNo,[clse(Q,prg(PrdNme,Arity),Args,Goals),..Rx],Rx,Ex,Exx,Rp,Rpx) :-
    debugPreamble(Nm,Extra,Q0,G0,G1,Opts,ClOpts),        -- are we debugging?
    trArgPtns(A,Args,const0(Extra,inMode),Q0,Q1,Map,ClOpts,Ex,Ex0,Rp,Rp0), -- head args
    trGoal(Body,G4,G7,Q1,Q3,Map,ClOpts,Ex0,Exx,Rp0,Rpx),
    labelAccess(Q3,Q,Map,Goals,G0),                       -- generate label access goals
    frameDebug(Nm,QNo,Q,G1,G2,ClOpts),                    -- generate frame entry debugging
    lineDebug(Lc,G2,G3,ClOpts),                           -- line debug after setting up frame
    deframeDebug(Nm,QNo,G7,[],ClOpts),                    -- generate frame exit debugging
    breakDebug(Nm,G3,G4,ClOpts),                          -- generate break point debugging
    Arity = size(Args).

  transformDefn:(list[lyr],trOptions,location,string,canonCond,canonTerm,map[term,rel],map[term,rel],report,report){}.
  transformDefn(Map,Opts,Lc,Nm,Cond,Value,P,Px,Rp,Rpx) :-
    extraVars(Map,Extra),
    lookupVarName(Map,Nm,Reslt),
    programAccess(Reslt,LclName,_,Closure,_),             -- extra variables coming from labels
    LclPrg = prg(LclName,length(Extra)),
    debugPreamble(Nm,Extra,Q0,G0,G1,Opts,ClOpts),         -- are we debugging?
    trGoal(Cond,G4,[],Q0,Q2,Map,ClOpts,P,P0,Rp,Rp0),      -- condition goals
    trExp(Value,Rep,Q2,Q3,Map,ClOpts,P0,P1,Rp0,Rpx),      -- replacement expression
    labelAccess(Q3,Q,Map,Guard,G0),                       -- generate label access goals
    frameDebug(Nm,0,Q,G1,G2,ClOpts),                      -- generate frame entry debugging
    lineDebug(Lc,G2,G3,ClOpts),                           -- line debug after setting up frame
    deframeDebug(Nm,0,G7,[],ClOpts),                      -- generate frame exit debugging
    breakDebug(Nm,G3,G4,ClOpts),                          -- generate break point debugging
    Px = P1[LclPrg->rel(LclPrg,some(Lc::tloc),[eqn(Q,LclPrg,const0(Extra,inMode),simplifyGuard(guarded(Rep,simplifyCond(conj(none,Guard<>G7)))))])].

  varAccess:(list[lyr],string,map[term,rel],map[term,rel]){}.
  varAccess(Map,Nm,P,Px) :-
    lookupVarName(Map,Nm,Reslt),
    programAccess(Reslt,LclName,_,_,_),
    LclPrg = prg(LclName,2),
    genVarbl("This",ThVr),
    genVarbl("Lbl",LblVr),
    Vars = [LblVr,ThVr],
    VarCl = eqn(Vars,prg(layerName(Map),3),[(biMode,enum(Nm)),(inMode,LblVr),(inMode,ThVr)],invoke(none,LclPrg,const0(Vars,inMode))),
    Px = addCl(P,VarCl).

  transformGrammar:(canonDef,list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformGrammar(grammDef(Lc,Nm,_,[],Rls),Map,Opts,P,Px,Rp,Rpx) :-
    lookupRelName(Map,Nm,Reslt),
    programAccess(Reslt,LclFun,_,Closure,_),
    extraVars(Map,Extra),
    transformGrammarRules(Map,Opts,LclFun,Arity,Extra,Rls,1,Clses,P,P0,Rp,Rpx),
    predClosureEntry(Map,some(Lc::tloc),LclFun,Closure,Arity,P0,P1),
    Px = P1[prg(LclFun,Arity)->rel(prg(LclFun,Arity),some(Lc::tloc),Clses)].

  transformGrammarRules:(list[lyr],trOptions,string,integer,list[term],list[canonRule],integer,list[clse],map[term,rel],map[term,rel],report,report){}.
  transformGrammarRules(_,_,_,_,_,[],No,[],Ex,Ex,Rp,Rp).
  transformGrammarRules(Map,Opts,LclFun,Arity,Extra,[Rl,..Defs],No,Rules,Ex,Exx,Rp,Rpx) :-
    transformGrammarRule(Rl,Map,Opts,LclFun,Arity,Extra,No,Rules,R0,Ex,Ex0,Rp,Rp0),
    transformGrammarRules(Map,Opts,LclFun,_,Extra,Defs,No+1,R0,Ex0,Exx,Rp0,Rpx).

  transformGrammarRule:(canonRule,list[lyr],trOptions,string,integer,list[term],integer,list[clse],list[clse],map[term,rel],map[term,rel],report,report){}.
  transformGrammarRule(grRule(Lc,Nm,A,grTerms(PB),Body),Map,Opts,LclFun,Arity,Extra,QNo,
        [clse(Q,prg(LclFun,Arity),[(inMode,StIn),(outMode,StX),..Args],Goals),..Rx],Rx,Ex,Exx,Rp,Rpx) :-
    debugPreamble(Nm,Extra,Q0,G0,G1,Opts,ClOpts),                     -- are we debugging?
    trArgPtns(A,Args,const0(Extra,inMode),Q0,Q1,Map,ClOpts,Ex,Ex0,Rp,Rp0),  -- head args
    genVarbl("StIn",StIn),
    dcgBody(Body,Map,ClOpts,G4,G6,StIn,StOut,[StIn,..Q1],Q2,Ex0,Ex1,Rp0,Rp1), -- grammar body
    pushTerminals(PB,Map,ClOpts,G6,G8,StOut,StX,Q2,Q4,Ex1,Exx,Rp1,Rpx),     -- push back
    labelAccess(Q4,Q,Map,Goals,G0),                        -- generate label access goals
    frameDebug(Nm,QNo,Q,G1,G2,ClOpts),                     -- generate frame entry debugging
    lineDebug(Lc,G2,G3,ClOpts),                            -- line debug after setting up frame
    deframeDebug(Nm,QNo,G8,[],ClOpts),                     -- generate frame exit debugging
    breakDebug(Nm,G3,G4,ClOpts),                           -- generate break point debugging
    Arity = size(Args)+2.

  dcgBody:(canonNT,list[lyr],trOptions,list[pred],list[pred],term,term,list[term],list[term],map[term,rel],map[term,rel],report,report){}.
  dcgBody(grTerms(Terms),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    pushTerminals(Terms,Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx).
  dcgBody(grConj(Lhs,Rhs),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    dcgBody(Lhs,Map,Opts,G,G0,Strm,Strm0,Q,Q0,Ex,Ex0,Rp,Rp0),
    dcgBody(Rhs,Map,Opts,G0,Gx,Strm0,Strmx,Q0,Qx,Ex0,Exx,Rp0,Rpx).
  dcgBody(grDisj(Lhs,Rhs),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    dcgDisj(Lhs,Rhs,Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx).
  dcgBody(grCond(Tst,Lhs,Rhs),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    dcgConditional(Tst,Lhs,Rhs,Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx).
  dcgBody(grOne(Tst),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    dcgOne(Tst,Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx).
  dcgBody(grNeg(Tst),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    joinStream(Strm,Strmx,G,G0),
    dcgNeg(Tst,Map,Opts,G0,Gx,Strm,Q,Qx,Ex,Exx,Rp,Rpx).
  dcgBody(grAhed(Tst),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    joinStream(Strm,Strmx,G,G0),
    dcgAhead(Tst,Map,Opts,G0,Gx,Strm,Q,Qx,Ex,Exx,Rp,Rpx).
  dcgBody(grTest(Goal),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    joinStream(Strm,Strmx,G,G0),
    trGoal(Goal,G0,Gx,Q,Qx,pushStreamVar(Map,Strm),Opts,Ex,Exx,Rp,Rpx).
  dcgBody(grCall(Lc,NT,Args),Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    lineDebug(Lc,G,G3,Opts),
    trArgExps(Args,AG,[],Q,Q0,Map,Opts,Ex,Ex0,Rp,Rpx),
    (var(Strmx) ? genVarbl("Stx",Strmx), Q1=[Strmx,..Q0] | Q0=Q1),
    trGoalCall(NT,[(inMode,Strm),(outMode,Strmx),..AG],G3,Gx,Q1,Qx,Map,Opts,Ex0,Exx,Rp,Rpx).

  dcgDisj:(canonNT,canonNT,list[lyr],trOptions,list[pred],list[pred],term,term,list[term],list[term],map[term,rel],map[term,rel],report,report){}.
  dcgDisj(Lhs,Rhs,Map,Opts,[call(none,DisProg,[(inMode,Strm),(outMode,Strmx),..const0(DQ,biMode)]),..G],G,Strm,Strmx,Q,merge(DQ,Q0),Ex,Exx,Rp,Rpx) :-
    (var(Strmx) ? genVarbl("DjOut",Strmx), Q0=[Strmx,..Q] | Q0=Q),
    genVarbl("DjStrm",DjStrm),
    dcgBody(Lhs,Map,Opts,LG,[],DjStrm,DjStrmx,[],LQ,Ex,Ex0,Rp,Rp0),
    dcgBody(Rhs,Map,Opts,RG,[],DjStrm,DjStrmy,LQ,DQ,Ex0,Ex1,Rp0,Rpx),
    genNewName(Map,"Disj",length(DQ)+2,DisProg),
    C1 = clse([DjStrm,..DQ],DisProg,[(inMode,DjStrm),(outMode,DjStrmx),..const0(DQ,biMode)],LG),
    C2 = clse([DjStrm,..DQ],DisProg,[(inMode,DjStrm),(outMode,DjStrmy),..const0(DQ,biMode)],RG),
    Exx = Ex1[DisProg->rel(DisProg,none,[C1,C2])].

  dcgOne:(canonNT,list[lyr],trOptions,list[pred],list[pred],term,term,list[term],list[term],map[term,rel],map[term,rel],report,report){}.
  dcgOne(Lhs,Map,Opts,[call(none,OneProg,[(inMode,Strm),(outMode,Strmx),..const0(DQ,biMode)]),..G],G,Strm,Strmx,Q,merge(DQ,Q),P,Px,Rp,Rpx) :-
    genVarbl("OneStm",OneStm),
    (var(Strmx) ? genVarbl("DjOut",Strmx) | true),
    dcgBody(Lhs,Map,Opts,LG,[neck],OneStm,OneStmx,[],DQ,P,P0,Rp,Rpx),
    genNewName(Map,"One",length(DQ)+2,OneProg),
    C1 = clse([OneStm,..DQ],OneProg,[(inMode,OneStm),(outMode,OneStmx),..const0(DQ,biMode)],LG),
    Px = P0[OneProg->rel(OneProg,none,[C1])].

  dcgNeg:(canonNT,list[lyr],trOptions,list[pred],list[pred],term,list[term],list[term],map[term,rel],map[term,rel],report,report){}.
  dcgNeg(Tst,Map,Opts,[call(none,NegProg,[(inMode,Strm),..const0(TQ,inMode)]),..G],G,Strm,Q,merge(TQ,Q),P,Px,Rp,Rpx) :-
    genVarbl("NegStrm",NegStrm),
    dcgBody(Tst,Map,Opts,TG,[],NegStrm,_,[],TQ,P,P0,Rp,Rpx),
    genNewName(Map,"Neg",length(TQ)+1,NegProg),
    C1 = clse([NegStrm,..TQ],NegProg,[(inMode,NegStrm),..const0(TQ,inMode)],TG<>[neck,fail]),
    C2 = clse([NegStrm,..TQ],NegProg,[(inMode,NegStrm),..const0(TQ,inMode)],[]),
    Px = P0[NegProg->rel(NegProg,none,[C1,C2])].

  dcgConditional:(canonNT,canonNT,canonNT,list[lyr],trOptions,list[pred],list[pred],term,term,list[term],list[term],map[term,rel],map[term,rel],report,report){}.
  dcgConditional(Tst,Lhs,Rhs,Map,Opts,[call(none,CondProg,[(inMode,Strm),(outMode,Strmx),..const0(DQ,biMode)]),..G],G,Strm,Strmx,Q,merge(DQ,Q),P,Px,Rp,Rpx) :-
    (var(Strmx) ? genVarbl("CndOut",Strmx) | true),
    genVarbl("CondStrm",CndStrm),
    dcgBody(Tst,Map,Opts,TG,[],CndStrm,CndStrm0,[],TQ,P,P0,Rp,Rp0),
    dcgBody(Lhs,Map,Opts,LG,[],CndStrm0,CndStrmx,TQ,LQ,P0,P1,Rp0,Rp1),
    dcgBody(Rhs,Map,Opts,RG,[],CndStrm,CndStrmy,LQ,DQ,P1,P2,Rp1,Rpx),
    genNewName(Map,"Cond",length(DQ)+2,CondProg),
    C1 = clse([CndStrm,..DQ],CondProg,[(inMode,CndStrm),(outMode,CndStrmx),..const0(DQ,biMode)],TG<>[neck,..LG]),
    C2 = clse([CndStrm,..DQ],CondProg,[(inMode,CndStrm),(outMode,CndStrmy),..const0(DQ,biMode)],RG),
    Px = P2[CondProg->rel(CondProg,none,[C1,C2])].

  dcgAhead:(canonNT,list[lyr],trOptions,list[pred],list[pred],term,list[term],list[term],map[term,rel],map[term,rel],report,report){}.
  dcgAhead(Tst,Map,Opts,[call(none,HdProg,[(inMode,Strm),..const0(TQ,inMode)]),..G],G,Strm,Q,merge(TQ,Q),P,Px,Rp,Rpx) :-
    genVarbl("HedStrm",HedStrm),
    dcgBody(Tst,Map,Opts,TG,[],HedStrm,_,[],TQ,P,P0,Rp,Rpx),
    genNewName(Map,"Hed",length(TQ)+1,HdProg),
    C1 = clse([HedStrm,..TQ],HdProg,[(inMode,HedStrm),..const0(TQ,inMode)],TG),
    Px = P0[HdProg->rel(HdProg,none,[C1])].

  pushTerminals:(list[(location,canonTerm,canonTerm)],list[lyr],trOptions,list[pred],list[pred],term,term,list[term],list[term],map[term,rel],map[term,rel],report,report){}.
  pushTerminals([],_,_,G,Gx,Strm,Strmx,Q,Q,Ex,Ex,Rp,Rp) :-
    joinStream(Strm,Strmx,G,Gx).
  pushTerminals([(Lc,SV,T),..More],Map,Opts,G,Gx,Strm,Strmx,Q,Qx,Ex,Exx,Rp,Rpx) :-
    genVarbl("NStrm",NStrm),
    trGoal(callCond(Lc,SV,[(inMode,mkCanon(Strm)),(biMode,T),(outMode,mkCanon(NStrm))]),G,G0,Q,Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    pushTerminals(More,Map,Opts,G0,Gx,NStrm,Strmx,[NStrm,..Q0],Qx,Ex0,Exx,Rp0,Rpx).

  mkCanon:(term)=>canonTerm.
  mkCanon(varbl(Nm))=>v(std,Nm).

  joinStream:(term,term,list[pred],list[pred]){}.
  joinStream(X,X,G,G).
  joinStream(Strm,Strmx,[unfy(none,Strm,Strmx),..Gx],Gx).

  transformOthers:(list[canonOther],list[lyr],trOptions,list[pred],map[term,rel],map[term,rel],report,report){}.
  transformOthers([],_,_,[],Rx,Rx,Rp,Rp).
  transformOthers([integrity(Lc,G),..Others],Map,Opts,[call(some(Lc::tloc),AssertName,[]),..Inits],P,Px,Rp,Rpx) :-
    collect(Others,isAssertion,Asserts,Rest),
    transformAssertions([integrity(Lc,G),..Asserts],Map,Opts,Lc,AssertName,P,P0,Rp,Rp0),
    transformOthers(Rest,Map,Opts,Inits,P0,Px,Rp0,Rpx).
  transformOthers([expShow(Lc,E),..Others],Map,Opts,[call(some(Lc::tloc),ShowName,[]),..Inits],P,Px,Rp,Rpx) :-
    collect(Others,isShow,Shows,Rest),
    transformShows([expShow(Lc,E),..Shows],Map,Opts,Lc,ShowName,P,P0,Rp,Rp0),
    transformOthers(Rest,Map,Opts,Inits,P0,Px,Rp0,Rpx).

  private isAssertion:(canonOther){}.
  isAssertion(integrity(_,_)).

  private isShow:(canonOther){}.
  isShow(expShow(_,_)).

  transformAssertions:(list[canonOther],list[lyr],trOptions,location,term,map[term,rel],map[term,rel],report,report){}.
  transformAssertions(Asserts,Map,Opts,Lc,prg(AssertNm,Arity),P,Px,Rp,Rpx) :-
    extraVars(Map,Extra),
    AssertNm = localName(layerName(Map),"@","assert"),
    transformClause(clause(Lc,"assert",[],foldRight(collectGoal,trueCond,Asserts)),Map,Opts,AssertNm,Arity,Extra,1,[ACl],[],P,P0,Rp,Rpx),
    Px = addCl(P0,ACl).

  collectGoal:(canonOther,canonCond)=>canonCond.
  collectGoal(integrity(_,G),trueCond) => G.
  collectGoal(integrity(_,G),O) => conjCond(G,O).

  transformShows:(list[canonOther],list[lyr],trOptions,location,term,map[term,rel],map[term,rel],report,report){}.
  transformShows(Shows,Map,Opts,Lc,prg(ShowNm,Arity),P,Px,Rp,Rpx) :-
    extraVars(Map,Extra),
    ShowNm = localName(layerName(Map),"@","show"),
    transformClause(clause(Lc,"show",[],(foldRight(collectShow,trueCond,Shows):canonCond)),Map,Opts,ShowNm,Arity,Extra,1,[SCl],[],P,P0,Rp,Rpx),
    Px = addCl(P0,SCl).

  collectShow:(canonOther,canonCond)=>canonCond.
  collectShow(expShow(Lc,S),trueCond) => callCond(Lc,v(Lc,"_logmsg"),[(inMode,S)]).
  collectShow(expShow(Lc,S),O) => conjCond(callCond(Lc,v(Lc,"_logmsg"),[(inMode,S)]),O).

  trLocation:(location) => canonTerm.
  trLocation(Lc) => tpl(Lc,tplLbl(3),[int(lineOf(Lc)),int(columnOf(Lc)),int(widthOf(Lc))]).

  thetaInit:(list[lyr],list[pred],map[term,rel],map[term,rel]){}.
  thetaInit(Map,Inits,P,Px) :-
    Px = addCl(P,clse([],prg(localName(layerName(Map),"@","init"),0),[],Inits<>[neck])).

  transformClass:(location,string,list[canonRule],tipe,list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformClass(Lc,Nm,Defs,Face,Map,Opts,P,Px,Rp,Rpx) :-
    labelName(Map,Nm,LclName),
    genClassMap(Map,Opts,Lc,LclName,Defs,Face,CMap,P,P1,Rp,Rp0)!,
    transformClassBody(Defs,CMap,Opts,P1,Px,Rp0,Rpx).

  labelName:(list[lyr],string,string){}.
  labelName(Map,Nm,LclName) :-
    lookupVarName(Map,Nm,Spec),
    makeLabelTerm(Spec,_,_,LclName).

  makeLabelTerm:(mapEntry,string,term,string){}.
  makeLabelTerm(localClass(LclName,Strct,_,LblVr,ThVr),LclName,cons(strct(Strct,2),[LblVr,ThVr]),LclName).
  makeLabelTerm(moduleClass(Access,Strct,0),Access,enum(Strct),Access).
  makeLabelTerm(moduleClass(Access,Strct,Ar),Access,cons(strct(Strct,0),[]),Access).
  makeLabelTerm(moduleImpl(Access,Strct),Access,Strct,Access).

  /* A class body of the form
  lbl(A1,..,Ak) <= {
    prog1 :- ...
  }
  is mapped to

  pkg#lbl(prog1(X1,..,Xm),Lb,Th) :- pkg#lbl@prog(X1,..,Xm,Lb,Th)

  together with the specific translations of prog1
  */
  transformClassBody:(list[canonRule],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformClassBody(Defs,Map,Opts,P,Px,Rp,Rpx) :-
    findClassBody(Defs,Stmts)!,
    transformClassDefs(Stmts,Map,Opts,P,Px,Rp,Rpx).
  transformClassBody(_,_,_,P,P,Rp,Rp).

  findClassBody:(list[canonRule],list[canonDef]){}.
  findClassBody(Defs,Stmts) :-
    clRule(_,_,_,theta(Stmts,_),_,_) in Defs.

  transformClassDefs:(list[canonDef],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformClassDefs([],_,_,Px,Px,Rp,Rp).
  transformClassDefs([Def,..Defs],Map,Opts,P,Px,Rp,Rpx) :-
    transformClassDef(Def,Map,Opts,P,P0,Rp,Rp0),
    transformClassDefs(Defs,Map,Opts,P0,Px,Rp0,Rpx).

  transformClassDef:(canonDef,list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformClassDef(funDef(Lc,Nm,Tp,Cx,Eqns),Map,Opts,P,Px,Rp,Rpx) :-
    transformFunction(funDef(Lc,Nm,Tp,Cx,Eqns),Map,Opts,P,P0,Rp,Rpx),
    closureAccess(Map,Nm,P0,Px).
  transformClassDef(relDef(Lc,Nm,Tp,Cx,Clses),Map,Opts,P,Px,Rp,Rpx) :-
    transformPredicate(relDef(Lc,Nm,Tp,Cx,Clses),Map,Opts,P,P0,Rp,Rpx),
    closureAccess(Map,Nm,P0,Px).
  transformClassDef(grammDef(Lc,Nm,Tp,Cx,Clses),Map,Opts,P,Px,Rp,Rpx) :-
    transformGrammar(grammDef(Lc,Nm,Tp,Cx,Clses),Map,Opts,P,P0,Rp,Rpx),
    closureAccess(Map,Nm,P0,Px).
  transformClassDef(varDef(Lc,Nm,_,_,Value,Cond),Map,Opts,P,Px,Rp,Rpx) :-
    transformDefn(Map,Opts,Lc,Nm,Cond,Value,P,P0,Rp,Rpx),
    varAccess(Map,Nm,P0,Px).
  transformClassDef(classDef(Lc,Nm,Tp,Cx,Defs,Face),Map,Opts,P,Px,Rp,Rpx) :-
    transformClass(Lc,Nm,Defs,Face,Map,Opts,P,P0,Rp,Rpx),
    classAccess(Map,Nm,P0,Px).

  enumAccess:(list[lyr],string,list[clse],list[clse]){}.
  enumAccess(Map,Name,[eqn(Extra,prg(AccessName,length(Extra)+1),const0(Extra,inMode),LamCons),..Rx],Rx) :-
    lookupVarName(Map,Name,Reslt),
    programAccess(Reslt,LclName,AccessName,_,0),
    extraVars(Map,Extra),
    (Extra=[] ? LamCons=enum(LclName) | LamCons=cons(strct(LclName,size(Extra)),Extra)).
  enumAccess(_,_,Rls,Rls).

  classAccess:(list[lyr],string,map[term,rel],map[term,rel]){}.
  classAccess(Map,Nm,P,Px) :-
    lookupVarName(Map,Nm,Spec),
    makeLabelTerm(Spec,Access,LblTerm,LclName),
    extraVars(Map,Extra),                              -- extra variables coming from labels
    Px = addCl(P,eqn([ThVr,LblVr]<>Extra,prg(layerName(Map),4),[(inMode,enum(Nm)),..const0(Extra,inMode)],LblTerm)).

  closureAccess:(list[lyr],string,map[term,rel],map[term,rel]){}.
  closureAccess(Map,Name,P,Px) :-
    lookupVarName(Map,Name,Reslt),
    programAccess(Reslt,_,_,Closure,_),
    genVarbl("This",ThVr),
    genVarbl("Lbl",LblVr),
    LamCons = cons(strct(Closure,2),[LblVr,ThVr]),
    Px = addCl(P,eqn([LblVr,ThVr],prg(layerName(Map),3),[(biMode,enum(Name)),(inMode,LblVr),(inMode,ThVr)],LamCons)).

  predClosureEntry:(list[lyr],option[tloc],string,string,integer,map[term,rel],map[term,rel]){}.
  predClosureEntry(Map,TLc,Prog,Closure,Arity,P,Px) :-
    extraVars(Map,Extra),
    Args = genVars(Arity),
    Q = Args<>Extra,
    CallStrct = cons(trCons("_call",Arity),Args),
    (Extra=[] ? ClosureCons = enum(Closure) | ClosureCons = cons(strct(Closure,size(Extra)),Extra)),
    Px = addCl(P,clse(Q,prg(Closure,3),[(biMode,CallStrct),(inMode,ClosureCons),(inMode,anon)],[call(TLc,prg(Prog,length(Q)),const0(Q,biMode))])).

  funClosureEntry:(list[lyr],option[tloc],string,string,integer,map[term,rel],map[term,rel]){}.
  funClosureEntry(Map,TLc,Prog,Closure,Arity,P,Px) :-
    extraVars(Map,Extra),
    Args = genVars(Arity),
    Q = Args<>Extra,
    CallStrct = cons(trCons("_call",Arity),Args),
    (Extra=[] ? ClosureCons = enum(Closure) | ClosureCons = cons(strct(Closure,size(Extra)),Extra)),
    Px = addCl(P,eqn(Q,prg(Closure,3),[(biMode,CallStrct),(inMode,ClosureCons),(inMode,anon)],invoke(TLc,prg(Prog,length(Q)),const0(Q,inMode)))).

  transformImplementation:(location,string,list[(typeMode,canonTerm)],canonTerm,tipe,list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  transformImplementation(Lc,ImplName,[],Body,Face,Map,Opts,P,Px,Rp,Rpx) :-
    transformClass(Lc,ImplName,[clRule(Lc,ImplName,[],Body,trueCond,Face)],Face,Map,Opts,P,Px,Rp,Rpx).
  transformImplementation(Lc,ImplName,Args,Body,Face,Map,Opts,P,Px,Rp,Rpx) :-
    transformClass(Lc,ImplName,[clRule(Lc,ImplName,Args,Body,trueCond,Face)],Face,Map,Opts,P,Px,Rp,Rpx).

  trArgPtns:(list[(typeMode,canonTerm)],list[(typeMode,term)],list[(typeMode,term)],list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trArgPtns([],Args,Args,Q,Q,_,_,Ex,Ex,Rp,Rp).
  trArgPtns([(M,P),..More],[(M,A),..Args],Ax,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trPtn(P,A,Q,Q0,Map,Opts,Ex,Ex0,Rp,Rp0)!,
    trArgPtns(More,Args,Ax,Q0,Qx,Map,Opts,Ex0,Exx,Rp0,Rpx).

  trPtns:(list[canonTerm],list[term],list[term],list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trPtns([],Args,Args,Q,Q,_,_,Ex,Ex,Rp,Rp).
  trPtns([P,..More],[A,..Args],Ax,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trPtn(P,A,Q,Q0,Map,Opts,Ex,Ex0,Rp,Rp0)!,
    trPtns(More,Args,Ax,Q0,Qx,Map,Opts,Ex0,Exx,Rp0,Rpx).

  trPtn:(canonTerm,term,list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trPtn(v(_,"this"),ThVr,Q,merge([ThVr],Q),Map,_,Ex,Ex,Rp,Rp) :-
    thisVar(Map,ThVr).
  trPtn(v(Lc,"this"),anon,Q,Q,_,_,Ex,Ex,Rp,Rpx) :-
    reportError("'this' not defined here",Lc,Rp,Rpx).
  trPtn(v(Lc,Nm),A,Q,Qx,Map,Opts,Ex,Ex,Rp,Rpx) :-
    trVarPtn(Lc,Nm,A,Q,Qx,Map,Opts,Rp,Rpx).
  trPtn(int(Ix),intgr(Ix),Q,Q,_,_,Ex,Ex,Rp,Rp).
  trPtn(flt(Ix),flot(Ix),Q,Q,_,_,Ex,Ex,Rp,Rp).
  trPtn(str(Ix),strng(Ix),Q,Q,_,_,Ex,Ex,Rp,Rp).
  trPtn(dot(Lc,Rc,Fld),Exp,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trDotExp(Lc,Rc,enum(Fld),Exp,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx).
  trPtn(tpl(_,Nm,Ptns),mkTpl(P),Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trPtns(Ptns,P,[],Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx).
  trPtn(apply(Lc,v(_,Nm),A),Ptn,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trArgPtns(A,Args,[],Q,Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    trPtnCallOp(Nm,some(Lc::tloc),Args,Ptn,Q0,Qx,Map,Opts,Ex0,Exx,Rp0,Rpx).
  trPtn(whre(P,C),guarded(Ptn,simplifyCond(conj(none,CC))),Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trPtn(P,Ptn,Q,Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    trGoal(C,CC,[],Q0,Qx,Map,Opts,Ex0,Exx,Rp0,Rpx).
  trPtn(XX,Exp,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(XX,Exp,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx).

  trVarPtn:(location,string,term,list[term],list[term],list[lyr],trOptions,report,report){}.
  trVarPtn(_,"_",anon,Q,Q,_,_,Rp,Rp).
  trVarPtn(Lc,Nm,A,Q,Qx,Map,_,Rp,Rpx) :-
    lookupVarName(Map,Nm,V),
    implementVarPtn(V,Nm,some(Lc::tloc),A,Q,Qx,Rp,Rpx).
  trVarPtn(Lc,Nm,anon,Q,Q,_,_,Rp,Rpx) :-
    reportError("'\(Nm)' not defined",Lc,Rp,Rpx).

  implementVarPtn:(mapEntry,string,option[tloc],term,list[term],list[term],report,report){}.
  implementVarPtn(localVar(Vn,_,ClVr,TVr),Nm,TLc,guarded(X,dfne(TLc,X,invoke(TLc,prg(Vn,2),[(inMode,ClVr),(inMode,TVr)]))),Q,merge([X,ClVr,TVr],Q),Rp,Rp) :- genVarbl(Nm,X).  -- instance var
  implementVarPtn(moduleVar(_,Vn,_),Nm,TLc,guarded(X,dfne(TLc,X,invoke(TLc,prg(Vn,0),[]))),Q,[X,..Q],Rp,Rp) :- genVarbl(Nm,X). -- module variable
  implementVarPtn(labelArg(N,ClVr,TVr),_,_,N,Q,merge([N,ClVr,TVr],Q),Rp,Rp).            -- argument from label
  implementVarPtn(moduleClass(Enum,_,0),_,_,enum(Enum),Q,Q,Rp,Rp).
  implementVarPtn(localClass(Enum,_,0,LbVr,ThVr),_,_,cons(strct(Enum,2),[LbVr,ThVr]),Q,merge([LbVr,ThVr],Q),Rp,Rp).
  implementVarPtn(inherit(Nm,_,LbVr,ThVr),_,_,cons(strct(Nm,2),[LbVr,ThVr]),Q,merge([LbVr,ThVr],Q),Rp,Rp).
  implementVarPtn(inheritField(Super,LblVr,ThVr),Nm,Lc,guarded(X,dfne(Lc,X,invoke(Lc,Super,[(inMode,enum(Nm)),(inMode,LblVr),(inMode,ThVr)]))),Q,merge([X,LblVr,ThVr],Q),Rp,Rp) :- genVarbl(Nm,X).
  implementVarPtn(notInMap,Nm,_,varbl(Nm),Q,merge([varbl(Nm)],Q),Rp,Rp).                -- variable local to clause

  trPtnCallOp:(string,option[tloc],list[(typeMode,term)],term,list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trPtnCallOp(Nm,TLc,Args,guarded(X,dfne(TLc,X,escvoke(TLc,Nm,Args))),Q,merge([X],Q),_,_,Ex,Ex,Rp,Rp) :-
    isEscape(Nm,_),
    genVarbl("Xa",X).
  trPtnCallOp(Nm,TLc,Args,Ptn,Q,Qx,Map,_,Ex,Ex,Rp,Rpx) :-
    lookupFunName(Map,Nm,Reslt),
    genVarbl("Xb",X),
    implementPtnCall(Reslt,Nm,TLc,X,Args,Ptn,Q,Qx,Rp,Rpx).

  implementPtnCall:(mapEntry,string,option[tloc],term,list[(typeMode,term)],term,list[term],list[term],report,report){}.
  implementPtnCall(localFun(Fn,_,_,Ar,LbVr,ThVr),_,TLc,X,Args,guarded(X,dfne(TLc,X,invoke(TLc,prg(Fn,size(Args)+2),Args<>[(inMode,LbVr),(inMode,ThVr)]))),Q,merge([X,LblVr,ThVr],Q),Rp,Rp).
  implementPtnCall(moduleFun(_,Fn,_,_,Ar),_,TLc,X,Args,guarded(X,dfne(TLc,X,invoke(TLc,prg(Fn,size(Args)),Args))),Q,merge([X],Q),Rp,Rp).
  implementPtnCall(inheritField(Super,LbVr,ThVr),Nm,TLc,X,Args,
    guarded(X,dfne(TLc,X,invoke(TLc,Super,[(inMode,cons(trCons(Nm,length(Args)),project1(Args))),(inMode,LbVr),(inMode,ThVr)]))),Q,merge([X,LbVr,ThVr],Q),Rp,Rp).
  implementPtnCall(moduleClass(Mdl,_,_),_,_,_,Args,cons(strct(Mdl,size(Args)),project1(Args)),Q,Q,Rp,Rp).
  implementPtnCall(localClass(Acc,_,_,LbVr,ThVr),_,_,_,Args,
        cons(strct(Acc,size(Args)+2),project1(Args)<>[LbVr,ThVr]),Q,merge([LbVr,ThVr],Q),Rp,Rp).
  implementPtnCall(inherit(Nm,_,LbVr,ThVr),_,_,_,Args,
        cons(strct(Nm,size(Args)),project1(Args)),Q,merge([LbVr,ThVr],Q),Rp,Rp).
  implementPtnCall(moduleImpl(_,Mdl),_,_,_,Args,cons(Mdl,project1(Args)),Q,Q,Rp,Rp).

  implementPkgRefPtn:(mapEntry,location,string,string,term,term,list[term],list[term],report,report){}.
  implementPkgRefPtn(moduleVar(_,Vn,_),Lc,_,_,Xi,guarded(Xi,dfne(none,Xi,invoke(some(Lc::tloc),prg(Vn,0),[]))),Q,[Xi,..Q],Rp,Rp).
  implementPkgRefPtn(moduleClass(Enum,_,0),_,_,_,_,enum(Enum),Q,Q,Rp,Rp).
  implementPkgRefPtn(_,Lc,Pkg,Rf,_,anon,Q,Q,Rp,Rpx) :-
    reportError("illegal access to \(Pkg)#\(Rf)",Lc,Rp,Rpx).

  trArgExps:(list[(typeMode,canonTerm)],list[(typeMode,term)],list[(typeMode,term)],list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trArgExps([],Args,Args,Q,Q,_,_,Ex,Ex,Rp,Rp).
  trArgExps([(M,P),..More],[(M,A),..Args],Extra,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(P,A,Q,Q0,Map,Opts,Ex,Ex0,Rp,Rp0)!,
    trArgExps(More,Args,Extra,Q0,Qx,Map,Opts,Ex0,Exx,Rp0,Rpx).

  trExps:(list[canonTerm],list[term],list[term],list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trExps([],Args,Args,Q,Q,_,_,Ex,Ex,Rp,Rp).
  trExps([P,..More],[A,..Args],Extra,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(P,A,Q,Q0,Map,Opts,Ex,Ex0,Rp,Rp0)!,
    trExps(More,Args,Extra,Q0,Qx,Map,Opts,Ex0,Exx,Rp0,Rpx).

  trExp:(canonTerm,term,list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trExp(v(_,"this"),ThVr,Q,merge([ThVr],Q),Map,_,Ex,Ex,Rp,Rp) :-
    thisVar(Map,ThVr).
  trExp(v(_,"stream"),ThVr,Q,merge([ThVr],Q),Map,_,Ex,Ex,Rp,Rp) :-
    streamVar(Map,ThVr).
  trExp(v(Lc,Nm),Vr,Q,Qx,Map,Opts,Ex,Ex,Rp,Rpx) :-
    trVarExp(Lc,Nm,Vr,Q,Qx,Map,Opts,Rp,Rpx).
  trExp(int(Ix),intgr(Ix),Q,Q,_,_,Ex,Ex,Rp,Rp).
  trExp(flt(Ix),flot(Ix),Q,Q,_,_,Ex,Ex,Rp,Rp).
  trExp(str(Ix),strng(Ix),Q,Q,_,_,Ex,Ex,Rp,Rp).
  trExp(tpl(_,_,A),mkTpl(TA),Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExps(A,TA,[],Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx).
  trExp(apply(Lc,Op,A),Exp,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trArgExps(A,Args,[],Q,Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    trExpCallOp(Lc,Op,Args,Exp,Q0,Qx,Map,Opts,Ex0,Exx,Rp0,Rpx).
  trExp(dot(Lc,Rec,Fld),Exp,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trDotExp(Lc,Rec,enum(Fld),Exp,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx).
  trExp(whre(E,C),simplifyGuard(guarded(Ce,simplifyCond(conj(none,Cx)))),Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(E,Ce,Q,Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    trGoal(C,Cx,[],Q0,Qx,Map,Opts,Ex0,Exx,Rp0,Rpx).
  trExp(condExp(Lc,T,L,R),invoke(some(Lc::tloc),CondFn,const0(LQ,inMode)),Q,merge(LQ,Q),Map,Opts,Ex,Exx,Rp,Rpx) :-
    trGoal(T,TG,[],[],Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    trExp(L,LRslt,Q0,Q1,Map,Opts,Ex0,Ex1,Rp0,Rp1),
    trExp(R,RRslt,Q1,LQ,Map,Opts,Ex1,Ex2,Rp1,Rpx),
    genNewName(Map,"condExp",length(LQ),CondFn),
    Cl1 = eqn(LQ,CondFn,const0(LQ,inMode),simplifyGuard(guarded(LRslt,simplifyCond(conj(none,TG))))),
    Cl2 = eqn(LQ,CondFn,const0(LQ,inMode),RRslt),
    Exx = Ex2[CondFn->rel(CondFn,some(Lc::tloc),[Cl1,Cl2])].
  trExp(lambda(Rl),Rslt,Q,Q,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trLambda(Rl,Rslt,merge(allLabelArgs(Map,[]),Q),Map,Opts,Ex,Exx,Rp,Rpx).
  trExp(XX,anon,Q,Q,_,_,Ex,Ex,Rp,Rpx) :-
    reportError("internal: cannot transform \(XX) as expression",std,Rp,Rpx).

  trDotExp:(location,canonTerm,term,term,list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trDotExp(Lc,v(_,Nm),C,Exp,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    lookupVarName(Map,Nm,Reslt),
    implementDotExp(Reslt,v(Lc,Nm),some(Lc::tloc),C,Exp,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx).
  trDotExp(Lc,v(_,Nm),C,ovoke(some(Lc::tloc),C,Rc,Rc),Q,Q0,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(v(Lc,Nm),Rc,Q,Q0,Map,Opts,Ex,Exx,Rp,Rpx).
  trDotExp(Lc,R,C,guarded(ovoke(some(Lc::tloc),C,Rec,Rec),unfy(some(Lc::tloc),Rc,Rec)),Q,Q0,Map,Opts,Ex,Exx,Rp,Rpx) :-
    genVarbl("R",Rec),
    trExp(R,Rc,[Rec,..Q],Q0,Map,Opts,Ex,Exx,Rp,Rpx).

  implementDotExp:(mapEntry,canonTerm,option[tloc],term,term,list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  implementDotExp(inherit(_,Super,ClVr,ThVr),_,TLc,C,invoke(TLc,C,[(inMode,ClVr),(inMode,ThVr)]),Q,merge([ClVr,ThVr],Q),_,_,Ex,Ex,Rp,Rp).
  implementDotExp(_,v(Lc,Nm),TLc,C,ovoke(TLc,C,Rc,Rc),Q,Q0,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(v(Lc,Nm),Rc,Q,Q0,Map,Opts,Ex,Exx,Rp,Rpx).
  implementDotExp(_,R,TLc,C,guarded(ovoke(TLc,C,Rec,Rec),unfy(TLc,Rc,Rec)),Q,Q0,Map,Opts,Ex,Exx,Rp,Rpx) :-
    genVarbl("R",Rec),
    trExp(R,Rc,[Rec,..Q],Q0,Map,Opts,Ex,Exx,Rp,Rpx).

  trVarExp:(location,string,term,list[term],list[term],list[lyr],trOptions,report,report){}.
  trVarExp(_,"_",anon,Q,Q,_,_,Rp,Rp).
  trVarExp(Lc,Nm,Exp,Q,Qx,Map,_,Rp,Rpx) :-
    lookupVarName(Map,Nm,V),
    implementVarExp(V,Lc,Nm,Exp,Q,Qx,Rp,Rpx).
  trVarExp(Lc,Nm,anon,Q,Q,_,_,Rp,Rpx) :-
    reportError("'\(Nm)' not defined",Lc,Rp,Rpx).

  implementVarExp:(mapEntry,location,string,term,list[term],list[term],report,report){}.
  implementVarExp(localVar(Vn,_,LblVr,ThVr),Lc,Nm,invoke(some(Lc::tloc),prg(Vn,2),[(inMode,LblVr),(inMode,ThVr)]),Q,merge([LblVr,ThVr],Q),Rp,Rp) :- genVarbl(Nm,X).
  implementVarExp(moduleVar(_,V,_),Lc,Nm,invoke(some(Lc::tloc),prg(V,0),[]),Q,Q,Rp,Rp) :- genVarbl(Nm,X).
  implementVarExp(labelArg(N,LblVr,ThVar),_,_,N,Q,merge([N,LblVr,ThVar],Q),Rp,Rp).
  implementVarExp(inheritField(Super,LblVr,ThVr),Lc,Nm,invoke(some(Lc::tloc),Super,[(inMode,enum(Nm)),(inMode,LbVr),(inMode,ThVr)]),Q,merge([LblVr,ThVr],Q),Rp,Rp).
  implementVarExp(moduleClass(Enum,_,0),_,_,enum(Enum),Q,Q,Rp,Rp).
  implementVarExp(moduleImpl(_,enum(Enum)),_,_,enum(Enum),Q,Q,Rp,Rp).
  implementVarExp(localClass(Enum,_,_,LbVr,ThVr),_,_,cons(strct(Enum,2),[LbVr,ThVr]),Q,merge([LbVr,ThVr],Q),Rp,Rp).
  implementVarExp(inherit(Nm,_,LbVr,ThVr),_,_,cons(strct(Nm,2),[LbVr,ThVr]),Q,merge([LbVr,ThVr],Q),Rp,Rp).
  implementVarExp(notInMap,_,Nm,varbl(Nm),Q,merge([varbl(Nm)],Q),Rp,Rp).
  implementVarExp(moduleFun(_,_,_,Acc,_),_,_,enum(Acc),Q,Q,Rp,Rp).
  implementVarExp(moduleRel(_,_,_,Acc,_),_,_,enum(Acc),Q,Q,Rp,Rp).
  implementVarExp(localFun(_,_,Closure,_,LblVr,ThVr),_,_,cons(strct(Closure,2),[LblVr,ThVr]),Q,Q,Rp,Rp).
  implementVarExp(_,Lc,Nm,varbl(Nm),Q,Q,Rp,Rpx) :-
    reportError("cannot handle \(Nm) in expression",Lc,Rp,Rpx).

  trExpCallOp:(location,canonTerm,list[(typeMode,term)],term,list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trExpCallOp(Lc,v(_,Nm),Args,escvoke(some(Lc::tloc),Nm,Args),Q,Q,_,_,Ex,Ex,Rp,Rp) :-
    isEscape(Nm,_).
  trExpCallOp(Lc,v(_,Nm),Args,Exp,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    lookupFunName(Map,Nm,Reslt),
    implementFunCall(Reslt,Lc,Nm,Args,Exp,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx).
  trExpCallOp(Lc,T,Args,ovoke(some(Lc::tloc),C,Cl,Cl),Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(T,Cl,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx),
    C = cons(trCons("_call",length(Args)),project1(Args)).

  implementFunCall:(mapEntry,location,string,list[(typeMode,term)],term,list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  implementFunCall(localFun(Fn,_,_,Ar,LblVr,ThVr),Lc,_,Args,invoke(some(Lc::tloc),prg(Fn,size(Args)+2),Args<>[(inMode,LblVr),(inMode,ThVr)]),Q,merge([LblVr,ThVr],Q),_,_,Ex,Ex,Rp,Rp).
  implementFunCall(moduleFun(_,Fn,_,_,Ar),Lc,_,Args,invoke(some(Lc::tloc),prg(Fn,size(Args)),Args),Q,Q,_,_,Ex,Ex,Rp,Rp).
/*
  implementFunCall(inheritField(Super,LblVr,ThVr),Lc,Nm,Args,invoke(some(Lc::tloc),Super,[cons(trCons(Nm,length(Args)),Args),LblVr,ThVr]),Q,merge([LblVr,ThVr],Q),_,_,Ex,Ex,Rp,Rp).
*/
  implementFunCall(moduleClass(Mdl,_,_),_,_,Args,cons(strct(Mdl,size(Args)),project1(Args)),Q,Q,_,_,Ex,Ex,Rp,Rp).
  implementFunCall(localClass(Mdl,_,_,LbVr,ThVr),_,_,Args,cons(strct(Mdl,size(Args)+2),project1(Args)<>[LbVr,ThVr]),Q,merge([Lbvr,ThVr],Q),_,_,Ex,Ex,Rp,Rp).
  implementFunCall(inherit(Mdl,_,LbVr,ThVr),_,_,Args,
        cons(strct(Mdl,size(Args)),project1(Args)),Q,merge([LbVr,ThVr],Q),_,_,Ex,Ex,Rp,Rp).
  implementFunCall(moduleImpl(_,Mdl),_,_,[],Mdl,Q,Q,_,_,Ex,Ex,Rp,Rp).
  implementFunCall(moduleImpl(_,Mdl),_,_,Args,cons(Mdl,project1(Args)),Q,Q,_,_,Ex,Ex,Rp,Rp).

  implementPkgRefExp:(mapEntry,location,string,string,term,list[term],list[term],report,report){}.
  implementPkgRefExp(moduleVar(_,Vn,_),Lc,_,_,invoke(some(Lc::tloc),prg(Vn,0),[]),Q,Q,Rp,Rp).
  implementPkgRefExp(moduleClass(Enum,_,0),_,_,_,enum(Enum),Q,Q,Rp,Rp).
  implementPkgRefExp(_,Lc,Pkg,Ref,anon,Q,Q,Rp,Rpx) :-
    reportError("illegal access to \(Pkg)#\(Ref)",Lc,Rp,Rpx).

  trLambda:(canonRule,term,list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
   -- We build $$(_call(Args<>Rep),$$(Free),_) :- Cond, !, replacement
  trLambda(equation(Lc,Nm,A,Exp,Cond),Closure,Q,Map,Opts,Ex,Exx,Rp,Rpx) :-
    FreeVars = freeVarsInRule(equation(Lc,Nm,A,Exp,Cond),Q,[]),
    genNewName(Map,Nm,3,prg(Lam,_)),
    trArgPtns(A,Args,[],[],Q1,Map,Opts,Ex,Ex0,Rp,Rp0), -- head of lambda
    trGoal(Cond,PreGx,[],Q1,Q2,Map,Opts,Ex0,Ex1,Rp0,Rp1),       -- condition goals
    trExp(Exp,Rep,Q2,Q3,Map,Opts,Ex1,Ex2,Rp1,Rpx),      -- replacement expression
    Closure = mkClosure(Lam,FreeVars),
    LmPrg = prg(Lam,3),
    Code = [eqn(merge(FreeVars,Q3),LmPrg,[(inMode,cons(trCons("_call",size(Args)),project1(Args))),(inMode,Closure),(inMode,anon)],simplifyGuard(guarded(Rep,simplifyCond(conj(none,PreGx)))))],
    Exx = Ex2[LmPrg->rel(LmPrg,none,Code)].
  trLambda(clause(Lc,Nm,A,Cond),Closure,Q,Map,Opts,Ex,Exx,Rp,Rpx) :-
    FreeVars = freeVarsInRule(clause(Lc,Nm,A,Cond),Q,[]),
    genNewName(Map,Nm,3,prg(Lam,_)),
    trArgPtns(A,Args,[],[],Q1,Map,Opts,Ex,Ex0,Rp,Rp0), -- head of lambda
    trGoal(Cond,Goals,[],Q1,Q2,Map,Opts,Ex0,Ex1,Rp0,Rpx),       -- condition goals
    Closure = mkClosure(Lam,FreeVars),
    LmPrg = prg(Lam,3),
    Exx = Ex1[LmPrg->rel(LmPrg,none,[clse(merge(FreeVars,Q2),LmPrg,[(biMode,cons(trCons("_call",size(Args)),project1(Args))),(inMode,Closure),(inMode,anon)],Goals)])].
  trLambda(grRule(Lc,Nm,A,grTerms(PB),Body),Closure,Q,Map,Opts,Ex,Exx,Rp,Rpx) :-
    FreeVars = freeVarsInRule(grRule(Lc,Nm,A,grTerms(PB),Body),Q,[]),
    genNewName(Map,Nm,3,prg(Lam,_)),
    trArgPtns(A,Args,[],[],Q1,Map,ClOpts,Ex,Ex0,Rp,Rp0),  -- head args
    genVarbl("StIn",StIn),
    dcgBody(Body,Map,Opts,Goals,PostG,StIn,StOut,[StIn,..Q1],Q2,Ex0,Ex1,Rp0,Rp1), -- grammar body
    pushTerminals(PB,Map,Opts,PostG,[],StOut,StX,Q2,Q4,Ex1,Ex2,Rp1,Rpx),     -- push back
    Closure = mkClosure(Lam,FreeVars),
    LmPrg = prg(Lam,3),
    CallStrct = cons(trCons("_call",size(Args)+2),[StIn,StX,..project1(Args)]),
    Exx = Ex2[LmPrg->rel(LmPrg,none,[clse(merge(FreeVars,Q4),LmPrg,[(biMode,CallStrct),(inMode,Closure),(inMode,anon)],Goals)])].

  mkClosure:(string,list[term])=>term.
  mkClosure(Lam,[]) => enum(Lam).
  mkClosure(Lam,FreeVars) => cons(strct(Lam,size(FreeVars)),FreeVars).

  trGoal:(canonCond,list[pred],list[pred],list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trGoal(trueCond,Goals,Goals,Q,Q,_,_,Ex,Ex,Rp,Rp).
  trGoal(falseCond,[fail,..Rest],Rest,Q,Q,_,_,Ex,Ex,Rp,Rp).
  trGoal(conjCond(L,R),Goals,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trGoal(L,Goals,G0,Q,Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    trGoal(R,G0,Gx,Q0,Qx,Map,Opts,Ex0,Exx,Rp0,Rpx).
  trGoal(disjCond(L,R),[call(none,DisjPr,const0(LQ,biMode)),..Gx],Gx,Q,merge(LQ,Q),Map,Opts,Ex,Exx,Rp,Rpx) :-
    trGoal(L,LG,[],[],Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    trGoal(R,RG,[],Q0,LQ,Map,Opts,Ex0,Ex1,Rp0,Rpx),
    genNewName(Map,"or",length(LQ),DisjPr),
    Cl1 = clse(LQ,DisjPr,const0(LQ,biMode),LG),
    Cl2 = clse(LQ,DisjPr,const0(LQ,biMode),RG),
    Exx = Ex1[DisjPr->rel(DisjPr,none,[Cl1,Cl2])].
  trGoal(condCond(T,L,R),[call(none,CondPr,const0(LQ,biMode)),..Gx],Gx,Q,merge(LQ,Q),Map,Opts,Ex,Exx,Rp,Rpx) :-
    trGoal(T,TG,[],[],Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    trGoal(L,LG,[],Q0,Q1,Map,Opts,Ex0,Ex1,Rp0,Rp1),
    trGoal(R,RG,[],Q1,LQ,Map,Opts,Ex1,Ex2,Rp1,Rpx),
    genNewName(Map,"cond",length(LQ),CondPr),
    Cl1 = clse(LQ,CondPr,const0(LQ,biMode),TG<>[neck,..LG]),
    Cl2 = clse(LQ,CondPr,const0(LQ,biMode),RG),
    Exx = Ex2[CondPr->rel(CondPr,none,[Cl1,Cl2])].
  trGoal(oneCond(T),[call(none,OnePr,const0(LQ,biMode)),..Gx],Gx,Q,merge(LQ,Q),Map,Opts,Ex,Exx,Rp,Rpx) :-
    trGoal(T,TG,[neck],[],LQ,Map,Opts,Ex,Ex0,Rp,Rpx),
    genNewName(Map,"one",length(LQ),OnePr),
    Cl1 = clse(LQ,OnePr,const0(LQ,biMode),TG),
    Exx = Ex0[OnePr->rel(OnePr,none,[Cl1])].
  trGoal(negCond(T),[call(none,NegPr,const0(LQ,inMode)),..Gx],Gx,Q,merge(LQ,Q),Map,Opts,Ex,Exx,Rp,Rpx) :-
    trGoal(T,TG,[],[],LQ,Map,Opts,Ex,Ex0,Rp,Rpx),
    genNewName(Map,"neg",length(LQ),NegPr),
    Cl1 = clse(LQ,NegPr,const0(LQ,inMode),TG<>[neck,fail]),
    Cl2 = clse(LQ,NegPr,const0(LQ,inMode),[]),
    Exx = Ex0[NegPr->rel(NegPr,none,[Cl1,Cl2])].
  trGoal(forallCond(L,R),[call(none,APr,AArgs),..Gx],Gx,Q,merge(LQ,Q),Map,Opts,Ex,Exx,Rp,Rpx) :-
    trGoal(L,LG,[call(none,BPr,AArgs)],[],Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    trGoal(R,RG,[],Q0,LQ,Map,Opts,Ex0,Ex1,Rp0,Rpx),
    QAr = length(LQ),
    AArgs = const0(LQ,inMode),
    genNewName(Map,"forallA",QAr,APr),
    genNewName(Map,"forallB",QAr,BPr),
    ACl1 = clse(LQ,APr,AArgs,LG<>[neck,fail]),
    ACl2 = clse(LQ,APr,AArgs,[]),
    BCl1 = clse(LQ,BPr,AArgs,RG<>[neck,fail]),
    BCl2 = clse(LQ,BPr,AArgs,[]),
    Ex2 = Ex1[APr->rel(APr,none,[ACl1,ACl2])],
    Exx = Ex2[BPr->rel(BPr,none,[BCl1,BCl2])].
  trGoal(unifyCond(Lc,L,R),G,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    lineDebug(Lc,G,[unfy(some(Lc::tloc),Lx,Rx),..Gx],Opts),
    trExp(L,Lx,Q,Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    trExp(R,Rx,Q0,Qx,Map,Opts,Ex0,Exx,Rp0,Rpx).
  trGoal(phraseCond(Lc,NT,Strm,Rem),G,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(Strm,StIn,Q,Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    lineDebug(Lc,G,G2,Opts),
    dcgBody(NT,Map,Opts,G2,G3,StIn,StOut,Q0,Q2,Ex0,Ex1,Rp0,Rp1), -- grammar body
    trExp(Rem,Out,Q2,Qx,Map,Opts,Ex1,Exx,Rp1,Rpx),
    joinStream(Out,StOut,G3,Gx).
  trGoal(callCond(Lc,Pred,Args),G,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    lineDebug(Lc,G,G3,Opts),
    trArgExps(Args,AG,[],Q,Q0,Map,Opts,Ex,Ex0,Rp,Rp0),
    trGoalCall(Pred,AG,G3,Gx,Q0,Qx,Map,Opts,Ex0,Exx,Rp0,Rpx).
  trGoal(isTrue(E),[unfy(none,Exp,enum("lo.core#true")),..Gx],Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(E,Exp,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx).

  trGoalCall:(canonTerm,list[(typeMode,term)],list[pred],list[pred],list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trGoalCall(v(Lc,Nm),Args,[ecall(some(Lc::tloc),Nm,Args),..Tail],Tail,Q,Q,_,_,Ex,Ex,Rp,Rp) :-
    isEscape(Nm,_).
  trGoalCall(v(Lc,Nm),Args,G,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    lookupRelName(Map,Nm,RSpec),
    implementGoalCall(RSpec,Lc,Nm,Args,G,Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx).
  trGoalCall(Pred,Args,[ocall(none,cons(trCons("_call",size(Args)),project1(Args)),PrdClos,PrdClos),..Gx],Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(Pred,PrdClos,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx).

  implementGoalCall:(mapEntry,location,string,list[(typeMode,term)],list[pred],list[pred],list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  implementGoalCall(localRel(Fn,_,_,Ar,LblVr,ThVr),Lc,_,Args,[call(some(Lc::tloc),prg(Fn,size(Args)+2),Args<>[(inMode,LblVr),(inMode,ThVr)]),..Tail],Tail,Q,merge([LblVr,ThVr],Q),_,_,Ex,Ex,Rp,Rp).
  implementGoalCall(moduleRel(_,Fn,_,_,Ar),Lc,_,Args,[call(some(Lc::tloc),prg(Fn,size(Args)),Args),..Tail],Tail,Q,Q,_,_,Ex,Ex,Rp,Rp).
  implementGoalCall(inheritField(Super,LblVr,ThVr),Lc,Pred,Args,
        [call(some(Lc::tloc),Super,[(biMode,cons(trCons(Pred,length(Args)),project1(Args))),(inMode,LblVr),(inMode,ThVr)]),..Tail],Tail,Q,merge([LblVr,ThVr],Q),_,_,Ex,Ex,Rp,Rp).
  implementGoalCall(notInMap,Lc,Pred,Args,[ocall(some(Lc::tloc),cons(trCons("_call",size(Args)),project1(Args)),PrdClos,PrdClos),..Gx],Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(v(Lc,Pred),PrdClos,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx).
  implementGoalCall(_,Lc,Pred,_,G,G,Q,Q,_,_,Ex,Ex,Rp,Rpx) :-
    reportError("cannot handle source for \(Pred)",Lc,Rp,Rpx).

  trGoalDot:(location,canonTerm,term,list[pred],list[pred],list[term],list[term],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  trGoalDot(_,v(Lc,Nm),C,[call(some(Lc::tloc),Super,[(biMode,C),(inMode,LbVr),(inMode,ThVr)]),..Gx],Gx,Q,merge([LbVr,ThVr],Q),Map,_,Ex,Ex,Rp,Rp) :-
    lookupVarName(Map,Nm,inherit(_,Super,LbVr,ThVr)).
  trGoalDot(Lc,Rec,C,[ocall(some(Lc::tloc),C,NR,NR),..Gx],Gx,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx) :-
    trExp(Rec,NR,Q,Qx,Map,Opts,Ex,Exx,Rp,Rpx).

  genClassMap:(list[lyr],trOptions,location,string,list[canonRule],tipe,list[lyr],map[term,rel],map[term,rel],report,report){}.
  genClassMap(Map,Opts,Lc,LclName,Defs,Face,[lyr(LclName,List,LblGl,LbVr,ThVr,anon),..Map],P,Px,Rp,Rpx) :-
    genVarbl("LbV",LbVr),
    genVarbl("ThV",ThVr),
    pickAllFieldsFromFace(Face,Fields),
    makeClassMtdMap(Defs,LclName,LbVr,ThVr,LblGl,[],L0,Fields,Map,Opts,P,P0,Rp,Rp0),
    makeInheritanceMap(Defs,LclName,LbVr,ThVr,Map,Opts,L0,List,Fields,P0,Px,Rp0,Rpx).

  pickAllFieldsFromFace:(tipe,list[(string,tipe)]){}.
  pickAllFieldsFromFace(Tp,Fields) :-
    moveQuants(Tp,_,QTp),
    moveConstraints(QTp,_,faceType(Fields)).

  makeClassMtdMap:(list[canonRule],string,term,term,list[pred],list[(string,mapEntry)],
      list[(string,mapEntry)],list[(string,tipe)],list[lyr],trOptions,map[term,rel],map[term,rel],report,report){}.
  makeClassMtdMap([],_,_,_,_,List,List,_,_,_,Ex,Ex,Rp,Rp).
  makeClassMtdMap([clRule(Lc,_,[],theta(Stmts,_),_,_),..Rules],LclName,LbVr,ThVr,LblGl,List,Lx,Fields,Map,Opts,Ex,Exx,Rp,Rpx) :-
    collectMtds(Stmts,LclName,LbVr,ThVr,List,L0,Fields),
    collectLabelVars([],LbVr,ThVr,L0,L1),
    extraVars(Map,Extra),
    makeLblTerm(LclName,Extra,LblTerm),
    (Extra =[] ? LblGl = [] | LblGl = [unfy(some(Lc::tloc),LbVr,LblTerm)]),
    makeClassMtdMap(Rules,LclName,LbVr,ThVr,_,L1,Lx,Fields,Map,Opts,Ex,Exx,Rp,Rpx).
  makeClassMtdMap([clRule(Lc,_,Hd,theta(Stmts,_),_,_),..Rules],LclName,LbVr,ThVr,[unfy(some(Lc::tloc),LbVr,LblTerm)],List,Lx,Fields,Map,Opts,Ex,Exx,Rp,Rpx) :-
    collectMtds(Stmts,LclName,LbVr,ThVr,List,L0,Fields),
    extraVars(Map,Extra),
    trArgPtns(Hd,Args,const0(Extra,inMode),[],Vs,Map,Opts,Ex,Ex0,Rp,Rp0),
    collectLabelVars(Vs,LbVr,ThVr,L0,L1),
    makeLblTerm(LclName,project1(Args),LblTerm),
    makeClassMtdMap(Rules,LclName,LbVr,ThVr,_,L1,Lx,Fields,Map,Opts,Ex0,Exx,Rp0,Rpx).
  makeClassMtdMap([clRule(Lc,_,_,_,_,_),..Rules],LclName,LbVr,ThVr,LblGl,List,L0,Fields,Map,Opts,Ex,Exx,Rp,Rpx) :-
    makeClassMtdMap(Rules,LclName,LbVr,ThVr,LblGl,List,L0,Fields,Map,Opts,Ex,Exx,Rp,Rpx).

  makeLblTerm:(string,list[term],term){}.
  makeLblTerm(Nm,[],enum(Nm)).
  makeLblTerm(Nm,Args,cons(strct(Nm,size(Args)),Args)).

  makeInheritanceMap:(list[canonRule],string,term,term,list[lyr],trOptions,list[(string,mapEntry)],
      list[(string,mapEntry)],list[(string,tipe)],map[term,rel],map[term,rel],report,report){}.
  makeInheritanceMap([],_,_,_,_,_,List,List,_,Px,Px,Rp,Rp).
  makeInheritanceMap([clRule(_,_,_,theta(_,_),_,_),..Defs],LclName,LbVr,ThVr,Map,Opts,List,Lx,Fields,P,Px,Rp,Rpx) :-
    makeInheritanceMap(Defs,LclName,LbVr,ThVr,Map,Opts,List,Lx,Fields,P,Px,Rp,Rpx).
  makeInheritanceMap([clRule(Lc,_,Ags,R,_,FaceTp),..Defs],LclName,LbVr,ThVr,Map,Opts,List,Lx,Fields,P,Prx,Rp,Rpx) :-
    pickAllFieldsFromFace(FaceTp,InhFields),
    extraVars(Map,Extra),
    genVarbl("CV",CV),
    trArgPtns(Ags,Args,const0(Extra,inMode),Extra,Q0,Map,Opts,P,Pr0,Rp,Rp0),
    trExp(R,Repl,Q0,Q1,Map,Opts,Pr0,Pr1,RP0,Rp1),
    makeLblTerm(LclName,project1(Args),Lbl),
    genNewName(Map,"^",3,Super),
    Pr2 = addCl(Pr1,eqn(merge(Q1,[CV,ThVr]),Super,[(biMode,CV),(inMode,Lbl),(inMode,ThVr)],ovoke(some(Lc::tloc),CV,Repl,ThVr))),
    makeInheritFields(InhFields,LclName,some(Lc::tloc),Super,Fields,Map,LbVr,ThVr,Pr2,Pr3,List,L1),
    makeInheritanceMap(Defs,LclName,LbVr,ThVr,Map,Opts,L1,Lx,Fields,Pr3,Prx,Rp1,Rpx).

  makeInheritFields:(list[(string,tipe)],string,option[tloc],term,list[(string,tipe)],list[lyr],term,term,
        map[term,rel],map[term,rel],list[(string,mapEntry)],list[(string,mapEntry)]){}.
  makeInheritFields([],_,_,_,_,_,_,_,Entry,Entry,List,List).
  makeInheritFields([(Nm,Tp),..InhFields],LclName,TLc,Super,Fields,Map,LbVr,ThVr,Entry,En,List,Lx) :-
    (Nm,_) in List,
    \+ isPredType(Tp), -- we dont allow overriding of relations
    makeInheritFields(InhFields,LclName,TLc,Super,Fields,Map,LbVr,ThVr,Entry,En,List,Lx).
  makeInheritFields([(Nm,Tp),..InhFields],LclName,TLc,Super,Fields,Map,LbVr,ThVr,Entry,En,List,Lx) :-
    inheritEqn(Nm,Tp,TLc,LclName,Map,Super,Entry,En0),
    makeInheritFields(InhFields,LclName,TLc,Super,Fields,Map,LbVr,ThVr,En0,En,[(Nm,inheritField(Super,LbVr,ThVr)),..List],Lx).

  inheritEqn:(string,tipe,option[tloc],string,list[lyr],term,map[term,rel],map[term,rel]){}.
  inheritEqn(Name,Tp,TLc,Prefix,Map,Super,P,Px) :-
    genVarbl("Clos",ClV),
    genVarbl("This",ThVr),
    genVarbl("Lbl",LbVr),
    Px =addCl(P,eqn([ClV,LblVr,ThVr],prg(Prefix,3),[(biMode,enum(Name)),(inMode,LbVr),(inMode,ThVr)],invoke(TLc,Super,[(biMode,enum(Name)),(inMode,LbVr),(inMode,ThVr)]))).

  collectMtds:(list[canonDef],string,term,term,list[(string,mapEntry)],list[(string,mapEntry)],list[(string,tipe)]){}.
  collectMtds([],_,_,_,List,List,_).
  collectMtds([Entry,..Defs],OuterNm,LbVr,ThVr,List,Lx,Fields) :-
    collectMtd(Entry,OuterNm,LbVr,ThVr,List,L0),
    collectMtds(Defs,OuterNm,LbVr,ThVr,L0,Lx,Fields).

  collectMtd:(canonDef,string,term,term,list[(string,mapEntry)],list[(string,mapEntry)]){}.
  collectMtd(funDef(_,Nm,Tp,_,_),OuterNm,Lbl,ThV,List,
        [(Nm,localFun(localName(OuterNm,"@",Nm),localName(OuterNm,"%",Nm),localName(OuterNm,"^",Nm),effectiveArity(Tp,0),Lbl,ThV)),..List]).
  collectMtd(relDef(_,Nm,Tp,_,_),OuterNm,Lbl,ThV,List,
        [(Nm,localRel(localName(OuterNm,"@",Nm),localName(OuterNm,"%",Nm),localName(OuterNm,"^",Nm),effectiveArity(Tp,0),Lbl,ThV)),..List]).
  collectMtd(grammDef(_,Nm,Tp,_,_),OuterNm,Lbl,ThV,List,
        [(Nm,localRel(localName(OuterNm,"@",Nm),localName(OuterNm,"%",Nm),localName(OuterNm,"^",Nm),effectiveArity(Tp,0),Lbl,ThV)),..List]).
  collectMtd(varDef(_,Nm,_,_,_,_),OuterNm,Lbl,ThV,List,[(Nm,localVar(localName(OuterNm,"@",Nm),localName(OuterNm,"%",Nm),Lbl,ThV)),..List]).
  collectMtd(classDef(_,Nm,Tp,_,_,_),OuterNm,Lbl,ThV,List,
        [(Nm,localClass(localName(OuterNm,"@",Nm),localName(OuterNm,"@",Nm),0,Lbl,ThV)),..List]) :- \+ isClassType(Tp).
  collectMtd(classDef(_,Nm,Tp,_,_,_),OuterNm,Lbl,ThV,List,
        [(Nm,localClass(localName(OuterNm,"@",Nm),localName(OuterNm,"@",Nm),effectiveArity(Tp,0),Lbl,ThV)),..List]).

  collectLabelVars:(list[term],term,term,list[(string,mapEntry)],list[(string,mapEntry)]){}.
  collectLabelVars([],_,_,List,List).
  collectLabelVars([varbl(Nm),..Args],LbVr,ThVr,List,Lx) :-
    collectLabelVars(Args,LbVr,ThVr,[(Nm,labelArg(varbl(Nm),LbVr,ThVr)),..List],Lx).

  public implementation coercion[location,tloc] <= {
    _coerce(loc(Line,Off,Col,Len,Pth)) => tloc(Line,Off,Col,Len).
  }

  addCl:(map[term,rel],clse)=>map[term,rel].
  addCl(M,Cl) => (present(M,Nm,rel(_,Lc,Clses)) ?
          M[Nm->rel(Nm,Lc,Clses<>[Cl])] |
          M[Nm->rel(Nm,none,[Cl])]) :-
    Nm = clName(Cl).
}
