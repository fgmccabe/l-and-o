lo.comp.code.unify{
  import lo.

  import lo.comp.errors.
  import lo.comp.code.code.
  import lo.comp.code.instructions.
  import lo.comp.code.registers.
  import lo.comp.term.

  public unifyHead:(list[term],map[string,varDesc],list[litrl],varSet,logical,varSet,map[string,varDesc],list[litrl],list[instruction]){}.
  unifyHead(Args,D0,Refs,Used,Last,Usx,Dx,Rfx,Inx) :-
    unifyArgs(Args,1,D0,Dx,Used,Last,Usx,Refs,Rfx,Inx).

  unifyArgs:(list[term],integer,map[string,varDesc],map[string,varDesc],varSet,logical,varSet,list[litrl],list[litrl],list[instruction]){}.
  unifyArgs([],_,D,D,V,_,V,Lt,Lt,[]).
  unifyArgs([e],Rg,D,Dx,V,Last,Vx,Lt,Ltx,unifyTerm(e,true,aReg(Rg),D,Dx,V,Vx,Lt,Ltx,Last)).
  unifyArgs([e,..l],Rg,D,Dx,V,Last,Vx,Lt,Ltx,HCode<>RCode) :-
    HCode = unifyTerm(e,true,aReg(Rg),D,D0,V,V0,Lt,Lt0,Last),
    unifyArgs(l,Rg+1,D0,Dx,V0,Last,Vx,Lt0,Ltx,RCode).

  public unifyTerm:(term,logical,addr,map[string,varDesc],map[string,varDesc],
        varSet,varSet,list[litrl],list[litrl],logical) => list[instruction].
  unifyTerm(anon,_,Src,D,D,VS,VS,Lts,Lts,_) => skipOver(Src).
  unifyTerm(T,Top,Src,D,D,VS,VSx,Lt,Ltx,_) => unifyLit(Lb,Top,Src,VS,VSx) :- isGroundTerm(T), accessLiteral(T,Lb,Lt,Ltx).
  unifyTerm(varbl(Nm),_,Src,D,Dx,VS,Vx,Lt,Lt,last) => unifyVar(Entry,Src,D,Dx,VS,Vx,last) :- present(D,Nm,Entry).
  unifyTerm(cons(Op,Els),Top,Src,D,Dx,V,Vx,Lt,Ltx,Last) => unifyOp(Lb,Src,Top,V,V0) <> unifyEls(Els,false,D,Dx,V,Vx,Lt0,Ltx) :-
      accessLiteral(Op,Lb,Lt,Lt0).

  unifyEls:(list[term],logical,map[string,varDesc],map[string,varDesc],varSet,varSet,list[litrl],list[litrl]) => list[instruction].
  unifyEls([],_,D,D,V,V,Lt,Lt) => [].
  unifyEls([e],Top,D,Dx,V,Vx,Lt,Ltx) => unifyTerm(e,Top,sReg,D,Dx,V,Vx,Lt,Ltx,true).
  unifyEls([e,..l],Top,D,Dx,V,Vx,Lt,Ltx) => unifyTerm(e,Top,sReg,D,D0,V,V0,Lt,Lt0,false)<>unifyEls(l,Top,D0,Dx,V0,Vx,Lt0,Ltx).

  unifyVar:(varDesc,addr,map[string,varDesc],map[string,varDesc],varSet,varSet,logical) => list[instruction].
  unifyVar(varDesc(_,_,_,voidAddr,_),sReg,D,D,V,V,_) => [iClS].
  unifyVar(varDesc(_,_,_,voidAddr,_),_,D,D,V,V,_) => [].
  unifyVar(varDesc(_,inited,_,Src,_),Dst,D,D,V,Vx,Last) => Ins :- unifyVr(Src,Dst,V,Ins,Vx).
  unifyVar(varDesc(Nm,notInited,Def,Src,Wh),Dst,D,D[Nm->varDesc(Nm,inited,Def,Src,Wh)],V,Vx,Last) => Ins :- moveVr(Src,Dst,V,Last,Ins,Vx).

  skipOver:(addr) => list[instruction].
  skipOver(voidAddr) => [].
  skipOver(aReg(_)) => [].
  skipOver(yReg(_,_)) => [].
  skipOver(sReg) => [iClS].

  unifyLit:(string,logical,addr,varSet,varSet) => list[instruction].
  unifyLit(_,_,voidAddr,Vs,Vs) => [].
  unifyLit(Lb,true,aReg(Rg),VS,freeAReg(VS,Rg)) => [iUAlit(Rg,Lb)].
  unifyLit(Lb,false,aReg(Rg),VS,VS) => [iUAlit(Rg,Lb)].
  unifyLit(Lb,_,yReg(Lc,_),VS,VS) => [iMAY(0,Lc),iUAlit(0,Lb)].
  unifyLit(Lb,_,sReg,VS,VS) => [iUSlit(Lb)].

  public accessLiteral:(term,string,list[litrl],list[litrl]){}.
  accessLiteral(T,Lb,Lt,Lt) :- litrl(Lb,T) in Lt.
  accessLiteral(strng(Sx),Lb,Lts,[litrl(Lb,strng(Sx)),..Lts]) :- Lb = _str_gen(Sx).
  accessLiteral(enum(Sx),Lb,Lts,[litrl(Lb,enum(Sx)),..Lts]) :- Lb = _str_gen(Sx).
  accessLiteral(T,Lb,Lts,[litrl(Lb,T),..Lts]) :- Lb = _str_gen("L").

  unifyOp:(string,addr,logical,varSet,varSet) => list[instruction].
  unifyOp(Lb,aReg(Rg),true,V,freeAReg(V,Rg)) => [iUAcns(Rg,Lb)].
  unifyOp(Lb,aReg(Rg),false,V,V) =>  [iUAcns(Rg,Lb)].
  unifyOp(Lb,yReg(Lc,_),_,V,V) =>  [iMAY(0,Lc),iUAcns(0,Lb)].
  unifyOp(Lb,sReg,_,V,V) =>  [iUScns(Lb)].

  public matchTerm:(term,logical,addr,map[string,varDesc],map[string,varDesc],
      varSet,varSet,list[litrl],list[litrl],logical) => list[instruction].
  matchTerm(anon,_,Src,D,D,VS,VS,Lts,Lts,_) => skipOver(Src).
  matchTerm(T,Top,Src,D,Dx,VS,VSx,Lt,Ltx,_) => matchLit(Lb,Top,Src,VS,VSx) :- isGroundTerm(T), accessLiteral(T,Lb,Lt,Ltx).
  matchTerm(varbl(Nm),_,Src,D,Dx,VS,Vx,Lt,Lt,last) => matchVar(Entry,Src,D,Dx,VS,Vx,last) :- present(D,Nm,Entry).
  matchTerm(cons(Op,Els),Top,Src,D,Dx,V,Vx,Lt,Ltx,Last) => matchOp(Lb,Src,Top,V,V0) <> matchEls(Els,D,Dx,V,Vx,Lt0,Ltx) :-
      accessLiteral(Op,Lb,Lt,Lt0).

  matchEls:(list[term],map[string,varDesc],map[string,varDesc],varSet,varSet,list[litrl],list[litrl]) => list[instruction].
  matchEls([],D,D,V,V,Lt,Lt) => [].
  matchEls([e],D,Dx,V,Vx,Lt,Ltx) => matchTerm(e,false,sReg,D,Dx,V,Vx,Lt,Ltx,true).
  matchEls([e,..l],D,Dx,V,Vx,Lt,Ltx) => matchTerm(e,false,sReg,D,D0,V,V0,Lt,Lt0,false)<>matchEls(l,D0,Dx,V0,Vx,Lt0,Ltx).

  matchVar:(varDesc,addr,map[string,varDesc],map[string,varDesc],varSet,varSet,logical) => list[instruction].
  matchVar(varDesc(_,_,_,voidAddr,_),sReg,D,D,V,V,_) => [iClS].
  matchVar(varDesc(_,_,_,voidAddr,_),_,D,D,V,V,_) => [].
  matchVar(varDesc(_,inited,_,Src,_),Dst,D,D,V,Vx,_) => Ins :- matchVr(Src,Dst,V,Ins,Vx).
  matchVar(varDesc(Nm,notInited,Def,Src,Lst),Dst,D,D[Nm->varDesc(Nm,inited,Def,Src,Lst)],V,Vx,Last) => Ins :- moveVr(Src,Dst,V,Last,Ins,Vx).

  matchLit:(string,logical,addr,varSet,varSet) => list[instruction].
  matchLit(_,_,voidAddr,Vs,Vs) => [].
  matchLit(Lb,true,aReg(Rg),VS,freeAReg(VS,Rg)) => [iCAlit(Rg,Lb)].
  matchLit(Lb,false,aReg(Rg),VS,VS) => [iCAlit(Rg,Lb)].
  matchLit(Lb,_,yReg(Lc,_),VS,VS) => [iMAY(0,Lc),iCAlit(0,Lb)].
  matchLit(Lb,_,sReg,VS,VS) => [iCSlit(Lcb)].

  matchOp:(string,addr,logical,varSet,varSet) => list[instruction].
  matchOp(Lb,aReg(Rg),true,V,freeAReg(V,Rg)) => [iCAcns(Rg,Lb)].
  matchOp(Lb,aReg(Rg),false,V,V) =>  [iCAcns(Rg,Lb)].
  matchOp(Lb,yReg(Lc,_),_,V,V) =>  [iMAY(0,Lc),iCAcns(0,Lb)].
  matchOp(Lb,sReg,_,V,V) =>  [iCScns(Lb)].

  public callArgs:(list[term],integer,map[string,varDesc],list[litrl],varSet,logical,list[instruction],map[string,varDesc],list[litrl],varSet){}.
  callArgs(Args,Gp,D,Lt,Vs,Last,Code,Dx,Ltx,Vsx) :-
    buildArgs(Args,1,Gp,D,Dx,Vs,Last,Vsx,Lt,Ltx,Code).

  buildArgs:(list[term],integer,integer,map[string,varDesc],map[string,varDesc],varSet,logical,varSet,list[litrl],list[litrl],list[instruction]){}.
  buildArgs([],_,_,D,D,V,_,V,Lt,Lt,[]).
  buildArgs([e,..l],Rg,Gp,D,Dx,V,Last,Vx,Lt,Ltx,Code) :-
    ACode = buildTerm(e,true,aReg(Rg),D,D0,V,V0,Lt,Lt0,Last),
    buildArgs(l,Rg+1,Gp,D0,Dx,V0,Last,Vx,Lt0,Ltx,BCode),
    Code = ACode<>BCode.

  public buildTerm:(term,logical,addr,map[string,varDesc],map[string,varDesc],
        varSet,varSet,list[litrl],list[litrl],logical) => list[instruction].
  buildTerm(anon,_,Dst,D,D,V,Vx,Lts,Lts,_) => clearTrm(Dst,V,Vx).
  buildTerm(T,Top,Dst,D,D,V,Vx,Lt,Ltx,_) => buildLit(Lb,Top,Dst,V,Vx) :- isGroundTerm(T), accessLiteral(T,Lb,Lt,Ltx).
  buildTerm(varbl(Nm),_,Dst,D,Dx,V,Vx,Lt,Lt,last) => buildVar(Entry,Dst,D,Dx,V,Vx,last) :- present(D,Nm,Entry).
  buildTerm(cons(Op,Els),Top,Dst,D,Dx,V,Vx,Lt,Ltx,Last) => buildOp(Lb,Dst,Top,V,V0) <> buildEls(Els,false,D,Dx,V0,Vx,Lt0,Ltx) :-
      accessLiteral(Op,Lb,Lt,Lt0).

  public clearTrm:(addr,varSet,varSet) => list[instruction].
  clearTrm(voidAddr,V,V)=>[].
  clearTrm(aReg(Rg),V,regUsed(V,Rg))=>[iClA(Rg)].
  clearTrm(yReg(Lc,_),V,locUsed(V,Lc))=>[iClY(Lc)].
  clearTrm(sReg,V,V) => [iCLS].

  buildEls:(list[term],logical,map[string,varDesc],map[string,varDesc],varSet,varSet,list[litrl],list[litrl]) => list[instruction].
  buildEls([],_,D,D,V,V,Lt,Lt) => [].
  buildEls([e],Top,D,Dx,V,Vx,Lt,Ltx) => buildTerm(e,Top,sReg,D,Dx,V,Vx,Lt,Ltx,true).
  buildEls([e,..l],Top,D,Dx,V,Vx,Lt,Ltx) => buildTerm(e,Top,sReg,D,D0,V,V0,Lt,Lt0,false)<>buildEls(l,Top,D0,Dx,V0,Vx,Lt0,Ltx).

  buildVar:(varDesc,addr,map[string,varDesc],map[string,varDesc],varSet,varSet,logical) => list[instruction].
  buildVar(varDesc(_,_,_,voidAddr,_),sReg,D,D,V,V,_) => [iClS].
  buildVar(varDesc(_,_,_,voidAddr,_),_,D,D,V,V,_) => [].
  buildVar(varDesc(_,inited,_,Src,_),Dst,D,D,V,Vx,Last) => Ins :- moveVr(Dst,Src,V,Last,Ins,Vx).
  buildVar(varDesc(Nm,notInited,Def,Src,Lst),Dst,D,D[Nm->varDesc(Nm,inited,Def,Src,Lst)],V,Vx,Last) => Ins :- clearVr(Dst,Src,V,Ins,Vx).

  buildLit:(string,logical,addr,varSet,varSet) => list[instruction].
  buildLit(_,_,voidAddr,Vs,Vs) => [].
  buildLit(Lb,_,aReg(Rg),VS,regUsed(VS,Rg)) => [iMAlit(Rg,Lb)].
  buildLit(Lb,_,yReg(Lc,_),VS,locUsed(VS,Lc)) => [iMAlit(0,Lb),iMYA(Lc,0)].
  buildLit(Lb,_,sReg,VS,VS) => [iMSlit(Lb)].

  buildOp:(string,addr,logical,varSet,varSet) => list[instruction].
  buildOp(Lb,aReg(Rg),true,V,regUsed(V,Rg)) => [iMAcns(Rg,Lb)].
  buildOp(Lb,aReg(Rg),false,V,V) =>  [iMAcns(Rg,Lb)].
  buildOp(Lb,yReg(Lc,_),_,V,locUsed(V,Lc)) =>  [iMAcns(0,Lb),iMYA(Lc,0)].
  buildOp(Lb,sReg,_,V,V) =>  [iMScns(Lb)].

  public unifyVr:(addr,addr,varSet,list[instruction],varSet){}.
  unifyVr(voidAddr,_,Used,[],Used).
  unifyVr(_,voidAddr,Used, [],Used).
  unifyVr(aReg(Reg),aReg(Reg),Used, [],Used).
  unifyVr(aReg(Reg),aReg(Rg),Used, [iUAA(Reg,Rg)],Used) :- Reg\=Rg.
  unifyVr(aReg(Reg),yReg(Lc,_),Used, [iUAY(Reg,Lc)],Used).
  unifyVr(aReg(Reg),sReg,Used, [iUAS(Reg)],Used).
  unifyVr(yReg(Lc,_),aReg(Reg),Used, [iUAY(Reg,Lc)],Used).
  unifyVr(yReg(Lc,_),yReg(Lc,_),Used, [],Used).
  unifyVr(yReg(Lc,_),yReg(Loc,_),Used, [iUYY(Lc,Loc)],Used) :- Lc<255, Loc<255.
  unifyVr(yReg(Lc,_),yReg(Loc,_),Used, [iMAY(0,Lc),iUAY(0,Loc)],Used).
  unifyVr(yReg(Lc,_),sReg,Used, [iUYS(Lc)],Used).
  unifyVr(sReg,aReg(Rg),Used,[iUAS(Rg)],Used).
  unifyVr(sReg,yReg(Lc,_),Used,[iUYS(Lc)],Used).

  public moveVr:(addr,addr,varSet,logical,list[instruction],varSet){}.
  moveVr(voidAddr,_,Used,_,[],Used).
  moveVr(aReg(Rg),aReg(Rg),Used,_,[],Used).
  moveVr(aReg(Rg),aReg(Reg),Used,_,[iMAA(Rg,Reg)],regUsed(Used,Rg)).
  moveVr(aReg(Rg),yReg(Lc,Safe),Used,Last,[iMAY(Rg,Lc)],regUsed(Used,Rg)) :- (Safe | Last).
  moveVr(aReg(Rg),yReg(Lc,_),Used,_,[iMuAY(Rg,Lc)],regUsed(lclGc(Used,varSlotSz),Rg)).
  moveVr(aReg(Rg),sReg,Used,_,[iMAS(Rg)],regUsed(Used,Rg)).
  moveVr(yReg(Lc,_),aReg(Rg),Used,_,[iMYA(Lc,Rg)],locUsed(Used,Lc)).
  moveVr(yReg(Lc,_),yReg(Lc,_),Used,_,[],Used).
  moveVr(yReg(Lc,_),yReg(Loc,_),Used,_,[iMYY(Lc,Loc)],locUsed(Used,Lc)) :- Lc<255, Loc<255.
  moveVr(yReg(Lc,_),yReg(Loc,_),Used,_,[iMAY(0,Loc),iMYA(Lc,0)],locUsed(Used,Lc)).
  moveVr(yReg(Lc,_),sReg,Used,_,[iMYS(Lc)],locUsed(Used,Lc)).
  moveVr(sReg,aReg(Rg),Used,_,[iMSA(Rg)],Used).
  moveVr(sReg,yReg(Lc,_),Used,_,[iMSY(Lc)],Used).

  public overVr:(addr,addr,varSet,logical,list[instruction],varSet){}.
  overVr(voidAddr,_,Used,_,[],Used).
  overVr(aReg(Rg),aReg(Rg),Used,_,[],Used).
  overVr(aReg(Rg),aReg(Reg),Used,_,[iMAA(Rg,Reg)],regUsed(Used,Rg)).
  overVr(aReg(Rg),yReg(Lc,Safe),Used,Last,[iMAY(Rg,Lc)],regUsed(Used,Rg)) :- (Safe | Last).
  overVr(aReg(Rg),yReg(Lc,_),Used,_,[iMuAY(Rg,Lc)],regUsed(lclGc(Used,varSlotSz),Rg)).
  overVr(aReg(Rg),sReg,Used,_,[iMAS(Rg)],regUsed(Used,Rg)).
  overVr(yReg(Lc,_),aReg(Rg),Used,_,[iOYA(Lc,Rg)],locUsed(Used,Lc)).
  overVr(yReg(Lc,_),yReg(Lc,_),Used,_,[],Used).
  overVr(yReg(Lc,_),yReg(Loc,_),Used,_,[iMAY(0,Lc),iOYA(Loc,0)],locUsed(Used,Lc)).
  overVr(yReg(Lc,_),sReg,Used,_,[iMYS(Lc)],locUsed(Used,Lc)).

  public matchVr:(addr,addr,varSet,list[instruction],varSet){}.
  matchVr(voidAddr,_,Used,[],Used).
  matchVr(aReg(Rg),aReg(Rg),Used,[],Used).
  matchVr(aReg(Rg),aReg(Reg),Used,[iNvrA(Rg),iCAA(Rg,Reg)],Used).
  matchVr(aReg(Rg),yReg(Lc,Safe),Used,[iNvrA(Rg),iCAY(Rg,Lc)],Used).
  matchVr(aReg(Rg),sReg,Used,[iNvrA(Rg),iCAS(Rg)],Used).
  matchVr(yReg(Lc,_),aReg(Rg),Used,[iNvrY(Lc),iCYA(Lc,Rg)],Used).
  matchVr(yReg(Lc,_),yReg(Lc,_),Used,[],Used).
  matchVr(yReg(Lc,_),yReg(Loc,_),Used,[iNvrY(Lc),iMAY(0,Loc),iCAY(0,Lc)],Used).
  matchVr(yReg(Lc,_),sReg,Used,[iNvrY(Lc),iCYS(Lc)],Used).
  matchVr(sReg,aReg(Rg),Used,[iCSA(Rg)],Used).
  matchVr(sReg,yReg(Lc,_),Used,[iCSY(Lc)],Used).

  public clearVr:(addr,addr,varSet,list[instruction],varSet){}.
  clearVr(voidAddr,Src,V,clearTrm(Src,V,Vx),Vx).
  clearVr(Dst,voidAddr,V,clearTrm(Dst,V,Vx),Vx).
  clearVr(aReg(Rg),aReg(Rg),V,[iClA(Rg)],regUsed(lclGc(V,varSlotSz),Rg)).
  clearVr(aReg(Rg),aReg(Reg),V,[iClAA(Rg,Reg)],regUsed(regUsed(lclGc(V,varSlotSz),Reg),Rg)).
  clearVr(aReg(Rg),yReg(Lc,Safe),V,[iClAY(Rg,Lc)],locUsed(regUsed(V,Rg),Lc)).
  clearVr(yReg(Lc,_),aReg(Rg),V,[iClAY(Rg,Lc)],locUsed(regUsed(V,Rg),Lc)).
  clearVr(yReg(Lc,_),yReg(Lc,_),V,[iClY(Lc)],locUsed(V,Lc)).
  clearVr(yReg(Lc,_),yReg(Loc,_),V,[iClY(Lc),iMAY(0,Lc),iMYA(Loc,0)],locUsed(locUsed(V,Loc),Lc)).
  clearVr(sReg,aReg(Rg),V,[iClSA(Rg)],regUsed(V,Rg)).
  clearVr(sReg,yReg(Lc,_),V,[iClSY(Lc)],locUsed(V,Lc)).
}
