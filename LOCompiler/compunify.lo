lo.comp.comp.unify{
  import lo.

  import lo.comp.errors.
  import lo.comp.registers.
  import lo.comp.term.

  unifyHead:(list[term],map[string,dictEntry],map[string,dictEntry],varSet,varSet,list[literal],list[literal],logical) => list[instruction].

  public unifyTerm:(term,logical,source,map[string,dictEntry],map[string,dictEntry],varSet,varSet,list[literal],list[literal],logical) => list[instruction].
  unifyTerm(anon,_,Src,D,D,VS,VS,Lts,Lts,_) => skipOver(Src).
  unifyTerm(T,Top,Src,D,D,VS,VSx,Lt,Ltx,_) => unifyLit(Lb,Top,Src,VS,VSx) :- isGroundTerm(T), accessLiteral(T,Lb,Lt,Ltx).
  unifyTerm(varbl(Nm),_,Src,D,Dx,VS,Vx,Lt,Lt,last) => unifyVar(Dst,Src,In,D,Dx,VS,Vx,Lt,last) :- present(D,Nm,dictEntry(_,In,Dst)).
  unifyTerm(cons(Op,Els),Top,Src,D,Dx,V,Vx,Lt,Ltx,Last) => unifyOp(Lb,Top,Src,V,V0) <> unifyEls(Els,D,Dx,V,Vx,Lt0,Ltx) :-
      accessLiteral(Op,Lt,Lt0).

  unifyEls:(list[term],map[string,dictEntry],map[string,dictEntry],varSet,varSet,list[literal],list[literal]) => list[instruction].
  unifyEls([],D,D,V,V,Lt,Lt) => [].
  unifyEls([e],D,Dx,V,Vx,Lt,Ltx) => unifyTerm(e,false,sReg,D,Dx,V,Vx,Lt,Ltx,true).
  unifyEls([e,..l],D,Dx,V,Vx,Lt,Ltx) => unifyTerm(e,false,sReg,D,D0,V,V0,Lt,Lt0,false)<>unifyEls(l,D0,Dx,V0,Vx,Lt0,Ltx).

  unifyVar:(source,source,initialized,map[string,dictEntry],map[string,dictEntry],varSet,varSet,logical) => list[instruction].
  unifyVar(voidVar,sReg,_,D,D,V,V,_) => [iClS].
  unifyVar(voidVar,_,_,D,D,V,V,_) => [].
  unifyVar(Src,Dst,true,D,D,V,Vx,Last) => Ins :- unifyVr(Src,Dst,V,Last,Ins,Vx).
  unifyVar(Src,Dst,false,D,Dx,V,Vx,Last) => Ins :- moveVr(Src,Dst,V,Last,Ins,Vx), updateInited(Src,D,Dx).

  skipOver:(source) => list[instruction].
  skipOver(voidVar) => [].
  skipOver(aReg(_)) => [].
  skipOver(yReg(_,_)) => [].
  skipOver(sReg) => [iClS].

  unifyLit:(string,logical,source,varSet,varSet) => list[instruction].
  unifyLit(_,_,anon,Vs,Vs) => [].
  unifyLit(Lb,true,aReg(Rg),VS,freeReg(VS,Rg)) => [iUAlit(Rg,Lb)].
  unifyLit(Lb,false,aReg(Rg),VS,VS) => [iUAlit(Rg,Lb)].
  unifyLit(Lb,_,yReg(Lc,_),VS,VS) => [iMAY(0,Lc),iUAlit(0,Lb)].
  unifyLit(Lb,_,sReg,VS,VS) => [iUSlit(Lcb)].

  accessLiteral:(term,string,list[literal],list[literal]){}.
  accessLiteral(T,Lb,Lt,Lt) :- literal(T,Lb) in Lt.
  accessLiteral(T,Lb,Lts,[literal(Lb,T)]) :- Lb = _str_gen("L").

  unifyOp:(string,source,logical,varSet,varSet) => list[instruction].
  unifyOp(Lb,aReg(1),true,V,freeAReg(V,1)) => [iUAcns1(Lb)].
  unifyOp(Lb,aReg(1),false,V,V) =>  [iUAcns1(Lb)].
  unifyOp(Lb,aReg(2),true,V,freeAReg(V,2)) => [iUAcns2(Lb)].
  unifyOp(Lb,aReg(2),false,V,V) =>  [iUAcns2(Lb)].
  unifyOp(Lb,aReg(3),true,V,freeAReg(V,3)) => [iUAcns3(Lb)].
  unifyOp(Lb,aReg(3),false,V,V) =>  [iUAcns3(Lb)].
  unifyOp(Lb,aReg(4),true,V,freeAReg(V,4)) => [iUAcns4(Lb)].
  unifyOp(Lb,aReg(4),false,V,V) =>  [iUAcns4(Lb)].
  unifyOp(Lb,aReg(Rg),true,V,freeAReg(V,Rg)) => [iUAcns(Rg.Lb)].
  unifyOp(Lb,aReg(Rg),false,V,V) =>  [iUAcns(Rg,Lb)].
  unifyOp(Lb,yReg(Lc,_),_,V,V) =>  [iMAY(0,Lc),iUAcns0(Lb)].
  unifyOp(Lb,sReg,_,V,V) =>  [iUScns(Lb)].

  public matchTerm:(term,logical,source,map[string,dictEntry],map[string,dictEntry],varSet,varSet,list[literal],list[literal],logical) => list[instruction].
  matchTerm(anon,_,Src,D,D,VS,VS,Lts,Lts,_) => skipOver(Src).
  matchTerm(T,Top,Src,D,D,VS,VSx,Lt,Ltx,_) => matchLit(Lb,Top,Src,VS,VSx) :- isGroundTerm(T), accessLiteral(T,Lb,Lt,Ltx).
  matchTerm(varbl(Nm),_,Src,D,Dx,VS,Vx,Lt,Lt,last) => matchVar(Dst,Src,In,D,Dx,VS,Vx,Lt,last) :- present(D,Nm,dictEntry(_,In,Dst)).
  matchTerm(cons(Op,Els),Top,Src,D,Dx,V,Vx,Lt,Ltx,Last) => matchOp(Lb,Top,Src,V,V0) <> matchEls(Els,D,Dx,V,Vx,Lt0,Ltx) :-
      accessLiteral(Op,Lt,Lt0).

  matchEls:(list[term],map[string,dictEntry],map[string,dictEntry],varSet,varSet,list[literal],list[literal]) => list[instruction].
  matchEls([],D,D,V,V,Lt,Lt) => [].
  matchEls([e],D,Dx,V,Vx,Lt,Ltx) => matchTerm(e,false,sReg,D,Dx,V,Vx,Lt,Ltx,true).
  matchEls([e,..l],D,Dx,V,Vx,Lt,Ltx) => matchTerm(e,false,sReg,D,D0,V,V0,Lt,Lt0,false)<>matchEls(l,D0,Dx,V0,Vx,Lt0,Ltx).

  matchVar:(source,source,initialized,map[string,dictEntry],map[string,dictEntry],varSet,varSet,logical) => list[instruction].
  matchVar(voidVar,sReg,_,D,D,V,V,_) => [iClS].
  matchVar(voidVar,_,_,D,D,V,V,_) => [].
  matchVar(Src,Dst,true,D,D,V,Vx,Last) => Ins :- matchVr(Src,Dst,V,Last,Ins,Vx).
  matchVar(Src,Dst,false,D,Dx,V,Vx,Last) => Ins :- moveVr(Src,Dst,V,Last,Ins,Vx), updateInited(Src,D,Dx).

  matchLit:(string,logical,source,varSet,varSet) => list[instruction].
  matchLit(_,_,anon,Vs,Vs) => [].
  matchLit(Lb,true,aReg(Rg),VS,freeReg(VS,Rg)) => [iCAlit(Rg,Lb)].
  matchLit(Lb,false,aReg(Rg),VS,VS) => [iCAlit(Rg,Lb)].
  matchLit(Lb,_,yReg(Lc,_),VS,VS) => [iMAY(0,Lc),iCAlit(0,Lb)].
  matchLit(Lb,_,sReg,VS,VS) => [iCSlit(Lcb)].

  matchOp:(string,source,logical,varSet,varSet) => list[instruction].
  matchOp(Lb,aReg(1),true,V,freeAReg(V,1)) => [iCAcns1(Lb)].
  matchOp(Lb,aReg(1),false,V,V) =>  [iCAcns1(Lb)].
  matchOp(Lb,aReg(2),true,V,freeAReg(V,2)) => [iCAcns2(Lb)].
  matchOp(Lb,aReg(2),false,V,V) =>  [iCAcns2(Lb)].
  matchOp(Lb,aReg(3),true,V,freeAReg(V,3)) => [iCAcns3(Lb)].
  matchOp(Lb,aReg(3),false,V,V) =>  [iCAcns3(Lb)].
  matchOp(Lb,aReg(4),true,V,freeAReg(V,4)) => [iCAcns4(Lb)].
  matchOp(Lb,aReg(4),false,V,V) =>  [iCAcns4(Lb)].
  matchOp(Lb,aReg(Rg),true,V,freeAReg(V,Rg)) => [iCAcns(Rg.Lb)].
  matchOp(Lb,aReg(Rg),false,V,V) =>  [iCAcns(Rg,Lb)].
  matchOp(Lb,yReg(Lc,_),_,V,V) =>  [iMAY(0,Lc),iCAcns0(Lb)].
  matchOp(Lb,sReg,_,V,V) =>  [iCScns(Lb)].

  public buildTerm:(term,logical,source,map[string,dictEntry],map[string,dictEntry],varSet,varSet,list[literal],list[literal],logical) => list[instruction].
  buildTerm(anon,_,Src,D,D,V,Vx,Lts,Lts,_) => clearVar(Src,V,Vx).
  buildTerm(T,Top,Src,D,D,VS,VSx,Lt,Ltx,_) => buildLit(Lb,Top,Src,VS,VSx) :- isGroundTerm(T), accessLiteral(T,Lb,Lt,Ltx).
  buildTerm(varbl(Nm),_,Src,D,Dx,VS,Vx,Lt,Lt,last) => buildVar(Dst,Src,In,D,Dx,VS,Vx,Lt,last) :- present(D,Nm,dictEntry(_,In,Dst)).
  buildTerm(cons(Op,Els),Top,Src,D,Dx,V,Vx,Lt,Ltx,Last) => buildOp(Lb,Top,Src,V,V0) <> buildEls(Els,D,Dx,V,Vx,Lt0,Ltx) :-
      accessLiteral(Op,Lt,Lt0).

  buildEls:(list[term],map[string,dictEntry],map[string,dictEntry],varSet,varSet,list[literal],list[literal]) => list[instruction].
  buildEls([],D,D,V,V,Lt,Lt) => [].
  buildEls([e],D,Dx,V,Vx,Lt,Ltx) => buildTerm(e,false,sReg,D,Dx,V,Vx,Lt,Ltx,true).
  buildEls([e,..l],D,Dx,V,Vx,Lt,Ltx) => buildTerm(e,false,sReg,D,D0,V,V0,Lt,Lt0,false)<>buildEls(l,D0,Dx,V0,Vx,Lt0,Ltx).

  buildVar:(source,source,initialized,map[string,dictEntry],map[string,dictEntry],varSet,varSet,logical) => list[instruction].
  buildVar(voidVar,sReg,_,D,D,V,V,_) => [iClS].
  buildVar(voidVar,_,_,D,D,V,V,_) => [].
  buildVar(Src,Dst,true,D,D,V,Vx,Last) => Ins :- moveVr(Src,Dst,V,Ins,Vx).
  buildVar(Src,Dst,false,D,Dx,V,Vx,Last) => Ins :- clearVr(Src,Dst,V,Last,Ins,Vx), updateInited(Src,D,Dx).

  buildLit:(string,logical,source,varSet,varSet) => list[instruction].
  buildLit(_,_,anon,Vs,Vs) => [].
  buildLit(Lb,true,aReg(Rg),VS,freeReg(VS,Rg)) => [iCAlit(Rg,Lb)].
  buildLit(Lb,false,aReg(Rg),VS,VS) => [iCAlit(Rg,Lb)].
  buildLit(Lb,_,yReg(Lc,_),VS,VS) => [iMAY(0,Lc),iCAlit(0,Lb)].
  buildLit(Lb,_,sReg,VS,VS) => [iCSlit(Lcb)].

  buildOp:(string,source,logical,varSet,varSet) => list[instruction].
  buildOp(Lb,aReg(1),true,V,freeAReg(V,1)) => [iCAcns1(Lb)].
  buildOp(Lb,aReg(1),false,V,V) =>  [iCAcns1(Lb)].
  buildOp(Lb,aReg(2),true,V,freeAReg(V,2)) => [iCAcns2(Lb)].
  buildOp(Lb,aReg(2),false,V,V) =>  [iCAcns2(Lb)].
  buildOp(Lb,aReg(3),true,V,freeAReg(V,3)) => [iCAcns3(Lb)].
  buildOp(Lb,aReg(3),false,V,V) =>  [iCAcns3(Lb)].
  buildOp(Lb,aReg(4),true,V,freeAReg(V,4)) => [iCAcns4(Lb)].
  buildOp(Lb,aReg(4),false,V,V) =>  [iCAcns4(Lb)].
  buildOp(Lb,aReg(Rg),true,V,freeAReg(V,Rg)) => [iCAcns(Rg.Lb)].
  buildOp(Lb,aReg(Rg),false,V,V) =>  [iCAcns(Rg,Lb)].
  buildOp(Lb,yReg(Lc,_),_,V,V) =>  [iMAY(0,Lc),iCAcns0(Lb)].
  buildOp(Lb,sReg,_,V,V) =>  [iCScns(Lb)].


  public unifyVar:(source,source,varSet,list[instruction],varSet){}.
  unifyVar(voidVar,_,Used,[],Used).
  unifyVar(_,voidVar,Used, [],Used).
  unifyVar(aReg(Reg),aReg(Reg),Used, [],Used).
  unifyVar(aReg(Reg),aReg(Rg),Used, [iUAA(Reg,Rg)],Used) :- Reg\=Rg.
  unifyVar(aReg(Reg),yReg(Lc,_),Used, [iUAY(Reg,Lc)],Used).
  unifyVar(aReg(Reg),sReg,Used, [iUAS(Reg)],Used).
  unifyVar(yReg(Lc,_),aReg(Reg),Used, [iUAY(Reg,Lc)],Used).
  unifyVar(yReg(Lc,_),yReg(Lc,_),Used, [],Used).
  unifyVar(yReg(Lc,_),yReg(Loc,_),Used, [iUYY(Lc,Loc)],Used) :- Lc<255, Loc<255.
  unifyVar(yReg(Lc,_),yReg(Loc,_),Used, [iMAY(0,Lc),iUAY(0,Loc)],Used).
  unifyVar(yReg(Lc,_),sReg,Used, [iUYS(Lc)],Used).
  unifyVar(sReg,aReg(Rg),Used)  => ([iUAS(Rg)],Used).
  unifyVar(sReg,yReg(Lc,_),Used, [iUYS(Lc)],Used).

  public moveVr:(source,source,varSet,logical,list[instruction],varSet){}.
  moveVr(voidVar,_,Used,_,[],Used).
  moveVr(aReg(Rg),aReg(Rg),Used,_,[],Used).
  moveVr(aReg(Rg),aReg(Reg),Used,_,[iMAA(Rg,Reg)],regUsed(Used,Rg)).
  moveVr(aReg(Rg),yReg(Lc,Safe),Used,Last,[iMAY(Rg,Lc)],regUsed(Used,Rg)) :- (Safe | Last).
  moveVr(aReg(Rg),yReg(Lc,_),Used,_,[iMUAY(Rg,Lc)],regUsed(lclGc(Used,varSlotSz))).
  moveVr(aReg(Rg),sReg,Used,_,[iMAS(Rg)],regUsed(Used,Rg)).
  moveVr(yReg(Lc,_),aReg(Rg),Used,_,[iMYA(Lc,Rg)],locUsed(Used,Lc)).
  moveVr(yReg(Lc,_),yReg(Lc,_),Used,_,[],Used).
  moveVr(yReg(Lc,_),yReg(Loc,_),Used,_,[iMYY(Lc,Loc)],locUsed(Used,Lc)) :- Lc<255, Loc<255.
  moveVr(yReg(Lc,_),yReg(Loc,_),Used,_,[iMAY(0,Loc),iMYA(Lc,0)],locUsed(Used,Lc)).
  moveVr(yReg(Lc,_),sReg,Used,_,[iMYS(Lc)],locUsed(Used,Lc)).
  moveVr(sReg,aReg(Rg),Used,_,[iMSA(Rg)],Used).
  moveVr(sReg,yReg(Lc,_),Used,_,[iMSY(Lc)],Used).


  public overVar:(source,source,varSet,logical,list[instruction],varSet){}.
  overVar(voidVar,_,Used,_,[],Used).
  overVar(aReg(Rg),aReg(Rg),Used,_,[],Used).
  overVar(aReg(Rg),aReg(Reg),Used,_,[iMAA(Rg,Reg)],regUsed(Used,Rg)).
  overVar(aReg(Rg),yReg(Lc,Safe),Used,Last,[iMAY(Rg,Lc)],regUsed(Used,Rg)) :- (Safe | Last).
  overVar(aReg(Rg),yReg(Lc,_),Used,_,[iMUAY(Rg,Lc)],regUsed(lclGc(Used,varSlotSz))).
  overVar(aReg(Rg),sReg,Used,_,[iMAS(Rg)],regUsed(Used,Rg)).
  overVar(yReg(Lc,_),aReg(Rg),Used,_,[iOYA(Lc,Rg)],locUsed(Used,Lc)).
  overVar(yReg(Lc,_),yReg(Lc,_),Used,_,[],Used).
  overVar(yReg(Lc,_),yReg(Loc,_),Used,_,[iMAY(0,Lc),iOYA(Loc,0)],locUsed(Used,Lc)).
  overVar(yReg(Lc,_),sReg,Used,_,[iMYS(Lc)],locUsed(Used,Lc)).

  public matchVar:(source,source,varSet,list[instruction],varSet){}.
  matchVar(voidVar,_,Used,[],Used).
  matchVar(aReg(Rg),aReg(Rg),Used,[],Used).
  matchVar(aReg(Rg),aReg(Reg),Used,[iNvra(Rg),iCAA(Rg,Reg)],Used).
  matchVar(aReg(Rg),yReg(Lc,Safe),Used,[iNvra(Rg),iCAY(Rg,Lc)],Used).
  matchVar(aReg(Rg),sReg,Used,_,[iNvra(Rg),iCAS(Rg)],Used).
  matchVar(yReg(Lc,_),aReg(Rg),Used,[iNvrY(Lc),iCYA(Lc,Rg)],Used).
  matchVar(yReg(Lc,_),yReg(Lc,_),Used,[],Used).
  matchVar(yReg(Lc,_),yReg(Loc,_),Used,[iNvrY(Lc),iMAY(0,Loc),iCAY(0,Lc)],Used).
  matchVar(yReg(Lc,_),sReg,Used,[iNvrY(Lc),iCYS(Lc)],Used).
  matchVar(sReg,aReg(Rg),Used,[iCSA(Rg)],Used).
  matchVar(sReg,yReg(Lc,_),Used,_,[iCSY(Lc)],Used).

  public clearVar:(source,varSet,list[instruction],varSet){}.
  clearVar(voidVar,Used,[],Used).
  clearVar(aReg(Rg),Used,[iClA(Rg)],regUsed(Used,Rg)).
  clearVar(yReg(Lc,_),Used,[iClY(Lc)],locUsed(Used,Lc)).
  clearVar(sReg,User,[iCLS],Used).

  public clearVr:(source,source,varSet,list[instruction],varSet).
  clearVr(voidVar,Src,Used) => clearVar(Src,Used).
  clearVr(Dst,voidVar,Used) => clearVar(Dst,Used).
  clearVr(aReg(Rg),aReg(Rg),Used,[iClA(Rg)],regUsed(lclGc(Used,varSlotSz),Rg)).
  clearVr(aReg(Rg),aReg(Reg),Used,[iClAA(Rg,Reg)],regUsed(regUsed(lclGc(Used,varSlotSz),Reg),Rg)).
  clearVr(aReg(Rg),yReg(Lc,Safe),Used,[iClAY(Rg,Lc)],locUsed(regUsed(Used,Rg),Loc)).
  clearVr(yReg(Lc,_),aReg(Rg),Used,[iClAY(Rg,Lc)],locUsed(regUsed(Used,Rg),Lc)).
  clearVr(yReg(Lc,_),yReg(Lc,_),Used,[iClY(Lc)],locUsed(Used,Lc)).
  clearVr(yReg(Lc,_),yReg(Loc,_),Used,[iClY(Lc),iMAY(0,Lc),iMYA(Loc,0)],locUsed(locUsed(Used,Loc),Lc)).
  clearVr(sReg,aReg(Rg),Used,[iClSA(Rg)],regUsed(Used,Rg)).
  clearVr(sReg,yReg(Lc,_),Used,_,[iClSY(Lc)],locUsed(Used,Lc)).
}