lo.comp.abstract{
  -- Utilities for parsing ast structures

  import lo.
  import lo.comp.ast.
  import lo.comp.location.
  import lo.comp.keywords.

  public isScalar:(ast){}.
  isScalar(intg(_,_)).
  isScalar(flot(_,_)).
  isScalar(strg(_,_)).

  public isString:(ast,location,string){}.
  isString(strg(Lc,St),Lc,St).

  public isInteger:(ast,location,integer){}.
  isInteger(intg(Lc,Ix),Lc,Ix).

  public isBinary:(ast,string,location,ast,ast){}.
  isBinary(appl(Lc,iden(_,Nm),tupl(_,"()",[L,R])),Nm,Lc,L,R).

  public
  binary:(location,string,ast,ast) => ast.
  binary(Lc,Op,L,R) => appl(Lc,iden(Lc,Op),tupl(Lc,"()",[L,R])).

  public isUnary:(ast,string,location,ast){}.
  isUnary(appl(Lc,iden(_,Nm),tupl(_,"()",[L])),Nm,Lc,L).

  public
  unary:(location,string,ast) => ast.
  unary(Lc,Op,A) => appl(Lc,iden(Lc,Op),tupl(Lc,"()",[A])).

  public
  isSquareTerm:(ast,location,ast,list[ast]){}.
  isSquareTerm(appl(Lc,Op,tupl(_,"[]",A)),Lc,Nm,A).

  public
  squareTerm:(location,ast,list[ast]) => ast.
  squareTerm(Lc,Op,Els) => appl(Lc,Op,tupl(Lc,"[]",Els)).

  public
  isBraceTerm:(ast,location,ast,list[ast]){}.
  isBraceTerm(appl(Lc,Op,tupl(_,"{}",A)),Lc,Op,A).

  public
  isIden:(ast,location,string){}.
  isIden(iden(Lc,Nm),Lc,Nm).
  isIden(tupl(Lc,"()",[iden(_,Nm)]),Lc,Nm).

  public
  isRoundTuple:(ast,location,list[ast]){}.
  isRoundTuple(tupl(Lc,"()",A),Lc,A).

  public
  isSquareTuple:(ast,location,list[ast]){}.
  isSquareTuple(tupl(Lc,"[]",A),Lc,A).

  public
  isBraceTuple:(ast,location,list[ast]){}.
  isBraceTuple(tupl(Lc,"{}",A),Lc,A).

  public
  braceTuple:(location,list[ast]) => ast.
  braceTuple(Lc,Els) => tupl(Lc,"{}",Els).

  public
  isRoundTerm:(ast,location,ast,list[ast]){}.
  isRoundTerm(appl(Lc,Op,tupl(_,"()",A)),Lc,Op,A) :- \+ keyword(Op).

  public
  isRound:(ast,location,ast,ast){}.
  isRound(appl(Lc,Op,A),Lc,Op,A) :- \+ keyword(Op), isRoundTuple(A,_,_).

  public
  roundTerm:(location,ast,list[ast]) => ast.
  roundTerm(Lc,Op,Els) => appl(Lc,Op,tupl(Lc,"()",Els)).

  public
  keyword:(ast){}.
  keyword(iden(_,Nm)) :- isKeyword(Nm).

  public
  deComma:(ast) => list[ast].
  deComma(T) => [L,..deComma(R)] :-  isBinary(T,",",_,L,R).
  deComma(T) => [T].

  public sameTerm:(ast,ast){}.
  sameTerm(iden(_,Nm),iden(_,Nm)).
  sameTerm(intg(_,Ix),intg(_,Ix)).
  sameTerm(flot(_,Dx),flot(_,Dx)).
  sameTerm(strg(_,S),strg(_,S)).
  sameTerm(tupl(_,T,A),tupl(_,T,B)) :-
    sameTerms(A,B).
  sameTerm(appl(_,OA,AA),appl(_,OB,BA)) :-
    sameTerm(OA,OB),
    sameTerm(AA,BA).

  private sameTerms:(list[ast],list[ast]){}.
  sameTerms([],[]).
  sameTerms([A,..L1],[B,..L2]) :-
    sameTerm(A,B),
    sameTerms(L1,L2).
}