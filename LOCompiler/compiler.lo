lo.comp.compiler{
  import lo.
  import lo.either.
  import lo.repo.file.
  import lo.uri.
  import lo.resources.

  import lo.comp.location.
  import lo.comp.ast.
  import lo.comp.encode.
  import lo.comp.grammar.
  import lo.comp.args.
  import lo.comp.canon.
  import lo.comp.catalog.
  import lo.comp.genprolog.
  import lo.comp.imports.
  import lo.comp.package.
  import lo.comp.typecheck.
  import lo.comp.errors.
  import lo.comp.grapher.
  import lo.comp.transform.
  import lo.comp.term.

  import lo.comp.code.pkg.

  -- Hint to the run-time:
  main:(list[string]){}.
  main(Args) :-
    processArgs(parseFlags(Args)).

  processArgs:(either[compOption,string]){}.
  processArgs(either(Opts)) :-
    Repo = openRepository(Opts.repoDir),
    Cat = locateCatalog(Opts.wDir),
    (Opts.dependency ?
      processGroups(makeGraph(Opts.pkgs,Repo,Cat,reportBase,Rp0),Repo,Cat,Opts,[],Rp0,Rpx)! |
      compilePkgs(Opts.pkgs,Repo,Cat,Opts,reportBase,Rpx)),
    _logmsg(formatSS(fullReport(Rpx))).
  processArgs(alternate(M)) :-
    _logmsg(M).

  processGroups:(list[list[(pkg,list[pkg])]],fileRepo,catalog,compOption,list[pkg],report,report){}.
  processGroups(_,_,_,_,_,Rp,Rpx) :-
    countErrors(Rp)>0,
    reportMsg("aborting compilation",std,Rp,Rpx).
  processGroups([],_,_,_,_,Rp,Rp).
  processGroups([Gp,..L],Repo,Cat,Opts,CP,Rp,Rpx) :-
    (length(Gp)>1 ?
      reportError("circular dependency in packages \(projectPkgs(Gp))",std,Rp,Rpx) |
      processGroup(Gp,Repo,Repo0,Cat,Opts,CP,CP0,Rp,Rp0),
      processGroups(L,Repo0,Cat,Opts,CP0,Rp0,Rpx)).

  private projectPkgs:(list[(pkg,list[pkg])]) => list[pkg].
  projectPkgs([]) => [].
  projectPkgs([(Pkg,_),..L]) => [Pkg,..projectPkgs(L)].

  processGroup:(list[(pkg,list[pkg])],fileRepo,fileRepo,catalog,compOption,list[pkg],list[pkg],report,report){}.
  processGroup([],Repo,Repo,_,_,CP,CP,Rp,Rp).
  processGroup([(P,Imps),..L],Repo,RepoX,Cat,Opts,CP,CPx,Rp,Rpx) :-
    processPkg(P,Imps,Repo,Repo0,Cat,Opts,CP,CP0,Rp,Rp0)!,
    processGroup(L,Repo0,RepoX,Cat,Opts,CP0,CPx,Rp0,Rpx).

  processPkg:(pkg,list[pkg],fileRepo,fileRepo,catalog,compOption,list[pkg],list[pkg],report,report){}.
  processPkg(P,Imps,Repo,Repo,_,Opts,CP,CP,Rp,Rp) :-
    importsOk(Imps,CP),
    (Opts.prologOnly?packagePrologOk(Repo,P) | packageCodeOk(Repo,P)),
    _logmsg("skipping package \(P)").
  processPkg(P,_,Repo,RepoX,Cat,Opts,CP,[P,..CP],Rp,Rpx) :-
    _logmsg("compiling package \(P)"),
    compilePkg(P,Repo,RepoX,Cat,Opts,Rp,Rpx)!.

  importsOk:(list[pkg],list[pkg]){}.
  importsOk([],_).
  importsOk([Pk,..L],CP) :- \+ (P in CP, consistentPkg(Pk,P)), importsOk(L,CP).

  compilePkg:(pkg,fileRepo,fileRepo,catalog,compOption,report,report){}.
  compilePkg(Pkg,Repo,Repox,Cat,Opts,Rp,Rpx) :-
    Pkg = pkg(P,V),
    (resolveCatalog(Cat,Pkg,U,_) ?
      Src = explode(getResource(U)),
      Term = parseSrc(U,Src,Rp,Rp0),
      (errorFree(Rp0) ?
        Prg = checkProgram(Term,V,Repo,Rp0,Rp1),
        (errorFree(Rp1) ?
          transformProg(Prg,Opts,TrPrg,Rp1,Rp2),
          (errorFree(Rp2)?
            Repo1 = addPrologPackage(addSource(Repo,Pkg,U::string),Pkg,TrPrg::string),
            (Opts.prologOnly ?
              Repox = Repo1 |
              Code = compileMdl(TrPrg),
              Repox = addPackage(Repo1,Pkg,implode(encMdl(Code)))) |
            Rpx = populateContext(Rp2,getUriPath(U),collectSrc(Src,1,emptyArray))) |
          Rpx = populateContext(Rp1,getUriPath(U),collectSrc(Src,1,emptyArray))) |
        Rpx = populateContext(Rp0,getUriPath(U),collectSrc(Src,1,emptyArray))) |
      reportError("cannot locate \(pkg(P,V)) in catalog",std,Rp,Rpx),
      Repox = Repo).

  compilePkgs:(list[pkg],fileRepo,catalog,compOption,report,report){}.
  compilePkgs([],_,_,_,Rp,Rp).
  compilePkgs([Pk,..L],Repo,Cat,Opt,Rp,Rpx) :-
    errorFree(Rp),
    compilePkg(Pk,Repo,Repo0,Cat,Opt,Rp,Rp0),
    compilePkgs(L,Repo0,Cat,Opts,Rp0,Rpx).
  compilePkgs(_,_,_,_,Rp,Rp) :- \+ errorFree(Rp).
}
