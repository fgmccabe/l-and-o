lo.comp.dependencies{
  import lo.
  import lo.topsort.

  import lo.comp.location.
  import lo.comp.ast.
  import lo.comp.abstract.
  import lo.comp.keywords.
  import lo.comp.misc.
  import lo.comp.errors.
  import lo.comp.package.
  import lo.comp.wff.

  public
  defn ::= defn(string,defnKind,location,list[(string,defnKind)],list[ast]).

  implementation all x,y ~~ depends[defn->>(string,defnKind)] => {
    defines(defn(X,K,_,_,_),(X,K)).
    references(defn(_,_,_,R,_)) => R.
  }

  implementation display[defn] => {
    disp(D) => dispDefn(D).
  }

  private
  dispDefn:(defn)=>ss.
  dispDefn(defn(Nm,K,Lc,Refs,Stmts)) => ssSeq([ss(Nm),ss(":"),disp(K),..showRefs(Refs,"->")]).

  private showRefs:(list[(string,defnKind)],string) => list[ss].
  showRefs([],_) => [].
  showRefs([(Nm,K),..R],Sep) => [ss(Sep),ss(Nm),ss(":"),disp(K),..showRefs(R,",")].

  implementation display[defnKind] => {
    disp(tpe) => ss("type").
    disp(con) => ss("contract").
    disp(impl) => ss("implementation").
    disp(valu) => ss("var").
    disp(clss) => ss("class").
  }

  public
  dependencies:(list[ast],list[list[defn]],list[(string,defnKind)],list[(string,ast)],list[ast],list[ast],report,report){}.
  dependencies(Els,Groups,Public,Annots,Imports,Other,Rp,Rpx) :-
    collectDefinitions(Els,Dfs,Public,Annots,Imports,Other,Rp,Rpx),
    Groups = topsort(collectThetaRefs(Dfs,allRefs(Dfs),Annots)),
    showGroups(Groups).

  collectDefinitions:(list[ast],list[defn],list[(string,defnKind)],list[(string,ast)],list[ast],list[ast],report,report){}.
  collectDefinitions([],[],[],[],[],[],Rp,Rp).
  collectDefinitions([St,..Stmts],Defs,Pu,An,Im,Ot,Rp,Rpx) :-
    collectDefn(St,St,Stmts,S0,Defs,D0,Pu,P0,An,An0,Im,Im0,Ot,Ot0,priVate,Rp,Rp0),
    collectDefinitions(S0,D0,P0,An0,Im0,Ot0,Rp0,Rpx).

  collectDefn:(ast,ast,list[ast],list[ast],list[defn],list[defn],
      list[(string,defnKind)],list[(string,defnKind)],list[(string,ast)],list[(string,ast)],
      list[ast],list[ast],list[ast],list[ast],visibility,report,report){}.
  collectDefn(St,OrigSt,Stmts,Stmts,Defs,Defs,P,Px,A,A,[OrigSt,..I],I,Oth,Oth,Viz,Rp,Rp) :-
    isImport(St,Nm),
    checkPublic(Viz,Nm,imp,P,Px).
  collectDefn(St,_,Stmts,Stmts,Defs,Defs,P,P,A,A,I,I,[St,..Oth],Oth,_,Rp,Rp) :-
    isOther(St).
  collectDefn(St,OrigSt,Stmts,Stx,Defs,Dx,P,P,A,Ax,I,Ix,O,Ox,_,Rp,Rpx) :-
    isPrivate(St,_,Inner),
    collectDefn(Inner,OrigSt,Stmts,Stx,Defs,Dx,P,_,A,Ax,I,Ix,O,Ox,priVate,Rp,Rpx).
  collectDefn(St,OrigSt,Stmts,Stx,Defs,Dx,P,Px,A,Ax,I,Ix,O,Ox,_,Rp,Rpx) :-
    isPublic(St,_,Inner),
    collectDefn(Inner,OrigSt,Stmts,Stx,Defs,Dx,P,Px,A,Ax,I,Ix,O,Ox,pUblic,Rp,Rpx).
  collectDefn(St,OrigSt,Stmts,Stmts,Defs,Defs,P,Px,[(Nm,St),..A],A,I,I,Oth,Oth,Viz,Rp,Rp) :-
    isBinary(St,":",_,L,_),
    isIden(L,_,Nm),
    checkPublic(Viz,Nm,valu,P,Px).
  collectDefn(St,_,Stmts,Stmts,Defs,Defs,P,P,A,A,I,I,O,O,_,Rp,Rp) :-
    isBinary(St,"@",_,_,_).
  collectDefn(St,_,Stmts,Stmts,Defs,Defs,P,P,A,A,I,I,O,O,_,Rp,Rp) :-
    isUnary(St,"@",_,_).
  collectDefn(St,_,Stmts,Stx,[defn(Nm,K,St.loc,[],[St,..DfSts]),..Defs],Defs,P,Px,A,A,I,I,Oth,Oth,Viz,Rp,Rp) :-
    ruleNameKind(St,K,Nm),
    collectDefines(Stmts,Nm,K,Stx,DfSts),
    checkPublic(Viz,Nm,K,P,Px).
  collectDefn(St,_,Stmts,Stmts,Defs,Defs,P,P,A,A,I,I,O,O,_,Rp,Rpx) :-
    reportError("cannot fathom \(St)",St.loc,Rp,Rpx).

  ruleNameKind:(ast,defnKind,string){}.
  ruleNameKind(S,con,Nm) :-
    isUnary(S,"contract",_,I),
    contractName(I,Nm).
  ruleNameKind(S,impl,Nm) :-
    isUnary(S,"implementation",_,I),
    isBinary(I,"=>",_,L,_),
    astImplName(L,Nm).
  ruleNameKind(S,tpe,Nm) :-
    typeRuleName(S,Nm).
  ruleNameKind(S,K,Nm) :- isPublic(S,_,I), ruleNameKind(I,K,Nm).
  ruleNameKind(S,K,Nm) :- isPrivate(S,_,I), ruleNameKind(I,K,Nm).
  ruleNameKind(S,valu,Nm) :- ruleHead(S,H)!, Nm = headName(H).

  ruleHead:(ast,ast){}.
  ruleHead(S,L) :- isBinary(S,"=",_,L,_).
  ruleHead(S,L) :- isBinary(S,"=>",_,L,_).
  ruleHead(S,L) :- isBinary(S,"-->",_,LL,_), isBinary(LL,",",_,L,_).
  ruleHead(S,L) :- isBinary(S,"-->",_,L,_).
  ruleHead(S,L) :- isBinary(S,":-",_,LL,_), ruleHead(LL,L).
  ruleHead(S,L) :- isBinary(S,"<=",_,L,_).
  ruleHead(S,S) :- isRoundTerm(S,_,_,_).

  headName:(ast)=>string.
  headName(H) =>  Nm :-  isRoundTerm(H,_,O,_), isIden(O,_,Nm).
  headName(H) =>  Nm :-  isIden(H,_,Nm).
  headName(H) =>  headName(A) :-  isRoundTuple(H,_,[A]).
  headName(H) =>  tplLbl(length(A)) :-  isRoundTuple(H,_,A). -- special handling for tuples
  headName(H) => Nm :- isBraceTerm(H,_,O,_), isIden(O,_,Nm).

  contractName:(ast,string){}.
  contractName(S,Nm) :-
    isQuantified(S,_,I),
    contractName(I,Nm).
  contractName(S,Nm) :-
    isConstrained(S,_,R),
    contractName(R,Nm).
  contractName(S,Nm) :-
    isBinary(S,"<~",_,L,_),
    contractName(L,Nm).
  contractName(S,Nm) :-
    isSquareTerm(S,_,Op,_), isIden(Op,_,Nm).

  typeRuleName:(ast,string){}.
  typeRuleName(S,Nm) :-
    isQuantified(S,_,I),
    typeRuleName(I,Nm).
  typeRuleName(S,Nm) :-
    isConstrained(S,_,I),
    typeRuleName(I,Nm).
  typeRuleName(S,Nm) :-
    isBinary(S,"<~",_,L,_),
    (isSquareTerm(L,_,Op,_) ? isIden(Op,_,Nm) | isIden(L,_,Nm)).
  typeRuleName(S,Nm) :-
    isBinary(S,"~>",_,L,_),
    (isSquareTerm(L,_,Op,_) ? isIden(Op,_,Nm) | isIden(L,_,Nm)).

  astImplName:(ast,string){}.
  astImplName(S,Nm) :-
    isQuantified(S,_,I),
    astImplName(I,Nm).
  astImplName(S,Nm) :-
    isConstrained(S,_,I),
    astImplName(I,Nm).
  astImplName(S,formatSS(ssSeq([ss(Nm),..sfcNames(A,marker(con))]))) :-
    isSquareTerm(S,_,Op,A),
    isIden(Op,_,Nm).
  astImplName(T,tplLbl(length(A))) :-
    isRoundTuple(T,_,A).

  sfcNames:(list[ast],string) => list[ss].
  sfcNames([T,.._],Sep) => sfcNames(deComma(L),Sep) :-
    isBinary(T,"->>",_,L,_).
  sfcNames([],_)=>[].
  sfcNames([T,..Els],Sep) => [ss(Sep),sfcName(T),..sfcNames(Els,Sep)].

  sfcName:(ast)=>ss.
  sfcName(N) =>  ss(Nm) :-  isIden(N,_,Nm).
  sfcName(S) =>  ss(Nm) :-  (isSquareTerm(S,_,Op,_), isIden(Op,_,Nm)).
  sfcName(T) => ss(tplLbl(length(Els))) :- isRoundTuple(T,_,Els).

  collectDefines:(list[ast],string,defnKind,list[ast],list[ast]){}.
  collectDefines([],_,_,[],[]).
  collectDefines([St,..Stmts],Nm,K,Stx,[St,..Def]) :-
    ruleNameKind(St,K,Nm),
    collectDefines(Stmts,Nm,K,Stx,Def).
  collectDefines(Stmts,_,_,Stmts,[]).

  checkPublic:(visibility,string,defnKind,list[(string,defnKind)],list[(string,defnKind)]){}.
  checkPublic(pUblic,Nm,K,[(Nm,K),..E],E).
  checkPublic(priVate,_,_,E,E).

  allRefs:(list[defn]) => list[(string,defnKind)].
  allRefs([]) => [].
  allRefs([defn(Nm,K,_,_,_),..L]) => [(Nm,K),..allRefs(L)].

  collectThetaRefs:(list[defn],list[(string,defnKind)],list[(string,ast)]) => list[defn].
  collectThetaRefs([],_,_) => [].
  collectThetaRefs([defn(N,K,Lc,_,S),..L],All,Annots) =>
    [defn(N,K,Lc,thetaRefs(S,All,refsInScope([A],All,[])),S),..collectThetaRefs(L,All,Annots)] :- (N,A) in Annots.
  collectThetaRefs([defn(N,K,Lc,_,S),..L],All,Annots)  =>
    [defn(N,K,Lc,thetaRefs(S,All,[]),S),..collectThetaRefs(L,All,Annots)].

  thetaRefs:(list[ast],list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  thetaRefs([],_,So)=>So.
  thetaRefs([St,..Stmts],All,So) => thetaRefs(Stmts,All,stmtRefs(St,All,So)).

  stmtRefs:(ast,list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  stmtRefs(S,All,So) =>  stmtRefs(I,All,So) :-  isUnary(S,"private",_,I).
  stmtRefs(S,All,So) =>  stmtRefs(I,All,So) :-  isUnary(S,"public",_,I).
  stmtRefs(S,All,So) =>  refsInType(S,All,So) :-  isTypeRule(S).
  stmtRefs(S,All,So) =>  refsInContract(I,All,So) :-  isUnary(S,"contract",_,I).
  stmtRefs(S,All,So) =>  refsInConstraint(L,All,refsInTerm(R,All,So)) :-  (isUnary(S,"implementation",_,I),isBinary(I,"=>",_,L,R)).
  stmtRefs(S,All,So) =>  refsInHead(L,All,refsInTerm(R,All,So)) :-  isBinary(S,"=>",_,L,R).
  stmtRefs(S,All,So) =>  refsInHead(H,All,refsInTerm(E,All,refsInCond(R,All,So))) :- isBinary(S,":-",_,L,R), isBinary(L,"=>",_,H,E).
  stmtRefs(S,All,So) =>  refsInHead(H,All,refsInTerm(E,All,refsInCond(R,All,So))) :- isBinary(S,":-",_,L,R), isBinary(L,"=",_,H,E).
  stmtRefs(S,All,So) =>  refsInHead(L,All,refsInCond(R,All,So)) :-  isBinary(S,":-",_,L,R).
  stmtRefs(S,All,So) =>  refsInTerms(A,All,So) :-  isRoundTerm(S,_,_,A).
  stmtRefs(S,All,So) =>  refsInHead(L,All,refsInNT(R,All,So)) :-  isBinary(S,"-->",_,L,R).
  stmtRefs(S,All,So) =>  refsInHead(L,All,refsInTerm(R,All,So)) :-  isBinary(S,"<=",_,L,R).
  stmtRefs(S,All,So) =>  refsInTerm(R,All,So) :-  isBinary(S,"=",_,L,R).
  stmtRefs(S,All,So) =>  refsInTerm(R,All,So) :-  isUnary(S,"show",_,R).
  stmtRefs(S,All,So) =>  refsInCond(R,All,So) :-  isUnary(S,"assert",_,R).
  stmtRefs(S,All,So) => refsInType(I,All,So) :- isBinary(S,":",_,_,I).

  refsInHead:(ast,list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInHead(S,All,So) => refsInTerms(A,All,So) :-  isRoundTerm(S,_,_,A).
  refsInHead(S,All,So) => So :- isIden(S,_,_).
  refsInHead(S,All,So) => refsInTerm(L,All,refsInTerm(R,All,So)) :- isBinary(A,_,_,L,R).
  refsInHead(S,All,So) => refsInTerm(R,All,So) :- isUnary(A,_,_,R).

  refsInType:(ast,list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInType(T,All,So) =>  (((Nm,tpe) in All, \+ (Nm,tpe) in So) ? [(Nm,tpe),..So] | So) :-  isIden(T,_,Nm).
  refsInType(T,All,So) =>  refsInTypes(Args,All,refsInType(Op,All,So)) :-  isSquareTerm(T,_,Op,Args).
  refsInType(T,All,So) => refsInTypes(Args,All,So) :- isBraceTerm(T,_,A,[]), isRoundTuple(A,_,Args).
  refsInType(T,All,So) =>  refsInType(I,All,So) :-  isUnary(T,"?",_,I).
  refsInType(T,All,So) =>  refsInType(I,All,So) :-  isUnary(T,"^",_,I).
  refsInType(T,All,So) =>  refsInType(I,All,So) :-  isUnary(T,"?^",_,I).
  refsInType(T,All,So) =>  refsInType(I,All,So) :-  isUnary(T,"^?",_,I).
  refsInType(T,All,So) =>  refsInType(L,All,refsInType(R,All,So)) :-  isBinary(T,",",_,L,R).
  refsInType(T,All,So) =>  refsInType(L,All,refsInType(R,All,So)) :-  isBinary(T,"=>",_,L,R).
  refsInType(T,All,So) =>  refsInArgTypes(A,All,refsInType(R,All,So)) :-  isBinary(T,"-->",_,L,R), isRoundTuple(L,_,A).
  refsInType(T,All,So) =>  refsInType(L,All,refsInType(R,All,So)) :-  isBinary(T,"<=>",_,L,R).
  refsInType(T,All,So) =>  refsInType(L,All,refsInType(R,All,So)) :-  isBinary(T,"->>",_,L,R).
  refsInType(T,All,So) =>  refsInType(R,All,So) :-  isBinary(T,"=",_,_,R).
  refsInType(T,All,So) =>  refsInTypes(L,All,So) :-  isRoundTuple(T,_,L).
  refsInType(T,All,So) =>  refsInConstraint(L,All,refsInType(R,All,So)) :-  isBinary(T,"|:",_,L,R).
  refsInType(T,All,So) =>  refsInType(R,All,So) :-  isBinary(T,"<~",_,_,R). -- type rule
  refsInType(T,All,So) =>  refsInType(I,All,So) :-  isQuantified(T,_,I).
  refsInType(T,All,So) =>  refsInScope(E,All,So) :-  isBraceTuple(T,_,E).
  refsInType(T,_,So) => So.  -- actually an error case

  refsInTypes:(list[ast],list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInTypes([],_,So) => So.
  refsInTypes([T,..L],All,So) => refsInTypes(L,All,refsInType(T,All,So)).

  refsInArgTypes:(list[ast],list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInArgTypes([],_,So) => So.
  refsInArgTypes([T,..L],All,So) => refsInArgTypes(L,All,refsInType(stripTypeMode(T),All,So)).

  stripTypeMode:(ast)=>ast.
  stripTypeMode(A) => I :- isUnary(A,"?",_,I).
  stripTypeMode(A) => I :- isUnary(A,"^",_,I).
  stripTypeMode(A) => I :- isUnary(A,"?^",_,I).
  stripTypeMode(A) => I :- isUnary(A,"^?",_,I).
  stripTypeMode(A) => A.

  refsInScope:(list[ast],list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInScope([],_,So) => So.
  refsInScope([E,..L],All,So) =>  refsInScope(L,All,refsInType(T,All,So)) :-  isBinary(E,":",_,_,T).
  refsInScope([E,..L],All,So) =>  refsInScope(L,All,So) :-  isBinary(E,"@",_,_,_).
  refsInScope([E,..L],All,So) =>  refsInScope(L,All,So) :-  isUnary(E,"@",_,_).

  refsInContract:(ast,list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInContract(C,All,So) => refsInContract(I,All,So) :- isQuantified(C,_,I).
  refsInContract(C,All,So) => refsInType(R,All,So) :- isBinary(C,"<~",_,L,R).

  refsInConstraint:(ast,list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInConstraint(T,All,So) =>  (((Nm,con) in All, \+ (Nm,con) in So) ? [(Nm,con),..So] | So) :-  isIden(T,_,Nm).
  refsInConstraint(T,All,So) =>  refsInTypes(Args,All,refsInConstraint(Op,All,So)) :-  isSquareTerm(T,_,Op,Args).
  refsInConstraint(T,All,So) =>  refsInConstraint(L,All,refsInConstraint(R,All,So)) :-  isBinary(T,",",_,L,R).
  refsInConstraint(T,All,So) =>  refsInConstraint(L,All,refsInConstraint(R,All,So)) :-  isBinary(T,"|:",_,L,R).
  refsInConstraint(T,All,So) =>  refsInType(L,All,refsInType(R,All,So)) :-  isBinary(T,"<~",_,L,R).
  refsInConstraint(T,All,So) =>  refsInConstraint(I,All,So) :-  isQuantified(T,_,I).

  refsInCond:(ast,list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInCond(T,All,So) =>  (((Nm,valu) in All, \+ (Nm,valu) in So) ? [(Nm,valu),..So] | So) :-  isIden(T,_,Nm).
  refsInCond(T,All,So) =>  refsInCond(L,All,refsInCond(R,All,So)) :-  isBinary(T,",",_,L,R).
  refsInCond(T,All,So) =>  refsInCond(R,All,refsInCond(LR,All,refsInCond(LL,All,So))) :-  (isBinary(T,"|",_,L,R), isBinary(L,"?",_,LL,LR)).
  refsInCond(T,All,So) =>  refsInCond(R,All,refsInCond(L,All,So)) :-  isBinary(T,"|",_,L,R).
  refsInCond(T,All,So) =>  refsInCond(L,All,refsInCond(R,All,So)) :-  isBinary(T,"*>",_,L,R).
  refsInCond(T,All,So) =>  refsInCond(L,All,So) :-  isUnary(T,"!",_,L).
  refsInCond(T,All,So) =>  refsInCond(L,All,So) :-  isUnary(T,"\\+",_,L).
  refsInCond(T,All,So) =>  refsInTerm(L,All,refsInTerm(R,All,So)) :-  isBinary(T,"=",_,L,R).
  refsInCond(T,All,So) =>  refsInTerm(L,All,refsInTerm(R,All,So)) :-  isBinary(T,"\\=",_,L,R).
  refsInCond(T,All,So) =>  refsInNT(L,All,refsInTerm(LR,All,refsInTerm(LL,All,So))) :-  (isBinary(T,"%%",_,L,R), isBinary(R,"~",_,LL,LR)).
  refsInCond(T,All,So) =>  refsInNT(L,All,refsInTerm(R,All,So)) :-  isBinary(T,"%%",_,L,R).
  refsInCond(T,All,So) =>  refsInTerms(Args,All,refsInTerm(Op,All,So)) :-  isRoundTerm(T,_,Op,Args).
  refsInCond(T,All,So) =>  refsInConds(Args,All,So) :-  isRoundTuple(T,_,Args).
  refsInCond(T,All,So) => refsInTerm(T,All,So).

  refsInConds:(list[ast],list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInConds([],_,So) => So.
  refsInConds([T,..L],All,So) => refsInConds(L,All,refsInCond(T,All,So)).

  refsInNT:(ast,list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInNT(T,All,So) => refsInTerms(Args,All,So) :-  isSquareTuple(T,_,Args).
  refsInNT(T,All,So) => refsInNT(R,All,refsInNT(LR,All,refsInNT(LL,All,So))) :- isBinary(T,"|",_,L,R), isBinary(L,"?",_,LL,LR).
  refsInNT(T,All,So) => refsInNT(R,All,refsInNT(L,All,So)) :-  isBinary(T,"|",_,L,R).
  refsInNT(T,All,So) => refsInNT(L,All,refsInNT(R,All,So)) :-  isBinary(T,",",_,L,R).
  refsInNT(T,All,So) => refsInNT(L,All,So) :-  isUnary(T,"!",_,L).
  refsInNT(T,All,So) => refsInNT(L,All,So) :-  isUnary(T,"\\+",_,L).
  refsInNT(T,All,So) => refsInNT(L,All,So) :-  isUnary(T,"+",_,L).
  refsInNT(T,All,So) => refsInTerm(L,All,refsInTerm(R,All,So)) :-  isBinary(T,"=",_,L,R).
  refsInNT(T,All,So) => refsInTerm(L,All,refsInTerm(R,All,So)) :-  isBinary(T,"\\=",_,L,R).
  refsInNT(T,All,So) => refsInCond(L,All,So) :-  isUnary(T,"@",_,L).
  refsInNT(T,All,So) => refsInTerms(Args,All,refsInTerm(Op,All,So)) :- isRoundTerm(T,_,Op,Args).
  refsInNT(T,All,So) => So :- isString(T,_,_).
  refsInNT(T,All,So) => refsInNTs(Els,All,So) :- isRoundTuple(T,_,Els).
  refsInNT(T,All,So) => refsInConds(Els,All,So) :- isBraceTuple(T,_,Els).
  refsInNT(T,All,So) => So :- isIden(T,_,"eof").
  refsInNT(T,All,So) => refsInTerm(T,All,So).

  refsInNTs:(list[ast],list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInNTs([],_,So) => So.
  refsInNTs([N,..L],All,So) => refsInNTs(L,All,refsInNT(N,All,So)).

  refsInTerm:(ast,list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInTerm(T,All,So) =>  (((Nm,valu) in All, \+ (Nm,valu) in So) ? [(Nm,valu),..So] | So) :-  isIden(T,_,Nm).
  refsInTerm(T,_,So) =>  So :-  isScalar(T).
  refsInTerm(T,All,So) => refsInTerm(L,All,refsInType(R,All,So)) :-  isBinary(T,":",_,L,R).
  refsInTerm(T,All,So) => refsInTerm(L,All,refsInType(R,All,So)) :-  isBinary(T,"::",_,L,R).
  refsInTerm(T,All,So) => refsInTerm(L,All,refsInCond(R,All,So)) :-  isBinary(T,":-",_,L,R).
  refsInTerm(T,All,So) => refsInTerm(L,All,So) :-  isBinary(T,".",_,L,_).
  refsInTerm(T,All,So) => refsInTerm(L,All,So) :-  isUnary(T,"?",_,L).
  refsInTerm(T,All,So) => refsInTerm(L,All,So) :-  isUnary(T,"^",_,L).
  refsInTerm(T,All,So) => refsInTerm(L,All,So) :-  isUnary(T,"?^",_,L).
  refsInTerm(T,All,So) => refsInTerm(L,All,So) :-  isUnary(T,"^?",_,L).
  refsInTerm(T,All,So) => refsInTerm(R,All,refsInTerm(LR,All,refsInCond(LL,All,So))) :-  isBinary(T,"|",_,L,R), isBinary(L,"?",_,LL,LR).
  refsInTerm(T,All,So) => refsInIndex(Args,All,refsInTerm(Op,All,So)) :-  isSquareTerm(T,_,Op,Args).
  refsInTerm(T,All,So) => refsInTerms(Args,All,So) :-  isRoundTuple(T,_,Args).
  refsInTerm(T,All,So) => refsInTerms(Args,All,refsInTerm(iden(Lc,",.."),All,refsInTerm(iden(Lc,"[]"),All,So))) :-  isSquareTuple(T,Lc,Args).
  refsInTerm(T,All,So) => refsInTerm(R,All,refsInTerm(L,All,So)) :-  isBinary(T,",..",_,L,R).
  refsInTerm(T,All,So) => refsInTerm(R,All,refsInTerm(L,All,So)) :-  isBinary(T,"->",_,L,R).
  refsInTerm(T,All,So) => thetaRefs(Els,All,So) :-  isBraceTuple(T,_,Els).
  refsInTerm(T,All,So) => refsInTerm(R,All,refsInTerm(L,All,So)) :-  isBinary(T,"=>",_,L,R).
  refsInTerm(T,All,So) => refsInCond(R,All,refsInTerm(L,All,So)) :-  isBinary(T,":-",_,L,R).
  refsInTerm(T,All,So) => refsInCond(R,All,refsInTerm(L,All,So)) :-  isBinary(T,"@@",_,L,R).
  refsInTerm(T,All,So) => refsInNT(R,All,refsInTerm(L,All,So)) :-  isBinary(T,"-->",_,L,R).
  refsInTerm(T,All,So) => refsInTerms(Args,All,refsInTerm(Op,All,So)) :-  isRoundTerm(T,_,Op,Args).
  refsInTerm(T,All,So) => So. -- ignore errors for _now

  refsInTerms:(list[ast],list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInTerms([],_,So) => So.
  refsInTerms([T,..L],All,So) => refsInTerms(L,All,refsInTerm(T,All,So)).

  refsInIndex:(list[ast],list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInIndex([A],All,So) => refsInTerm(Vl,All,refsInTerm(Ky,All,So)) :- isBinary(A,"->",_,Ky,Vl).
  refsInIndex([A],All,So) => refsInTerm(Ky,All,So) :- isUnary(A,"\\+",_,Ky).
  refsInIndex(A,All,So) => refsInTerms(A,All,So).

  showGroups:(list[list[defn]]){}.
  showGroups([]).
  showGroups([G,..L]) :-
    logMsg("Group: \(G)"),
    showGroups(L).
}
