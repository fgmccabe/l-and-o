lo.comp.dependencies{
  import lo.
  import lo.comp.location.
  import lo.comp.ast.
  import lo.comp.abstract.
  import lo.comp.wff.
  import lo.comp.keywords.
  import lo.comp.misc.
  import lo.comp.errors.
  import lo.topsort.

  public
  type defn ::= defn(string,defnKind,location,list[(string,defnKind)],list[ast]).

  implementation all x,y ~~ depends[defn->>(string,defnKind)].. {
    defines(defn(X,K,_,_,_),(X,K)).
    references(defn(_,_,_,R,_)) => R.
  }

  implementation display[defn].. {
    disp(D) => dispDefn(D).
  }

  private
  dispDefn:(defn)=>ss.
  dispDefn(defn(Nm,K,Lc,Refs,Stmts)) => ssSeq([ss(Nm),ss(":"),disp(K)]).

  implementation display[defnKind].. {
    disp(tpe) => ss("type").
    disp(con) => ss("contract").
    disp(impl) => ss("implementation").
    disp(valu) => ss("var").
    disp(clss) => ss("class").
  }

  public
  dependencies:(list[ast],list[list[defn]],list[(string,defnKind)],list[(string,ast)],list[ast],list[ast]){}.
  dependencies(Els,Groups,Public,Annots,Imports,Other) :-
    collectDefinitions(Els,Dfs,Public,Annots,Imports,Other),
    Groups = topsort(collectThetaRefs(Dfs,allRefs(Dfs),Annots)),
    showGroups(Groups).

  collectDefinitions:(list[ast],list[defn],list[(string,defnKind)],list[(string,ast)],list[ast],list[ast]){}.
  collectDefinitions([],[],[],[],[],[]).
  collectDefinitions([St,..Stmts],Defs,Pu,An,Im,Ot) :-
    collectDefn(St,Stmts,S0,Defs,D0,Pu,P0,An,An0,Im,Im0,Ot,Ot0,false),
    collectDefinitions(S0,D0,P0,An0,Im0,Ot0).

  collectDefn:(ast,list[ast],list[ast],list[defn],list[defn],
      list[(string,defnKind)],list[(string,defnKind)],list[(string,ast)],list[(string,ast)],
      list[ast],list[ast],list[ast],list[ast],logical){}.
  collectDefn(St,Stmts,Stmts,Defs,Defs,P,P,A,A,[St,..I],I,Oth,Oth,_) :-
    isImport(St).
  collectDefn(St,Stmts,Stmts,Defs,Defs,P,P,A,A,I,I,[St,..Oth],Oth,_) :-
    isOther(St).
  collectDefn(St,Stmts,Stx,Defs,Dx,P,P,A,Ax,I,Ix,O,Ox,_) :-
    isUnary(St,"private",_,Inner),
    collectDefn(Inner,Stmts,Stx,Defs,Dx,P,_,A,Ax,I,Ix,O,Ox,false).
  collectDefn(St,Stmts,Stx,Defs,Dx,P,Px,A,Ax,I,Ix,O,Ox,_) :-
    isUnary(St,"public",_,Inner),
    collectDefn(Inner,Stmts,Stx,Defs,Dx,P,Px,A,Ax,I,Ix,O,Ox,true).
  collectDefn(St,Stmts,Stmts,Defs,Defs,P,Px,[(Nm,St),..A],A,I,I,Oth,Oth,Exp) :-
    isBinary(St,":",_,L,_),
    isIden(L,_,Nm),
    checkPublic(Exp,Nm,valu,P,Px).
  collectDefn(St,Stmts,Stx,[defn(Nm,K,St.loc,[],[St,..DfSts]),..Defs],Defs,P,Px,A,A,I,I,Oth,Oth,Exp) :-
    ruleNameKind(St,Nm,K),
    collectDefines(Stmts,Nm,K,Stx,DfSts),
    checkPublic(Exp,Nm,K,P,Px).
  collectDefn(St,Stmts,Stmts,Defs,Defs,P,P,A,A,I,I,O,O,_) :-
    reportError("cannot fathom $(St)",St.loc).

  isImport:(ast){}.
  isImport(St) :-
    isUnary(St,"private",_,I),
    isImport(I).
  isImport(St) :-
    isUnary(St,"public",_,I),
    isImport(I).
  isImport(St) :-
    isUnary(St,"import",_,_).

  isOther:(ast){}.
  isOther(St) :-
    isUnary(St,"assert",_,_).
  isOther(St) :-
    isUnary(St,"show",_,_).

  ruleNameKind:(ast,string,defnKind){}.
  ruleNameKind(S,Nm,con) :-
    isUnary(S,"contract",_,I),
    isBinary(I,"..",_,L,_),
    contractName(L,Nm).
  ruleNameKind(S,Nm,impl) :-
    isUnary(S,"implementation",_,I),
    isBinary(I,"..",_,L,_),
    implementationName(L,Nm).
  ruleNameKind(S,Nm,tpe) :-
    isUnary(S,"type",_,I),
    typeRuleName(L,Nm).
  ruleNameKind(S,ruleName(S),valu).

  ruleName:(ast)=>string.
  ruleName(S) =>  ruleName(I) :-  isQuantified(S,_,I).
  ruleName(S) =>  ruleName(R) :-  isConstrained(S,_,R).
  ruleName(S) => headName(ruleHead(S)).

  ruleHead:(ast)=>ast.
  ruleHead(S) =>  L :-  isBinary(S,"=",_,L,_).
  ruleHead(S) =>  L :-  isBinary(S,"=>",_,L,_).
  ruleHead(S) =>  LL :-  (isBinary(S,"-->",_,L,_), isBinary(L,",",_,LL,_)) .
  ruleHead(S) =>  L :-  isBinary(S,"-->",_,L,_).
  ruleHead(S) =>  L :-  isBinary(S,":-",_,L,_).
  ruleHead(S) =>  L :-  isBinary(S,"<=",_,L,_).
  ruleHead(S) =>  L :-  isBraceTerm(S,_,L).
  ruleHead(S) =>  S :-  isRoundTerm(S,_,_,_).

  headName:(ast)=>string.
  headName(H) =>  headName(L) :-  isBinary(H,"@@",_,L,_).
  headName(H) =>  Nm :-  (isRoundTerm(H,_,N,_), isIden(N,_,Nm)).
  headName(H) =>  Nm :-  isIden(H,_,Nm).
  headName(H) =>  headName(A) :-  isRoundTuple(H,_,[A]).
  headName(H) =>  "()$(length(A))" :-  isRoundTuple(H,_,A). -- special handling for tuples

  contractName:(ast,string){}.
  contractName(S,Nm) :-
    isQuantified(S,_,I),
    contractName(I,Nm).
  contractName(S,Nm) :-
    isConstrained(S,_,R),
    contractName(R,Nm).
  contractName(S,Nm) :-
    isSquareTerm(S,_,Op,_), isIden(Op,_,Nm).

  typeRuleName:(ast,string){}.
  typeRuleName(S,Nm) :-
    isQuantified(S,_,I),
    typeRuleName(I,Nm).
  typeRuleName(S,Nm) :-
    isConstrained(S,_,I),
    typeRuleName(I,Nm).
  typeRuleName(S,Nm) :-
    isBinary(S,"<~",_,L,_),
    isSquareTerm(L,_,Op,_), isIden(Op,_,Nm).

  implementationName:(ast,string){}.
  implementationName(S,Nm) :-
    isQuantified(S,_,I),
    implementationName(I,Nm).
  implementationName(S,Nm) :-
    isConstrained(S,_,I),
    implementationName(I,Nm).
  implementationName(S,formatSS(ssSeq([ss(Nm),..surfaceNames(A,marker(con))]))) :-
    isSquareTerm(S,_,Op,A),
    isIden(Op,_,Nm).

  surfaceNames:(list[ast],string) => list[ss].
  surfaceNames([T,.._],Sep) => surfaceNames(deComma(T),Sep) :-
    isBinary(T,"->>",_,L,_).
  surfaceNames([],_)=>[].
  surfaceNames([T,..Els],Sep) => [surfaceName(T),ss(Sep),..surfaceNames(Els,Sep)].

  surfaceName:(ast)=>ss.
  surfaceName(N) =>  ss(Nm) :-  isIden(N,_,Nm).
  surfaceName(S) =>  ss(Nm) :-  (isSquareTerm(S,_,Op,_), isIden(Op,_,Nm)).

  collectDefines:(list[ast],string,defnKind,list[ast],list[ast]){}.
  collectDefines([],_,_,[],[]).
  collectDefines([St,..Stmts],Nm,K,Stx,[St,..Def]) :-
    ruleNameKind(St,Nm,K),
    collectDefines(Stmts,Nm,K,Stx,Def).
  collectDefines(Stmts,_,_,Stmts,[]).

  checkPublic:(logical,string,defnKind,list[(string,defnKind)],list[(string,defnKind)]){}.
  checkPublic(true,Nm,K,[(Nm,K),..E],E).
  checkPublic(false,_,_,E,E).

  allRefs:(list[defn]) => list[(string,defnKind)].
  allRefs([]) => [].
  allRefs([defn(Nm,K,_,_,_),..L]) => [(Nm,K),..allRefs(L)].

  collectThetaRefs:(list[defn],list[(string,defnKind)],list[(string,ast)]) => list[defn].
  collectThetaRefs([],_,_) => [].
  collectThetaRefs([defn(N,K,Lc,_,S),..L],All,Annots) =>
    [defn(N,K,Lc,thetaRefs(S,All,refsInType(A,All,[])),S),..collectThetaRefs(L,All,Ann)] :- (N,A) in Annots.
  collectThetaRefs([defn(N,K,Lc,_,S),..L],All,Annots)  =>
    [defn(N,K,Lc,thetaRefs(S,All,[]),S),..collectThetaRefs(L,All,Ann)].

  thetaRefs:(list[ast],list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  thetaRefs([],_,So)=>So.
  thetaRefs([St,..Stmts],All,So) => thetaRefs(Stmts,All,stmtRefs(St,All,So)).

  stmtRefs:(ast,list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  stmtRefs(S,All,So) =>  stmtRefs(I,All,So) :-  isUnary(S,"private",_,I).
  stmtRefs(S,All,So) =>  stmtRefs(I,All,So) :-  isUnary(S,"public",_,I).
  stmtRefs(S,All,So) =>  refsInType(I,All,So) :-  isUnary(S,"type",_,I).
  stmtRefs(S,All,So) =>  refsInConstraint(L,All,refsInType(R,All,So)) :-  (isUnary(S,"contract",_,I), isBinary(I,"..",_,L,R)).
  stmtRefs(S,All,So) =>  refsInConstraint(L,All,refsInTerm(R,All,So)) :-  (isUnary(S,"implementation",_,I),isBinary(I,"..",_,L,R)).
  stmtRefs(S,All,So) =>  refsInHead(L,All,refsInTerm(R,All,So)) :-  isBinary(S,"=>",_,L,R).
  stmtRefs(S,All,So) =>  refsInHead(H,All,refsInTerm(E,All,refsInCond(R,All,So))) :- isBinary(S,":-",_,L,R), isBinary(L,"=>",_,H,E).
  stmtRefs(S,All,So) =>  refsInHead(L,All,refsInCond(R,All,So)) :-  isBinary(S,":-",_,L,R).
  stmtRefs(S,All,So) =>  refsInTerms(A,All,So) :-  isRoundTerm(S,_,_,A).
  stmtRefs(S,All,So) =>  refsInHead(L,Al,refsInNT(R,All,So)) :-  isBinary(S,"-->",_,L,R).
  stmtRefs(S,All,So) =>  refsInHead(L,Al,refsInTerm(R,All,So)) :-  isBinary(S,"<=",_,L,R).
  stmtRefs(S,All,So) =>  refsInHead(L,Al,thetaRefs(Els,All,So)) :-  isBraceTerm(S,_,L,Els).

  refsInHead:(ast,list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInHead(S,All,So) =>  refsInHead(L,All,refsInCond(R,All,So)) :-  isBinary(S,"@@",_,L,R).
  refsInHead(S,All,So) =>  refsInTerms(A,All,So) :-  isRoundTerm(S,_,_,A).

  refsInType:(ast,list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInType(T,All,So) =>  (((Nm,tpe) in All, \+ (Nm,tpe) in So) ? [(Nm,tpe),..So] | So) :-  isIden(T,_,Nm).
  refsInType(T,All,So) =>  refsInTypes(Args,All,refsInType(Op,All,So)) :-  isSquareTerm(T,_,Op,Args).
  refsInType(T,All,So) =>  refsInType(L,All,refsInType(R,All,So)) :-  isBinary(T,",",_,L,R).
  refsInType(T,All,So) =>  refsInType(L,All,refsInType(R,All,So)) :-  isBinary(T,"=>",_,L,R).
  refsInType(T,All,So) =>  refsInType(L,All,refsInType(R,All,So)) :-  isBinary(T,"-->",_,L,R).
  refsInType(T,All,So) =>  refsInType(L,All,refsInType(R,All,So)) :-  isBinary(T,"<=>",_,L,R).
  refsInType(T,All,So) =>  refsInType(L,All,refsInType(R,All,So)) :-  isBinary(T,"->>",_,L,R).
  refsInType(T,All,So) =>  refsInTypes(L,All,So) :-  isRoundTuple(T,_,L).
  refsInType(T,All,So) =>  refsInConstraint(L,All,refsInType(R,All,So)) :-  isBinary(T,"|:",_,L,R).
  refsInType(T,All,So) =>  refsInType(L,All,refsInType(R,All,So)) :-  isBinary(T,"<~",_,L,R). -- type rule
  refsInType(T,All,So) =>  refsInType(I,All,So) :-  isQuantified(T,_,I).
  refsInType(T,All,So) =>  refsInScope(E,All,So) :-  isBraceTuple(T,_,E).

  refsInTypes:(list[ast],list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInTypes([],_,So) => So.
  refsInTypes([T,..L],All,So) => refsInTypes(L,All,refsInType(T,All,So)). 

  refsInScope:(list[ast],list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInScope([],_,So) => So.
  refsInScope([E,..L],All,So) =>  refsInScope(L,All,refsInType(T,All,So)) :-  isBinary(E,":",_,_,T).

  refsInConstraint:(ast,list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInConstraint(T,All,So) =>  (((Nm,con) in All, \+ (Nm,con) in So) ? [(Nm,con),..So] | So) :-  isIden(T,_,Nm).
  refsInConstraint(T,All,So) =>  refsInTypes(Args,All,refsInConstraint(Op,All,So)) :-  isSquareTerm(T,_,Op,Args).
  refsInConstraint(T,All,So) =>  refsInConstraint(L,All,refsInConstraint(R,All,So)) :-  isBinary(T,",",_,L,R).
  refsInConstraint(T,All,So) =>  refsInConstraint(L,All,refsInConstraint(R,All,So)) :-  isBinary(T,"|:",_,L,R).
  refsInConstraint(T,All,So) =>  refsInType(L,All,refsInType(R,All,So)) :-  isBinary(T,"<~",_,L,R).
  refsInConstraint(T,All,So) =>  refsInConstraint(I,All,So) :-  isQuantified(T,_,I).

  refsInCond:(ast,list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInCond(T,All,So) =>  (((Nm,valu) in All, \+ (Nm,valu) in So) ? [(Nm,valu),..So] | So) :-  isIden(T,_,Nm).
  refsInCond(T,All,So) =>  refsInCond(L,All,refsInCond(R,All,So)) :-  isBinary(T,",",_,L,R).
  refsInCond(T,All,So) =>  refsInCond(R,All,refsInCond(LR,All,refsInCond(LL,All,So))) :-  (isBinary(T,"|",_,L,R), isBinary(L,"?",_,LL,LR)).
  refsInCond(T,All,So) =>  refsInCond(R,All,refsInCond(L,All,So)) :-  isBinary(T,"|",_,L,R).
  refsInCond(T,All,So) =>  refsInCond(L,All,refsInCond(R,All,So)) :-  isBinary(T,"*>",_,L,R).
  refsInCond(T,All,So) =>  refsInCond(L,All,So) :-  isUnary(T,"!",_,L).
  refsInCond(T,All,So) =>  refsInCond(L,All,So) :-  isUnary(T,"\\+",_,L).
  refsInCond(T,All,So) =>  refsInTerm(L,All,refsInTerm(R,All,So)) :-  isBinary(T,"=",_,L,R).
  refsInCond(T,All,So) =>  refsInTerm(L,All,refsInTerm(R,All,So)) :-  isBinary(T,"\\=",_,L,R).
  refsInCond(T,All,So) =>  refsInTerm(L,All,refsInTerm(R,All,So)) :-  isBinary(T,".=",_,L,R).
  refsInCond(T,All,So) =>  refsInNT(L,All,refsInTerm(LR,All,refsInTerm(LL,All,So))) :-  (isBinary(T,"%%",_,L,R), isBinary(R,"~",_,LL,LR)).
  refsInCond(T,All,So) =>  refsInNT(L,All,refsInTerm(R,All,So)) :-  isBinary(T,"%%",_,L,R).
  refsInCond(T,All,So) =>  refsInTerms(Args,All,refsInTerm(Op,All,So)) :-  isRoundTerm(T,_,Op,Args).
  refsInCond(T,All,So) =>  refsInConds(Args,All,So) :-  isRoundTuple(T,_,Args).

  refsInConds:(list[ast],list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInConds([],_,So) => So.
  refsInConds([T,..L],All,So) => refsInConds(L,All,refsInCond(T,All,So)). 

  refsInNT:(ast,list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInNT(T,All,So) =>  refsInTerms(Args,All,So) :-  isSquareTuple(T,_,Args).
  refsInNT(T,All,So) =>  refsInNT(R,All,refsInNT(LR,All,refsInCond(LL,All,So))) :-  (isBinary(T,"|",_,L,R), isBinary(L,"?",_,LL,LR)).
  refsInNT(T,All,So) =>  refsInNT(R,All,refsInNT(L,All,So)) :-  isBinary(T,"|",_,L,R).
  refsInNT(T,All,So) =>  refsInNT(L,All,refsInNT(R,All,So)) :-  isBinary(T,",",_,L,R).
  refsInNT(T,All,So) =>  refsInNT(L,All,So) :-  isUnary(T,"!",_,L).
  refsInNT(T,All,So) =>  refsInNT(L,All,So) :-  isUnary(T,"\\+",_,L).
  refsInNT(T,All,So) =>  refsInNT(L,All,So) :-  isUnary(T,"+",_,L).
  refsInNT(T,All,So) =>  refsInNT(L,All,refsInCond(R,All,So)) :-  isBinary(T,"@@",_,L,R).
  refsInNT(T,All,So) =>  refsInTerm(L,All,refsInTerm(R,All,So)) :-  isBinary(T,"=",_,L,R).
  refsInNT(T,All,So) =>  refsInTerm(L,All,refsInTerm(R,All,So)) :-  isBinary(T,"\\=",_,L,R).
  refsInNT(T,All,So) =>  refsInCond(L,All,So) :-  isUnary(T,"@",_,L).

  refsInTerm:(ast,list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInTerm(T,All,So) =>  (((Nm,valu) in All, \+ (Nm,valu) in So) ? [(Nm,valu),..So] | So) :-  isIden(T,_,Nm).
  refsInTerm(T,_,So) =>  So :-  isScalar(T).
  refsInTerm(T,All,So) =>  refsInTerm(L,All,refsInType(R,All,So)) :-  isBinary(T,":",_,L,R).
  refsInTerm(T,All,So) =>  refsInTerm(L,All,refsInCond(R,All,So)) :-  isBinary(T,"@@",_,L,R).
  refsInTerm(T,All,So) =>  refsInCond(L,All,So) :-  isUnary(T,"@",_,L).
  refsInTerm(T,All,So) =>  refsInTerm(L,All,So) :-  isBinary(T,".",_,L,_).
  refsInTerm(T,All,So) =>  refsInTerm(R,All,refsInTerm(LR,All,refsInCond(LL,All,So))) :-  (isBinary(T,"|",_,L,R), isBinary(L,"?",_,LL,LR)).
  refsInTerm(T,All,So) =>  refsInTerms(Args,All,refsInTerm(Op,All,So)) :-  isSquareTerm(T,_,Op,Args).
  refsInTerm(T,All,So) =>  refsInTerms(Args,All,So) :-  isRoundTuple(T,_,Args).
  refsInTerm(T,All,So) =>  refsInTerms(Args,All,So) :-  isSquareTuple(T,_,Args).
  refsInTerm(T,All,So) =>  refsInMapEntries(Els,All,So) :-  isBraceTuple(T,_,Els).
  refsInTerm(T,All,So) =>  refsInTerms(Args,All,refsInTerm(Op,All,So)) :-  isRoundTerm(T,_,Op,Args).

  refsInTerms:(list[ast],list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInTerms([],_,So) => So.
  refsInTerms([T,..L],All,So) => refsInTerms(L,All,refsInTerm(T,All,So)).

  refsInMapEntries:(list[ast],list[(string,defnKind)],list[(string,defnKind)]) => list[(string,defnKind)].
  refsInMapEntries([],_,So) => So.
  refsInMapEntries([T,..L],All,So) =>  refsInMapEntries(L,All,refsInTerm(R,All,So)) :-  isBinary(T,"->",_,_,R).

  showGroups:(list[list[defn]]){}.
  showGroups([]).
  showGroups([G,..L]) :-
    logMsg("Group"),
    logMsg(formatSS(disp(G))),
    showGroups(L).
}