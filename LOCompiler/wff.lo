lo.comp.wff {
  import lo.
  import lo.comp.location.
  import lo.comp.ast.
  import lo.comp.errors.
  import lo.comp.abstract.
  import lo.comp.package.

  public
  type defnKind ::= tpe | con | impl | valu | clss | imp.

  public isAlgebraicTypeDef:(ast,location,list[ast],list[ast],ast,ast){}.
  isAlgebraicTypeDef(Stmt,Lc,Quants,Constraints,Head,Body) :-
    isUnary(Stmt,"type",Lc,Term),
    getQuantifiers(Term,Quants,Inner),
    getConstraints(Inner,Constraints,TpStmt),
    isBinary(TpStmt,"::=",_,Head,Body).

  public isQuantified:(ast,ast,ast){}.
  isQuantified(T,V,B) :-
    isUnary(T,"all",_,R),
    isBinary(R,"~~",_,V,B).

  getQuantifiers:(ast,list[ast],ast){}.
  getQuantifiers(T,deComma(V),B) :- isQuantified(T,V,B).
  getQuantifiers(T,[],T).

  public
  isContractSpec:(ast,location,list[ast],list[ast],ast,list[ast]){}.
  isContractSpec(St,Lc,Quants,Constraints,Con,Body) :-
    isUnary(St,"contract",Lc,I),
    isBinary(I,"<~",_,L,R),
    isBraceTuple(R,_,Body),
    contractSpec(L,Quants,Constraints,Con).

  contractSpec:(ast,list[ast],list[ast],ast){}.
  contractSpec(S,deComma(V),Constraints,Con) :-
    isQuantified(S,V,B),
    contractSpec(B,_,Constraints,Con).
  contractSpec(S,[],deComma(L),Con) :-
    isBinary(S,"|:",_,L,Con).
  contractSpec(S,[],[],S).

  public isConstrained:(ast,list[ast],ast){}.
  isConstrained(T,deComma(L),R) :-
    isBinary(T,"|:",_,L,R).

  private getConstraints:(ast,list[ast],ast){}.
  getConstraints(T,deComma(L),R) :-
    isBinary(T,"|:",_,L,R).
  getConstraints(T,[],T).

  public
  packageName:(ast) => string.
  packageName(T) =>  Pkg :-  isIden(T,_,Pkg).
  packageName(T) =>  Pkg :-  isString(T,_,Pkg).
  packageName(T) => packageName(L)+"."+packageName(R) :- isBinary(T,".",_,L,R).

  public
  pkgName:(ast) => pkg.
  pkgName(T) => pkg(packageName(L),vers(packageVersion(R))) :- 
    isBinary(T,"#",_,L,R).
  pkgName(T) => pkg(packageName(T),defltVersion).

  packageVersion:(ast) => string.
  packageVersion(T) =>  Pkg :-  isIden(T,_,Pkg).
  packageVersion(T) =>  Pkg :-  isString(T,_,Pkg).
  packageVersion(T) =>  "$(Ix)" :-  isInteger(T,_,Ix).
  packageVersion(T) =>  packageVersion(L)+"."+packageVersion(R) :-  isBinary(T,".",_,L,R).

  public
  tupleize:(ast,string,ast){}.
  tupleize(P,Op,tupl(Lc,Op,[L,..deComma(R)])) :-
    isBinary(P,",",Lc,L,R).
  tupleize(P,Op,tupl(P.loc,Op,[P])).

  public marker:(defnKind)=>string.
  marker(tpe)=>"*".
  marker(valu)=>"@".
  marker(clss)=>"#".
  marker(con)=>"$".

  public sameLength:all e~~(list[e],list[e],location,report,report){}.
  sameLength(L1,L2,_,Rp,Rp) :- length(L1)=length(L2).
  sameLength(L1,_,Lc,Rp,Rpx) :-
    reportError("expecting $(length(L1)) elements",Lc,Rp,Rpx).
}