lo.comp.imports{
  import lo.
  import lo.uri.
  import lo.resources.

  import lo.comp.dict.
  import lo.comp.types.
  import lo.comp.term.
  import lo.comp.misc.
  import lo.comp.decode.
  import lo.comp.package.
  import lo.comp.repository.
  import lo.comp.manifest.
  import lo.comp.errors.
  import lo.comp.token.
  import lo.comp.lexer.
  import lo.comp.grammar.
  import lo.comp.ast.
  import lo.comp.abstract.
  import lo.comp.canon.

  public importPkg:(pkg,repository,pkgSpec,report,report){}.
  importPkg(pkg(Pkg,Vers),Repo,pkgSpec(pkg(Pkg,Vers),Export,Types,Classes,Contracts,Impls,Imports),Rp,Rpx) :-
    locatePackage(Repo,Pkg,Vers,_,Strm),
    nextTerm(getNTokens(Strm,Pkg,5),A,_,Rp,Rp0)!,
    pickupPkgSpec(A,Imports,Export,Types,Classes,Contracts,Impls,Rp0,Rpx)!.

  pickupPkgSpec:(ast,list[(visibility,pkg)],tipe,list[(string,tipe)],list[(string,string,tipe)],list[conEntry],list[implEntry],report,report){}.
  pickupPkgSpec(Term,decodeImports(Is),decodeSignature(Ex),Types,Classes,Contracts,Impls,Rp,Rp) :-
    isUnary(Term,"#pkg",_,E),
    isString(E,_,Enc),
    tuple([P,tuple(Is),Ex,Tp,tuple(C),tuple(Co),tuple(Im)]) = decodeValue(Enc),
    faceType(Types) = decodeSignature(Tp),
    pickupClasses(C,Classes,[]),
    findContracts(Co,Contracts,[]),
    pickupImplementations(Im,Impls,[]).

  decodeImports:(list[term]) => list[(visibility,pkg)].
  decodeImports([]) => [].
  decodeImports([cons(enum("import"),[Vz,Pk]),..Is]) => [(decodeViz(Vz),decodePkg(Pk)),..decodeImports(Is)].

  decodeTypes:(string) => list[(string,tipe)].
  decodeTypes(Txt) => F :- decodeType(faceType(F)) %% explode(Txt).

  decodeViz:(term)=>visibility.
  decodeViz(enum("public")) => pUblic.
  decodeViz(enum("private")) => priVate.

  decodePkg:(term)=>pkg.
  decodePkg(cons(enum("pkg"),[strng(Pk),V]))=> pkg(Pk,decodeVers(V)).

  decodeVers:(term)=>version.
  decodeVers(enum("*"))=>defltVersion.
  decodeVers(strng(V)) => vers(V).

  pickupClasses:(list[term],list[(string,string,tipe)],list[(string,string,tipe)]){}.
  pickupClasses([],Cls,Cls).
  pickupClasses([tuple([strng(Nm),strct(Cl,_),Sig]),..Rest],[(Nm,Cl,decodeSignature(Sig)),..More],Cls):-
    pickupClasses(Rest,More,Cls).
  pickupClasses([tuple([strng(Nm),enum(Cl),Sig]),..Rest],[(Nm,Cl,decodeSignature(Sig)),..More],Cls):-
    pickupClasses(Rest,More,Cls).

  findContracts:(list[term],list[conEntry],list[conEntry]){}.
  findContracts([],C,C).
  findContracts([tuple([strng(Nm),strng(Sig),strng(ConSig),FaceSig]),..M],[conEntry(Nm,Con,decodeSignature(FaceSig)),..C],Cx) :-
    decodeConstraint(ConSig,Con),
    findContracts(M,C,Cx).

  pickupImplementations:(list[term],list[implEntry],list[implEntry]){}.
  pickupImplementations([],I,I).
  pickupImplementations([tuple([strng(Nm),strng(Sig)]),..M],[implEntry(Nm,Spec),..I],RI) :-
    decodeConstraint(Sig,Spec),
    pickupImplementations(M,I,RI).

  private decodeSignature:(term) => tipe.
  decodeSignature(strng(S)) => T :- decodeType(T) %% explode(S).

  private splitOnHash:(string) => string.
  splitOnHash(S) => pathSuffix(S,"#").
}