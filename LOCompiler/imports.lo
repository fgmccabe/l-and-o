lo.comp.imports{
  import lo.
  import lo.uri.
  import lo.resources.
  import lo.repo.

  import lo.comp.dict.
  import lo.comp.types.
  import lo.comp.term.
  import lo.comp.misc.
  import lo.comp.decode.
  import lo.comp.package.
  import lo.comp.errors.
  import lo.comp.token.
  import lo.comp.lexer.
  import lo.comp.grammar.
  import lo.comp.ast.
  import lo.comp.abstract.
  import lo.comp.canon.

  public importPkg:all r ~~ repository[r] |: (pkg,r,pkgSpec,report,report){}.
  importPkg(pkg(Pkg,Vers),Repo,pkgSpec(IPkg,Export,Types,Enums,Contracts,Impls,Imports),Rp,Rpx) :-
    loadFromRepo(Repo,pkg(Pkg,Vers),"prolog",Strm),
    parse(A,Rp,Rp0) %% getNTokens(explode(Strm),Pkg,5)!,
    pickupPkgSpec(A,IPkg,Imports,Export,Types,Enums,Contracts,Impls,Rp0,Rpx)!.

  pickupPkgSpec:(ast,pkg,list[(visibility,pkg)],list[(string,tipe)],list[(string,tipe)],list[string],list[conEntry],list[implEntry],report,report){}.
  pickupPkgSpec(Term,decodePkg(Pk),decodeImports(Is),Fields,Types,Enums,Contracts,Impls,Rp,Rp) :-
    isUnary(Term,"#pkg",_,E),
    isString(E,_,Enc),
    cons(_,[Pk,cons(_,Is),Ex,Tp,cons(_,C),cons(_,Co),cons(_,Im)]) = decodeValue(Enc),
    faceType(Fields) = decodeSignature(Ex),
    faceType(Types) = decodeSignature(Tp),
    pickupEnums(C,Enums,[]),
    findContracts(Co,Contracts,[]),
    pickupImplementations(Im,Impls,[]).

  public importPkgs:all r ~~ repository[r] |: (list[pkg],list[pkgSpec],r,report,report) => list[pkgSpec].
  importPkgs([],Specs,_,Rp,Rp) => Specs.
  importPkgs([Pkg,..L],SoFar,Repo,Rp,Rpx) => importPkgs(L,SoFar,Repo,Rp,Rpx) :- alreadyImported(Pkg,SoFar).
  importPkgs([Pkg,..L],SoFar,Repo,Rp,Rpx) => importPkgs(L,[Spec,..SoFar],Repo,Rp0,Rpx) :-
    importPkg(Pkg,Repo,Spec,Rp,Rp0).

  public importClosure:all r ~~ repository[r] |: (list[pkg],list[pkgSpec],r,report,report) => list[pkgSpec].
  importClosure([],Specs,_,Rp,Rp) => Specs.
  importClosure([Pkg,..L],SoFar,Repo,Rp,Rpx) => importClosure(L,SoFar,Repo,Rp,Rpx) :- alreadyImported(Pkg,SoFar).
  importClosure([Pkg,..L],SoFar,Repo,Rp,Rpx) => importClosure(L,importClosure(publicImports(importsOfSpec(Spec)),[Spec,..SoFar],Repo,Rp0,Rp1),Repo,Rp1,Rpx) :-
    importPkg(Pkg,Repo,Spec,Rp,Rp0).

  alreadyImported:(pkg,list[pkgSpec]){}.
  alreadyImported(Pkg,Specs) :- pkgSpec(Pk,_,_,_,_,_,_) in Specs, consistentPkg(Pkg,Pk).

  public consistentPkg:(pkg,pkg){}.
  consistentPkg(pkg(P,V1),pkg(P,V2)) :- consistentVersion(V1,V2)!.

  consistentVersion:(version,version){}.
  consistentVersion(defltVersion,_).
  consistentVersion(vers(V),vers(V)).

  importsOfSpec:(pkgSpec) => list[(visibility,pkg)].
  importsOfSpec(pkgSpec(_,_,_,_,_,_,Imps)) => Imps.

  publicImports:(list[(visibility,pkg)]) => list[pkg].
  publicImports([]) => [].
  publicImports([(pUblic,Pkg),..L]) => [Pkg,..publicImports(L)].
  publicImports([(priVate,_),..L]) => publicImports(L).

  decodeImports:(list[term]) => list[(visibility,pkg)].
  decodeImports([]) => [].
  decodeImports([cons(strct("import",2),[Vz,Pk]),..Is]) => [(decodeViz(Vz),decodePkg(Pk)),..decodeImports(Is)].

  decodeTypes:(string) => list[(string,tipe)].
  decodeTypes(Txt) => F :- decodeType(faceType(F)) %% explode(Txt).

  decodeViz:(term)=>visibility.
  decodeViz(enum("public")) => pUblic.
  decodeViz(enum("private")) => priVate.

  decodePkg:(term)=>pkg.
  decodePkg(cons(strct("pkg",2),[strng(Pk),V]))=> pkg(Pk,decodeVers(V)).

  decodeVers:(term)=>version.
  decodeVers(enum("*"))=>defltVersion.
  decodeVers(strng(V)) => vers(V).

  pickupEnums:(list[term],list[string],list[string]){}.
  pickupEnums([],Cls,Cls).
  pickupEnums([strng(Nm),..Rest],[Nm,..More],Cls):-
    pickupEnums(Rest,More,Cls).

  findContracts:(list[term],list[conEntry],list[conEntry]){}.
  findContracts([],C,C).
  findContracts([cons(_,[strng(Nm),strng(ConNm),strng(ConSig),FaceSig]),..M],[conEntry(Nm,ConNm,Con,decodeSignature(FaceSig)),..C],Cx) :-
    decodeConstraint(ConSig,Con),
    findContracts(M,C,Cx).

  pickupImplementations:(list[term],list[implEntry],list[implEntry]){}.
  pickupImplementations([],I,I).
  pickupImplementations([cons(_,[strng(Nm),strng(Sig)]),..M],[implEntry(Nm,Spec),..I],RI) :-
    decodeConstraint(Sig,Spec),
    pickupImplementations(M,I,RI).

  private decodeSignature:(term) => tipe.
  decodeSignature(strng(S)) => T :- decodeType(T) %% explode(S).

  private splitOnHash:(string) => string.
  splitOnHash(S) => pathSuffix(S,"#").
}
