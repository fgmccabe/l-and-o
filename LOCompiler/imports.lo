lo.comp.imports{
  import lo.
  import lo.uri.
  import lo.resources.
  import lo.comp.dict.
  import lo.comp.types.
  import lo.comp.term.
  import lo.comp.misc.
  import lo.comp.decode.
  import lo.comp.package.
  import lo.comp.repository.
  import lo.comp.manifest.
  import lo.comp.errors.
  import lo.comp.token.
  import lo.comp.grammar.
  import lo.comp.ast.
  import lo.comp.abstract.
  import lo.comp.canon.

  public type pkgSpec ::= pkgSpec(string,version,tipe,list[(string,tipe)],list[(string,string,tipe)],list[conDef],list[implDef],list[(visibility,pkg)]).

  public importPkg:(pkg,repository,pkgSpec,report,report){}.
  importPkg(pkg(Pkg,Vers),Repo,pkgSpec(Pkg,Vers,Export,Types,Classes,Contracts,Impls,Imports),Rp,Rpx) :-
    locatePackage(Repo,Pkg,Vers,_,Strm),
    pickupPieces(tokenCodes(Strm,Pkg),Export,Types,Imports,Classes,Contracts,Impls,Rp,Rpx)!.

  pickupPieces:(list[token],tipe,list[(string,tipe)],list[(visibility,pkg)],
          list[(string,string,tipe)],list[conDef],list[implDef],report,report){}.
  pickupPieces(Toks,Export,Types,Imports,Classes,Contracts,Impls,Rp,Rpx) :-
    nextTerm(Toks,A,Rest,Rp,Rp0)!,
    isRoundTerm(A,_,O,Args),
    isIden(O,_,Nm),
    pickupTerm(splitOnHash(Nm),Args,Rest,Export,Types,Imports,Classes,Contracts,Impls,Rp0,Rpx).
  pickupPieces(_,_,[],[],[],[],[],Rp,Rp).

  pickupTerm:(string,list[ast],list[token],tipe,list[(string,tipe)],list[(visibility,pkg)],
          list[(string,string,tipe)],list[conDef],list[implDef],report,report){}.
  pickupTerm("import",[Vz,Pk,Vr],Rest,Export,Types,[(decodeViz(Vz),pkg(decodePkg(Pk),decodeVers(Vr))),..Imports],Classes,Contracts,Impls,Rp,Rpx) :-
    pickupPieces(Rest,Export,Types,Imports,Classes,Contracts,Impls,Rp,Rpx).
  pickupTerm("export",[Strg],Rest,decodeSignature(Sig),Types,Imports,Classes,Contracts,Impls,Rp,Rpx) :-
    isString(Strg,_,Sig),
    pickupPieces(Rest,_,Types,Imports,Classes,Contracts,Impls,Rp,Rpx).
  pickupTerm("classes",[Strg],Rest,Export,Types,Imports,Classes,Contracts,Impls,Rp,Rpx) :-
    isString(Strg,_,Sig),
    pickupClasses(decodeTuple(Sig),Classes,Cls),
    pickupPieces(Rest,Export,Types,Imports,Cls,Contracts,Impls,Rp,Rpx).
  pickupTerm("types",[Strg],Rest,Export,decodeTypes(Sig),Imports,Classes,Contracts,Impls,Rp,Rpx) :-
    isString(Strg,_,Sig),
    pickupPieces(Rest,Export,_,Imports,Cls,Contracts,Impls,Rp,Rpx).
  pickupTerm("contracts",[Strg],Rest,Export,Types,Imports,Classes,Contracts,Impls,Rp,Rpx) :-
    isString(Strg,_,Sig),
    findContracts(decodeTuple(Sig),Contracts,Cs),
    pickupPieces(Rest,Export,Types,Imports,Classes,Cs,Impls,Rp,Rpx).
  pickupTerm("implementations",[Strg],Rest,Export,Types,Imports,Classes,Contracts,Impls,Rp,Rpx) :-
    isString(Strg,_,Sig),
    pickupImplementations(decodeTuple(Sig),Impls,Is),
    pickupPieces(Rest,Export,Types,Imports,Cls,Contracts,Is,Rp,Rpx).

  decodeTypes:(string) => list[(string,tipe)].
  decodeTypes(Txt) => F :- decodeType(faceType(F)) %% explode(Txt).

  decodeViz:(ast)=>visibility.
  decodeViz(P) => pUblic :-
    isIden(P,_,"public").
  decodeViz(_) => priVate.

  decodePkg:(ast)=>string.
  decodePkg(P)=>Pk :-
    isString(P,_,Pk).

  decodeVers:(ast)=>version.
  decodeVers(V)=>defltVersion :-
    isIden(V,_,"*").
  decodeVers(V)=>vers(VV) :-
    isString(V,_,VV).

  pickupClasses:(list[term],list[(string,string,tipe)],list[(string,string,tipe)]){}.
  pickupClasses([],Cls,Cls).
  pickupClasses([tupl([strng(Nm),strng(Cl),strng(Sig)]),..Rest],[(Nm,Cl,decodeSignature(Sig)),..More],Cls):-
    pickupClasses(Rest,More,Cls).

  findContracts:(list[term],list[conDef],list[conDef]){}.
  findContracts([],C,C).
  findContracts([tupl([strng(Nm),strng(CnNm),strng(Sig),strng(FSig)]),..M],[conDef(Nm,CnNm,Spec,FullSpec,decodeSignature(FSig)),..C],Cx) :-
    decodeConstraint(Sig,FullSpec),
    moveConQuants(FullSpec,Q,FS),
    moveConConstraints(FS,_,S),
    moveConQuants(Spec,Q,S),
    findContracts(M,C,Cx).

  pickupImplementations:(list[term],list[implDef],list[implDef]){}.
  pickupImplementations([],I,I).
  pickupImplementations([tupl([strng(Nm),strng(Sig)]),..M],[impl(Nm,Spec),..I],RI) :-
    decodeConstraint(Sig,Spec),
    pickupImplementations(M,I,RI).

  private decodeSignature:(string) => tipe.
  decodeSignature(S) => T :- decodeType(T) %% explode(S).

  private splitOnHash:(string) => string.
  splitOnHash(S) => pathSuffix(S,"#").
}