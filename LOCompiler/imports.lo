lo.comp.imports{
  import lo.
  import lo.uri.
  import lo.resources.
  import lo.repo.

  import lo.comp.dict.
  import lo.comp.types.
  import lo.comp.term.
  import lo.comp.misc.
  import lo.comp.decode.
  import lo.comp.package.
  import lo.comp.errors.
  import lo.comp.token.
  import lo.comp.lexer.
  import lo.comp.grammar.
  import lo.comp.ast.
  import lo.comp.abstract.
  import lo.comp.canon.

  public importPkg:all r ~~ repository[r] |: (pkg,r,pkgSpec,report,report){}.
  importPkg(pkg(Pkg,Vers),Repo,pkgSpec(IPkg,Export,Types,Enums,Contracts,Impls,Imports),Rp,Rpx) :-
    loadFromRepo(Repo,pkg(Pkg,Vers),"prolog",Strm),
    parse(A,Rp,Rp0) %% getNTokens(explode(Strm),Pkg,5)!,
    pickupPkgSpec(A,IPkg,Imports,Export,Types,Enums,Contracts,Impls,Rp0,Rpx)!.

  pickupPkgSpec:(ast,pkg,list[(visibility,pkg)],list[(string,tipe)],list[(string,tipe)],list[string],list[conEntry],list[implEntry],report,report){}.
  pickupPkgSpec(Term,Pkg,decodeImports(Is),Fields,Types,Enums,Contracts,Impls,Rp,Rp) :-
    isUnary(Term,"#pkg",_,E),
    isString(E,_,Enc),
    pkgSpec(Pkg,Fields,Types,Enums,Contracts,Impls,Imports) = unwrapSpec(decodeValue(Enc)),
    
    cons(_,[Pk,cons(_,Is),Ex,Tp,cons(_,C),cons(_,Co),cons(_,Im)]) = decodeValue(Enc),
    faceType(Fields) = decodeSignature(Ex),
    faceType(Types) = decodeSignature(Tp),
    pickupEnums(C,Enums,[]),
    findContracts(Co,Contracts,[]),
    pickupImplementations(Im,Impls,[]).

      public type pkgSpec ::= pkgSpec(pkg,list[(string,tipe)],list[(string,tipe)],list[string],list[conEntry],list[implEntry],list[(visibility,pkg)]).


  public importPkgs:all r ~~ repository[r] |: (list[pkg],list[pkgSpec],r,report,report) => list[pkgSpec].
  importPkgs([],Specs,_,Rp,Rp) => Specs.
  importPkgs([Pkg,..L],SoFar,Repo,Rp,Rpx) => importPkgs(L,SoFar,Repo,Rp,Rpx) :- alreadyImported(Pkg,SoFar).
  importPkgs([Pkg,..L],SoFar,Repo,Rp,Rpx) => importPkgs(L,[Spec,..SoFar],Repo,Rp0,Rpx) :-
    importPkg(Pkg,Repo,Spec,Rp,Rp0).

  public importClosure:all r ~~ repository[r] |: (list[pkg],list[pkgSpec],r,report,report) => list[pkgSpec].
  importClosure([],Specs,_,Rp,Rp) => Specs.
  importClosure([Pkg,..L],SoFar,Repo,Rp,Rpx) => importClosure(L,SoFar,Repo,Rp,Rpx) :- alreadyImported(Pkg,SoFar).
  importClosure([Pkg,..L],SoFar,Repo,Rp,Rpx) => importClosure(L,importClosure(publicImports(importsOfSpec(Spec)),[Spec,..SoFar],Repo,Rp0,Rp1),Repo,Rp1,Rpx) :-
    importPkg(Pkg,Repo,Spec,Rp,Rp0).

  alreadyImported:(pkg,list[pkgSpec]){}.
  alreadyImported(Pkg,Specs) :- pkgSpec(Pk,_,_,_,_,_,_) in Specs, consistentPkg(Pkg,Pk).

  public consistentPkg:(pkg,pkg){}.
  consistentPkg(pkg(P,V1),pkg(P,V2)) :- consistentVersion(V1,V2)!.

  consistentVersion:(version,version){}.
  consistentVersion(defltVersion,_).
  consistentVersion(vers(V),vers(V)).

  importsOfSpec:(pkgSpec) => list[(visibility,pkg)].
  importsOfSpec(pkgSpec(_,_,_,_,_,_,Imps)) => Imps.

  publicImports:(list[(visibility,pkg)]) => list[pkg].
  publicImports([]) => [].
  publicImports([(pUblic,Pkg),..L]) => [Pkg,..publicImports(L)].
  publicImports([(priVate,_),..L]) => publicImports(L).



  private splitOnHash:(string) => string.
  splitOnHash(S) => pathSuffix(S,"#").
}
