lo.comp.parseType{
  import lo.
  import lo.comp.types.
  import lo.comp.ast.
  import lo.comp.abstract.
  import lo.comp.wff.
  import lo.comp.dict.
  import lo.comp.unify.
  import lo.comp.errors.
  import lo.comp.location.
  import lo.comp.freshen.
  import lo.comp.canon.

  public
  parseType:(ast,list[env],tipe,report,report){}.
  parseType(T,Env,Type,Rp,Rpx) :-
    prsType(T,Env,{},[],Cons,Tp,Rp,Rpx),
    moveConstraints(Type,Cons,Tp).

  public parseTypeDefinition:(string,location,ast,list[canonDef],list[canonDef],list[env],string,report,report){}.
  parseTypeDefinition(N,Lc,St,[typeDef(Lc,N,Type,FaceRule),..Defs],Defs,Env,Path,Rp,Rpx) :-
    isUnary(St,"type",_,InSt),
    parseTypeRule(InSt,{},Env,FaceRule,Path,Rp,Rpx),
    isType(N,Env,Type).

  parseTypeRule:(ast,map[string,tipe],list[env],tipe,string,report,report){}.
  parseTypeRule(St,_,_,Env,Rule,Path,Rp,Rpx) :-
    isQuantified(St,V,Body),
    parseTypeBound(V,{},B,Env,Rule,Rl),
    parseTypeRule(Body,B,Env,Inner,Path,Rp,Rpx),
    wrapQuants(B,Inner,Rl).
  parseTypeRule(St,B,Env,Rule,Path,Rp,Rpx) :-
    isBinary(St,"|:",_,L,R),
    parseConstraint(L,Env,B,[],Cx,Rp,Rp0),
    parseTypeRule(R,B,Env,Inner,Path,Rp0,Rpx),
    wrapConstraints(Cx,Inner,Rule).
  parseTypeRule(St,B,Env,typeRule(Lhs,Rhs),Path,Rp,Rpx) :-
    isBinary(St,"<~",_,L,R),
    parseTypeHead(L,B,Env,Lhs,Path,Rp,Rp0),
    parseType(R,Env,B,C0,Cx,Tp,Rp0,Rpx),
    faceOfType(deRef(Tp),Env,Rhs).

  private
  prsType : (ast,list[env],map[string,tipe],list[constraint],list[constraint],tipe,report,report){}.
  prsType(T,Env,Q,Cx,Cx,PT,Rp,Rpx) :-
    isQuantified(T,V,BT),
    parseTypeBound(V,Q,B0,Env,PT,Inner),
    prsType(BT,Env,B0,[],C0,BTp,Rp,Rpx),
    moveConstraints(Inner,C0,BTp). -- no constraints migrate out of quantified type
  prsType(T,Env,Q,C,Cx,Type,Rp,Rpx) :-
    isBinary(T,"|:",_,L,R),
    parseConstraint(L,Env,Q,C,C0,Rp,Rp0),
    prsType(R,Env,Q,C0,Cx,Type,Rp0,Rpx). -- This has the effect of pulling all constraints to the outside
  prsType(T,Env,Q,C,Cx,Tp,Rp,Rpx) :-
    isIden(T,Lc,Nm),
    prsTypeName(Lc,Nm,Env,Q,C,Cx,Tp,Rp,Rpx).
  prsType(Sq,Env,Q,C,Cx,Type,Rp,Rpx) :-
    isSquareTerm(Sq,Lc,Op,Args), 
    isIden(Op,_,Nm),
    prsTypeName(Lc,N,Env,Q,C,C0,TpCon,Rp,Rp0),
    prsTypes(Args,Env,Q,C0,Cx,ArgTps,Rp0,Rp1),
    applyTypeExp(TpCon,ArgTps,Lc,Type,Rp1,Rpx). -- should do this too:  sameType(tupleType(ATs),tupleType(ArgTps),Env).
  prsType(F,Env,Q,C,Cx,funType(AT,RT),Rp,Rpx) :-
    isBinary(F,"=>",_,L,R),
    prsType(L,Env,Q,C,C1,AT,Rp,Rp0),
    prsType(R,Env,Q,C1,Cx,RT,Rp0,Rpx).
  prsType(F,Env,Q,C,Cx,grammarType(AT,RT),Rp,Rpx) :-
    isBinary(F,"-->",_,L,R),
    prsType(L,Env,Q,C,C1,AT,Rp,Rp0),
    prsType(R,Env,Q,C1,Cx,RT,Rp0,Rpx).
  prsType(F,Env,Q,C,Cx,classType(AT,RT),Rp,Rpx) :-
    isBinary(F,"<=>",_,L,R),
    prsType(L,Env,Q,C,C1,AT,Rp,Rp0),
    prsType(R,Env,Q,C1,Cx,RT,RP,Rp0).
  prsType(T,Env,Q,C,Cx,predType(AT),Rp,Rpx) :-
    isBraceTerm(T,_,L,[]),
    prsType(L,Env,Q,C,Cx,AT,Rp,Rpx).
  prsType(T,Env,Q,C,Cx,tupleType(AT),Rp,Rpx) :-
    isRoundTuple(T,_,[A]), 
    isRoundTuple(A,_,Inner),
    prsTypes(Inner,Env,Q,C,Cx,AT,Rp,Rpx).
  prsType(T,Env,Q,C,Cx,AT,Rp,Rpx) :-
    isRoundTuple(T,_,[A]),
    prsType(A,Env,Q,C,Cx,AT,Rp,Rpx).
  prsType(T,Env,Q,C,Cx,tupleType(AT),Rp,Rpx) :-
    isRoundTuple(T,_,A),
    prsTypes(A,Env,Q,C,Cx,AT,Rp,Rpx).
  prsType(T,Env,Q,C,Cx,faceType(AT),Rp,Rpx) :-
    isBraceTuple(T,_,L),
    prsTypeFields(L,Env,Q,C,Cx,AT,Rp,Rpx).
  prsType(T,_,_,Cx,Cx,anonType,Rp,Rpx) :-
    Prx=reportError("cannot understand type $(T)",T.loc,Rp).

  private
  applyTypeExp:(tipe,list[tipe],location,tipe,report,report){}.
  applyTypeExp(typeExp(Op,A),Args,_,typeExp(Op,Args),Rp,Rp) :-
    length(A) = length(Args).
  applyTypeExp(T,Args,Lc,voidType,Rp,Rpx) :-
    Rpx=reportError("cannot apply type exp $(T) to $(Args)",Lc,Rp).

  private
  prsTypes:(list[ast],list[env],map[string,tipe],list[constraint],list[constraint],list[tipe],report,report){}.
  prsTypes([],_,_,C,C,[],Rp,Rp).
  prsTypes([T,..R],Env,Q,C,Cx,[PT,..M],Rp,Rpx) :-
    prsType(T,Env,Q,C,C0,PT,Rp,Rp0),
    prsTypes(R,Env,Q,C0,Cx,M,Rp0,Rpx).

  private
  prsTypeFields:(list[ast],list[env],map[string,tipe],list[constraint],list[constraint],list[(string,tipe)],report,report){}.
  prsTypeFields([],_,_,B,B,[],Rp,Rp).
  prsTypeFields([A,..AT],Env,Q,C,Cx,[(Fld,FldTp),..ArgTypes],Rp,Rp) :-
    isBinary(A,":",_,L,R),
    isIden(L,_,Fld),
    prsType(R,Env,Q,C,C0,FldTp,Rp,Rp0),
    prsTypeFields(AT,Env,Q,C0,Cx,ArgTypes,Rp0,Rpx).
  prsTypeFields([A,..AT],Env,Q,C,Cx,ArgTypes,Rp,Rpx) :-
    Rp0=reportError("$(A) is not a valid field designator",A.loc,Rp),
    prsTypeFields(AT,Env,Q,C,Cx,ArgTypes,Rp0,Rpx).

  prsTypeName:(location,string,list[env],map[string,tipe],list[constraint],list[constraint],tipe,report,report){}.
  prsTypeName(_,"_",_,_,C,C,anonType,Rp,Rp).
  prsTypeName(_,"void",_,_,C,C,voidType,Rp,Rp).
  prsTypeName(_,"this",_,_,C,C,thisType,Rp,Rp).
  prsTypeName(_,Id,_,{Id->Tp},C,C,Tp,Rp,Rp).
  prsTypeName(_,Id,Env,_,C,Cx,Type,Rp,Rp) :- 
    isType(Id,Env,_,Tp),
    moveConstraints(freshen(Tp,{}),C0,Type),
    mergeConstraints(C0,C,Cx).
  prsTypeName(Lc,Id,_,_,C,C,anonType,Rp,Rpx) :- 
    Rpx=reportError("type $(Id) not declared",Lc,Rp).

  public parseTypeBound:(ast,map[string,tipe],map[string,tipe],list[env],tipe,tipe){}.
  parseTypeBound(P,BV,Bound,Env,QT,Inner) :-
    isBinary(P,",",_,L,R),
    parseTypeBound(L,BV,B0,Env,QT,Q0),
    parseTypeBound(R,B0,Bound,Env,Q0,Inner).
  parseTypeBound(V,B,B1,Env,univType(kVar(Nm),Inner),Inner) :-
    B1 = B+{Nm->kVar(Nm)},
    isIden(V,_,Nm).

  public parseConstraint:(ast,list[env],map[string,tipe],list[constraint],list[constraint],report,report){}.
  parseConstraint(T,Env,B,C0,Cx,Rp,Rpx) :-
    isBinary(T,",",_,L,R),
    parseConstraint(L,Env,B,C0,C1,Rp,Rp0),
    parseConstraint(R,Env,B,C1,Cx,RP0,Rpx).
  parseConstraint(T,Env,B,C0,Cx,Rp,Rpx) :-
    isBinary(T,"<~",_,L,R),
    prsType(L,Env,B,C0,C1,TV,RP,Rp0),
    isBraceTuple(R,_,E),
    prsTypeFields(E,Env,B,C1,C2,AT,Rp0,Rpx).
    addConstraint(implementsFace(TV,AT),C2,Cx).
  parseConstraint(Sq,Env,B,C0,Cx,Rp,Rpx) :- 
    isSquareTerm(Sq,Lc,Op,Args),
    isIden(Op,_,Nm),
    parseContractName(Lc,N,Env,conTract(Nm,_ATs,_Dps),Rp,Rp0),
    parseContractArgs(Args,Env,B,C0,C1,ArgTps,Deps,Rp0,Rpx),
    addConstraint(conTract(Nm,ArgTps,Deps),C1,Cx).
  parseConstraint(T,_,B,C,C,Rp,Rpx) :-
    Rpx=reportError("invalid type constraint $(T)",T.loc,Rp).

  mergeConstraints:(list[constraint],list[constraint],list[constraint]){}.
  mergeConstraints([],C,C).
  mergeConstraints([C0,..L],C,Cx) :-
    addConstraint(C0,C,C1),
    mergeConstraints(L,C1,Cx).

  addConstraint:(constraint,list[constraint],list[constraint]){}.
  addConstraint(Con,C0,C0) :- Con in C0!.
  addConstraint(Con,C0,[Con,..C0]) :- \+Con in C0.

  parseContractName:(location,string,list[env],constraint,report,report){}.
  parseContractName(_,Id,Env,freshen(Spec,{}),Rp,Rp) :-
    isContract(Id,Env,conDef(_,_,Spec,_,_)).
  parseContractName(Lc,Id,_,conTract(Id,[],[]),Rp,Rpx) :- 
    Rpx=reportError("contract $(Id) not declared",Lc,Rp).

  parseContractArgs:(list[ast],list[env],map[string,tipe],list[constraint],list[constraint],list[tipe],list[tipe],report,report){}.
  parseContractArgs([A],Env,B,C0,Cx,Args,Deps,Rp,Rpx) :-
    isBinary(A,"->>",_,L,R),
    prsTypes(deComma(L),Env,B,C0,C1,Args,Rp,Rp0),
    prsTypes(deComma(R),Env,B,C1,Cx,Deps,Rp0,Rpx).
  parseContractArgs(A,Env,B,C0,Cx,Args,[],Rp,Rpx) :-
    prsTypes(A,Env,B,C0,Cx,Args,Rp,Rpx).

  public parseTypeTemplate:(ast,map[string,tipe],list[env],tipe,string,report,report){}.
  parseTypeTemplate(St,B,Env,Type,Path,Rp,Rpx) :-
    isUnary(St,"type",L),
    parseTpTemplate(L,B,Env,[],Cx,Tp,Path,Rp,Rpx),
    wrapConstraints(Cx,Tp,Type).

  parseTpTemplate:(ast,map[string,tipe],list[env],list[constraint],list[constraint],tipe,string,report,report){}.
  parseTpTemplate(St,B,Env,C,C,Type,Path,Rp,Rx) :-
    isQuantified(St,V,Body),
    parseTypeBound(V,B,BB,Type,Tmplte),
    parseTpTemplate(Body,BB,Env,[],Cx,Inner,Path),
    wrapConstraints(Cx,Inner,Tmplte).
  parseTpTemplate(St,B,Env,C0,Cx,Type,Path) :-
    isBinary(St,"|:",L,R),
    parseConstraint(L,Env,B,C0,C1),
    parseTpTemplate(R,B,Env,C1,Cx,Type,Path).
  parseTpTemplate(St,B,Env,Cx,Cx,Type,Path,Rp,Rpx) :-
    isBinary(St,"<~",L,_),
    parseTypeHead(L,B,Env,Type,Path,Rp,Rpx),!.

  parseTypeHead:(ast,map[string,tipe],tipe,string,report,report){}.
  parseTypeHead(N,_,_,type(TpNm),Path,Rp,Rp) :-
    isIden(N,_,Nm),
    marker(type,Marker),
    subPath(Path,Marker,Nm,TpNm).
  parseTypeHead(N,B,_,typeExp(TpNm,Args),Path,Rp,Rpx) :-
    isSquare(N,_,Nm,A),
    parseHeadArgs(A,B,Args,Rp,Rpx),
    marker(type,Marker),
    subPath(Path,Marker,Nm,TpNm).
  
  parseHeadArgs:(list[ast],map[string,tipe],list[tipe],report,report){}.
  parseHeadArgs([],_,[],Rp,Rp).
  parseHeadArgs([H,..L],B,[V,..Args],Rp,Rpx) :-
    isIden(H,Lc,Nm),
    (is_member((Nm,V),B) ? Rp=Rpx0 | Rp0=reportError("type argument $(H) not quantified ",Lc,Rp)),
    parseHeadArgs(L,B,Args,Rp0,Rpx).


  -- reapply quantifiers to a type to get full form
  reQuant([],Tp,Tp).
  reQuant([(Nm,_),..M],Tp,QTp) :-
    reQuant(M,univType(kVar(Nm),Tp),QTp).

  wrapConstraints:(list[constraint],tipe,tipe){}.
  wrapConstraints([],Tp,Tp).
  wrapConstraints([Con,..C],Tp,WTp) :-
    wrapConstraints(C,constrained(Tp,Con),WTp).
}