lo.comp.parseType{
  import lo.
  import lo.comp.types.
  import lo.comp.ast.
  import lo.comp.abstract.
  import lo.comp.wff.
  import lo.comp.dict.
  import lo.comp.unify.
  import lo.comp.errors.
  import lo.comp.location.
  import lo.comp.freshen.
  import lo.comp.canon.
  import lo.comp.misc.

  public
  parseType:(ast,list[env],tipe,report,report){}.
  parseType(T,Env,Type,Rp,Rpx) :-
    prsType(T,Env,[],[],Cons,Tp,Rp,Rpx),
    moveConstraints(Type,Cons,Tp).

  public parseTypeRule:(ast,map[string,tipe],list[env],tipe,string,report,report){}.
  parseTypeRule(St,_,Env,Rule,Path,Rp,Rpx) :-
    isQuantified(St,V,Body),
    parseTypeBound(V,[],B,Env,Rule,Rl),
    parseTypeRule(Body,B,Env,Inner,Path,Rp,Rpx),
    reQuant(pairs(B),Inner,Rl).
  parseTypeRule(St,B,Env,Rule,Path,Rp,Rpx) :-
    isBinary(St,"|:",_,L,R),
    parseConstraint(L,Env,B,[],Cx,Rp,Rp0),
    parseTypeRule(R,B,Env,Inner,Path,Rp0,Rpx),
    wrapConstraints(Cx,Inner,Rule).
  parseTypeRule(St,B,Env,typeRule(Lhs,Rhs),Path,Rp,Rpx) :-
    isBinary(St,"<~",_,L,R),
    parseTypeHead(L,B,Lhs,Path,Rp,Rp0),
    prsType(R,Env,B,C0,Cx,Tp,Rp0,Rpx),
    faceOfType(deRef(Tp),Env,Rhs).

  private prsArgType:(ast,list[env],map[string,tipe],list[constraint],list[constraint],tipe,report,report){}.
  prsArgType(T,Env,Q,C,Cx,tupleType(AT),Rp,Rpx) :-
    isRoundTuple(T,_,A),
    prsTypes(A,Env,Q,C,Cx,AT,Rp,Rpx).
  prsArgType(T,Env,Q,C,Cx,AT,Rp,Rpx) :-
    prsType(T,Env,Q,C,Cx,AT,Rp,Rpx).

  private prsType:(ast,list[env],map[string,tipe],list[constraint],list[constraint],tipe,report,report){}.
  prsType(T,Env,Q,Cx,Cx,PT,Rp,Rpx) :-
    isQuantified(T,V,BT),
    parseTypeBound(V,Q,B0,Env,PT,Inner),
    prsType(BT,Env,B0,[],C0,BTp,Rp,Rpx),
    moveConstraints(Inner,C0,BTp). -- no constraints migrate out of quantified type
  prsType(T,Env,Q,C,Cx,Type,Rp,Rpx) :-
    isBinary(T,"|:",_,L,R),
    parseConstraint(L,Env,Q,C,C0,Rp,Rp0),
    prsType(R,Env,Q,C0,Cx,Type,Rp0,Rpx). -- This has the effect of pulling all constraints to the outside
  prsType(T,Env,Q,C,Cx,Tp,Rp,Rpx) :-
    isIden(T,Lc,Nm),
    prsTypeName(Lc,Nm,Env,Q,C,Cx,Tp,Rp,Rpx).
  prsType(Sq,Env,Q,C,Cx,Type,Rp,Rpx) :-
    isSquareTerm(Sq,Lc,Op,Args), 
    isIden(Op,_,Nm),
    prsTypeName(Lc,Nm,Env,Q,C,C0,TpCon,Rp,Rp0),
    prsTypes(Args,Env,Q,C0,Cx,ArgTps,Rp0,Rp1),
    applyTypeExp(TpCon,ArgTps,Lc,Type,Rp1,Rpx). -- should do this too:  sameType(tupleType(ATs),tupleType(ArgTps),Env).
  prsType(F,Env,Q,C,Cx,funType(AT,RT),Rp,Rpx) :-
    isBinary(F,"=>",_,L,R),
    prsArgType(L,Env,Q,C,C1,AT,Rp,Rp0),
    prsType(R,Env,Q,C1,Cx,RT,Rp0,Rpx).
  prsType(F,Env,Q,C,Cx,grammarType(AT,RT),Rp,Rpx) :-
    isBinary(F,"-->",_,L,R),
    prsArgType(L,Env,Q,C,C1,AT,Rp,Rp0),
    prsType(R,Env,Q,C1,Cx,RT,Rp0,Rpx).
  prsType(F,Env,Q,C,Cx,classType(AT,RT),Rp,Rpx) :-
    isBinary(F,"<=>",_,L,R),
    prsArgType(L,Env,Q,C,C1,AT,Rp,Rp0),
    prsType(R,Env,Q,C1,Cx,RT,RP,Rp0).
  prsType(T,Env,Q,C,Cx,predType(AT),Rp,Rpx) :-
    isBraceTerm(T,_,L,[]),
    prsType(L,Env,Q,C,Cx,AT,Rp,Rpx).
  prsType(T,Env,Q,C,Cx,tupleType(AT),Rp,Rpx) :-
    isRoundTuple(T,_,[A]), 
    isRoundTuple(A,_,Inner),
    prsTypes(Inner,Env,Q,C,Cx,AT,Rp,Rpx).
  prsType(T,Env,Q,C,Cx,AT,Rp,Rpx) :-
    isRoundTuple(T,_,[A]),
    prsType(A,Env,Q,C,Cx,AT,Rp,Rpx).
  prsType(T,Env,Q,C,Cx,tupleType(AT),Rp,Rpx) :-
    isRoundTuple(T,_,A),
    prsTypes(A,Env,Q,C,Cx,AT,Rp,Rpx).
  prsType(T,Env,Q,C,Cx,faceType(AT),Rp,Rpx) :-
    isBraceTuple(T,_,L),
    prsTypeFields(L,Env,Q,C,Cx,AT,Rp,Rpx).
  prsType(T,_,_,Cx,Cx,anonType,Rp,Rpx) :-
    reportError("cannot understand type $(T)",T.loc,Rp,Rpx).

  private applyTypeExp:(tipe,list[tipe],location,tipe,report,report){}.
  applyTypeExp(typeExp(Op,A),Args,_,typeExp(Op,Args),Rp,Rp) :-
    length(A) = length(Args).
  applyTypeExp(T,Args,Lc,voidType,Rp,Rpx) :-
    reportError("cannot apply type exp $(T) to $(Args)",Lc,Rp,Rpx).

  private prsTypes:(list[ast],list[env],map[string,tipe],list[constraint],list[constraint],list[tipe],report,report){}.
  prsTypes([],_,_,C,C,[],Rp,Rp).
  prsTypes([T,..R],Env,Q,C,Cx,[PT,..M],Rp,Rpx) :-
    prsType(T,Env,Q,C,C0,PT,Rp,Rp0),
    prsTypes(R,Env,Q,C0,Cx,M,Rp0,Rpx).

  private prsTypeFields:(list[ast],list[env],map[string,tipe],list[constraint],list[constraint],list[(string,tipe)],report,report){}.
  prsTypeFields([],_,_,Cx,Cx,[],Rp,Rp).
  prsTypeFields([A,..AT],Env,Q,C,Cx,[(Fld,FldTp),..ArgTypes],Rp,Rp) :-
    isBinary(A,":",_,L,R),
    isIden(L,_,Fld),
    prsType(R,Env,Q,C,C0,FldTp,Rp,Rp0),
    prsTypeFields(AT,Env,Q,C0,Cx,ArgTypes,Rp0,Rpx).
  prsTypeFields([A,..AT],Env,Q,C,Cx,ArgTypes,Rp,Rpx) :-
    reportError("$(A) is not a valid field designator",A.loc,Rp,Rp0),
    prsTypeFields(AT,Env,Q,C,Cx,ArgTypes,Rp0,Rpx).

  prsTypeName:(location,string,list[env],map[string,tipe],list[constraint],list[constraint],tipe,report,report){}.
  prsTypeName(_,"_",_,_,C,C,anonType,Rp,Rp).
  prsTypeName(_,"void",_,_,C,C,voidType,Rp,Rp).
  prsTypeName(_,"this",_,_,C,C,thisType,Rp,Rp).
  prsTypeName(_,Id,_,B,C,C,Tp,Rp,Rp) :- present(B,Id,Tp).
  prsTypeName(_,Id,Env,_,C,Cx,Type,Rp,Rp) :- 
    isType(Id,Env,_,Tp),
    (_,FT) = freshen(Tp,[]),
    moveConstraints(FT,C0,Type),
    mergeConstraints(C0,C,Cx).
  prsTypeName(Lc,Id,_,_,C,C,anonType,Rp,Rpx) :- 
    reportError("type $(Id) not declared",Lc,Rp,Rpx).

  public parseTypeBound:(ast,map[string,tipe],map[string,tipe],list[env],tipe,tipe){}.
  parseTypeBound(P,BV,Bound,Env,QT,Inner) :-
    isBinary(P,",",_,L,R),
    parseTypeBound(L,BV,B0,Env,QT,Q0),
    parseTypeBound(R,B0,Bound,Env,Q0,Inner).
  parseTypeBound(V,B,B1,Env,univType(kVar(Nm),Inner),Inner) :-
    isIden(V,_,Nm),
    B1 = B+[Nm->kVar(Nm)].

  public parseContract:(ast,list[env],string,canonDef,report,report){}.
  parseContract(T,Env,Path,cnDefn(T.loc,Nm,Spec,Face),Rp,Rpx) :-
    isUnary(T,"contract",_,TI),
    parseContractSpec(TI,F,[],Q,[],C0,Env,Spc,Nm,Path,Rp,Rp0),
    isBraceTuple(F,_,TLs),
    prsTypeFields(TLs,Env,Q,C0,_,Fc,Rp0,Rpx),
    PQ = pairs(Q),
    reQuant(PQ,faceType(Fc),Face),
    reConQuant(PQ,Spc,Spec),
    wrapConConstraints(C0,Spc,SpcC),
    reConQuant(PQ,SpcC,FullSpec).

  private parseContractSpec:(ast,ast,map[string,tipe],map[string,tipe],list[constraint],list[constraint],list[env],constraint,string,string,report,report){}.
  parseContractSpec(T,R,Q,Qx,C0,Cx,Env,Spec,Nm,Path,Rp,Rpx) :-
    isQuantified(T,V,B),
    parseConBound(V,Q,Q0,Env,_,_),
    parseContractSpec(B,R,Q0,Qx,C0,Cx,Env,Spec,Nm,Path,Rp,Rpx).
  parseContractSpec(T,F,Q,Qx,C0,Cx,Env,Spec,Nm,Path,Rp,Rpx) :-
    isBinary(T,"|:",_,L,R),
    reportError("constrained contract $(T) not supported",Lc,Rp,Rp0),
    parseContractSpec(R,F,Q,Qx,C1,Cx,Env,Spec,Nm,Path,Rp0,Rpx).
  parseContractSpec(T,F,Q,Q,C,Cx,Env,Spec,Nm,Path,Rp,Rpx) :-
    isBinary(T,"<~",Lc,L,F),
    parseContractHead(L,Q,C,Cx,Env,Spec,Nm,Path,Rp,Rpx).

  private parseContractHead:(ast,map[string,tipe],list[constraint],list[constraint],list[env],constraint,string,string,report,report){}.
  parseContractHead(T,Q,C,Cx,Env,conTract(ConNm,ArgTps,Deps),ConNm,Path,Rp,Rpx) :-
    isSquareTerm(T,Lc,Op,A),
    isIden(Op,_,Nm),
    ConNm = subPath(Path,marker(con),Nm),
    parseContractArgs(A,Env,Q,C,Cx,ArgTps,Deps,Rp,Rpx).

  public parseConstraint:(ast,list[env],map[string,tipe],list[constraint],list[constraint],report,report){}.
  parseConstraint(T,Env,B,C0,Cx,Rp,Rpx) :-
    isBinary(T,",",_,L,R),
    parseConstraint(L,Env,B,C0,C1,Rp,Rp0),
    parseConstraint(R,Env,B,C1,Cx,Rp0,Rpx).
  parseConstraint(T,Env,B,C0,Cx,Rp,Rpx) :-
    isBinary(T,"<~",_,L,R),
    prsType(L,Env,B,C0,C1,TV,Rp,Rp0),
    isBraceTuple(R,_,E),
    prsTypeFields(E,Env,B,C1,C2,AT,Rp0,Rpx),
    addConstraint(implementsFace(TV,AT),C2,Cx).
  parseConstraint(Sq,Env,B,C0,Cx,Rp,Rpx) :- 
    isSquareTerm(Sq,Lc,Op,Args),
    isIden(Op,Lc0,Nm),
    parseContractName(Lc0,Nm,Env,conTract(ConNm,_ATs,_Dps),Rp,Rp0),
    parseContractArgs(Args,Env,B,C0,C1,ArgTps,Deps,Rp0,Rpx),
    addConstraint(conTract(ConNm,ArgTps,Deps),C1,Cx).
  parseConstraint(T,_,B,C,C,Rp,Rpx) :-
    reportError("invalid type constraint $(T)",T.loc,Rp,Rpx).

  mergeConstraints:(list[constraint],list[constraint],list[constraint]){}.
  mergeConstraints([],C,C).
  mergeConstraints([C0,..L],C,Cx) :-
    addConstraint(C0,C,C1),
    mergeConstraints(L,C1,Cx).

  addConstraint:(constraint,list[constraint],list[constraint]){}.
  addConstraint(Con,C0,C0) :- Con in C0!.
  addConstraint(Con,C0,[Con,..C0]) :- \+Con in C0.

  parseContractName:(location,string,list[env],constraint,report,report){}.
  parseContractName(_,Id,Env,Con,Rp,Rp) :-
    isContract(Id,Env,conEntry(_,Spec,_)),
    (_,Con) = freshen(Spec,[]).
  parseContractName(Lc,Id,_,conTract(Id,[],[]),Rp,Rpx) :- 
    reportError("contract $(Id) not declared",Lc,Rp,Rpx).

  parseContractArgs:(list[ast],list[env],map[string,tipe],list[constraint],list[constraint],list[tipe],list[tipe],report,report){}.
  parseContractArgs([A],Env,B,C0,Cx,Args,Deps,Rp,Rpx) :-
    isBinary(A,"->>",_,L,R),
    prsTypes(deComma(L),Env,B,C0,C1,Args,Rp,Rp0),
    prsTypes(deComma(R),Env,B,C1,Cx,Deps,Rp0,Rpx).
  parseContractArgs(A,Env,B,C0,Cx,Args,[],Rp,Rpx) :-
    prsTypes(A,Env,B,C0,Cx,Args,Rp,Rpx).

  public parseContractConstraint:(ast,list[env],string,constraint,report,report){}.
  parseContractConstraint(T,Env,N,Con,Rp,Rpx) :-
    parseContractCon(T,Env,[],[],Cons,N,Tp,Rp,Rpx)!,
    wrapConConstraints(Cons,Tp,Con).
 
  private parseContractCon:(ast,list[env],map[string,tipe],list[constraint],list[constraint],string,constraint,report,report){}.
  parseContractCon(Tp,Env,B,C,C,N,PT,Rp,Rpx) :-
    isQuantified(Tp,V,BT),
    parseConBound(V,B,B0,Env,PT,Inner),
    parseContractCon(BT,Env,B0,[],C0,N,BTp,Rp,Rpx),
    wrapConConstraints(C0,BTp,Inner).
  parseContractCon(Tp,Env,B,C0,Cx,N,Cn,Rp,Rpx) :-
    isBinary(Tp,"|:",_,L,R),
    parseConstraint(L,Env,B,C0,C1,Rp,Rp0),
    parseContractCon(R,Env,B,C1,Cx,N,Cn,Rp0,Rpx).
  parseContractCon(Sq,Env,Q,C0,Cx,N,conTract(Op,ArgTps,Deps),Rp,Rpx) :-
    isSquareTerm(Sq,Lc,Nm,Args),
    isIden(Nm,_,N),
    parseContractArgs(Args,Env,Q,C0,Cx,ArgTps,Deps,Rp,Rp0),
    ( parseContractName(Lc,N,Env,conTract(Op,ATs,Dps),Rp0,Rpx) ?
        sameType(tupleType(ATs),tupleType(ArgTps),Env),
        sameType(tupleType(Dps),tupleType(Deps),Env)
      | reportError("contract $(N) not declared",Lc,Rp0,Rpx), Op = N).

  public parseConBound:(ast,map[string,tipe],map[string,tipe],list[env],constraint,constraint){}.
  parseConBound(P,BV,Bound,Env,QT,Inner) :-
    isBinary(P,",",_,L,R),
    parseConBound(L,BV,B0,Env,QT,Q0),
    parseConBound(R,B0,Bound,Env,Q0,Inner).
  parseConBound(V,B,B+[Nm->kVar(Nm)],Env,univCon(kVar(Nm),Inner),Inner) :-
    isIden(V,_,Nm).

  public parseTypeTemplate:(ast,list[env],tipe,string,report,report){}.
  parseTypeTemplate(St,Env,Type,Path,Rp,Rpx) :-
    isUnary(St,"type",_,L),
    parseTpTemplate(L,[],Env,[],Cx,Tp,Path,Rp,Rpx),
    wrapConstraints(Cx,Tp,Type).

  parseTpTemplate:(ast,map[string,tipe],list[env],list[constraint],list[constraint],tipe,string,report,report){}.
  parseTpTemplate(St,B,Env,C,C,Type,Path,Rp,Rpx) :-
    isQuantified(St,V,Body),
    parseTypeBound(V,B,BB,Env,Type,Tmplte),
    parseTpTemplate(Body,BB,Env,[],Cx,Inner,Path,Rp,Rpx),
    wrapConstraints(Cx,Inner,Tmplte).
  parseTpTemplate(St,B,Env,C0,Cx,Type,Path,Rp,Rpx) :-
    isBinary(St,"|:",_,L,R),
    parseConstraint(L,Env,B,C0,C1,Rp,Rp0),
    parseTpTemplate(R,B,Env,C1,Cx,Type,Path,Rp0,Rpx).
  parseTpTemplate(St,B,Env,Cx,Cx,Type,Path,Rp,Rpx) :-
    isBinary(St,"<~",_,L,_),
    parseTypeHead(L,B,Type,Path,Rp,Rpx)!.

  parseTypeHead:(ast,map[string,tipe],tipe,string,report,report){}.
  parseTypeHead(N,_,tipe(subPath(Path,marker(tpe),Nm)),Path,Rp,Rp) :-
    isIden(N,_,Nm).
  parseTypeHead(N,B,typeExp(subPath(Path,marker(tpe),TpNm),Args),Path,Rp,Rpx) :-
    isSquareTerm(N,_,Nm,A),
    isIden(Nm,_,TpNm),
    parseHeadArgs(A,B,Args,Rp,Rpx).
  
  parseHeadArgs:(list[ast],map[string,tipe],list[tipe],report,report){}.
  parseHeadArgs([],_,[],Rp,Rp).
  parseHeadArgs([H,..L],B,[V,..Args],Rp,Rpx) :-
    isIden(H,Lc,Nm),
    (present(B,Nm,V) ? Rp=Rpx | reportError("type argument $(H) not quantified ",Lc,Rp,Rp0)),
    parseHeadArgs(L,B,Args,Rp0,Rpx).

  -- reapply quantifiers to a type to get full form
  reQuant:(list[(string,tipe)],tipe,tipe){}.
  reQuant([],Tp,Tp).
  reQuant([(Nm,_),..M],Tp,QTp) :-
    reQuant(M,univType(kVar(Nm),Tp),QTp).

  wrapConstraints:(list[constraint],tipe,tipe){}.
  wrapConstraints([],Tp,Tp).
  wrapConstraints([Con,..C],Tp,WTp) :-
    wrapConstraints(C,constrained(Tp,Con),WTp).

  public wrapConConstraints:(list[constraint],constraint,constraint){}.
  wrapConConstraints([],C,C).
  wrapConConstraints(Cx,C,conRule(Cx,C)).

  public rewriteConstraints:(list[constraint],map[string,tipe],list[constraint],list[constraint]){}.
  rewriteConstraints([],_,Cx,Cx).
  rewriteConstraints([Con,..Cons],Q,C0,Cx) :-
    (_,FCon) = freshen(Con,Q),
    addConstraint(FCon,C0,C1),
    rewriteConstraints(Cons,Q,C1,Cx).

    -- reapply quantifiers to a constraint to get full form
  reConQuant:(list[(string,tipe)],constraint,constraint){}.
  reConQuant([],Tp,Tp).
  reConQuant([(Nm,_),..M],Tp,QTp) :-
    reConQuant(M,univCon(kVar(Nm),Tp),QTp).
}