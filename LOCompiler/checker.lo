lo.comp.typecheck{
  import lo.
  import lo.repo.

  import lo.comp.location.
  import lo.comp.ast.
  import lo.comp.abstract.
  import lo.comp.keywords.
  import lo.comp.canon.
  import lo.comp.types.
  import lo.comp.parseType.
  import lo.comp.freshen.
  import lo.comp.unify.
  import lo.comp.dependencies.
  import lo.comp.dict.
  import lo.comp.errors.
  import lo.comp.macro.
  import lo.comp.package.
  import lo.comp.misc.
  import lo.uri.
  import lo.comp.imports.
  import lo.comp.resolve.

  public checkProgram:all r ~~ repository[r] |: (ast,version,r,report,report)=>canonPkg.
  checkProgram(Prog,V,Repo,Rp,Rpx) => canonPkg(pkgSpec(pkg(PkgNm,V),Exports,Types,Enums,Contracts,Impls,Imports),ImportClosure,ODefs,OOthers) :-
    isBraceTerm(Prog,Lc,Pk,Els),
    PkgNm = packageName(Pk),
    thetaEnv(PkgNm,Repo,Lc,Els,[],pushScope(stdDict),_,Defs,Public,Imports,ImportClosure,Others,Rp,Rp0),
    (errorFree(Rp0) ?
      findImportedImplementations(ImportClosure,[],OverDict),
      overload(Defs,OverDict,ODict,ODefs,Rp0,Rp1),
      OOthers = overloadOthers(Others,ODict,Rp1,Rpx) |
      Rpx=Rp0,
      ODefs=Defs,
      OOthers=Others),
    computeExport(ODefs,[],Public,Exports,Types,Enums,Contracts,Impls).

  private computeImports:(list[(string,defnKind)],list[pkgSpec]) => list[(visibility,pkg)].
  computeImports(_,[])=>[].
  computeImports(Pub,[pkgSpec(pkg(Pk,V),_,_,_,_,_,_),..Pkgs]) => [(exportViz(Pk,imp,Pub),pkg(Pk,V)),..computeImports(Pub,Pkgs)].

  private thetaEnv:all r ~~ repository[r] |: (string,r,location,list[ast],list[(string,tipe)],list[env],list[env],
      list[canonDef],list[(string,defnKind)],list[(visibility,pkg)],list[pkgSpec],list[canonOther],report,report){}.
  thetaEnv(Path,Repo,Lc,Els,Fields,Base,TheEnv,Defs,Public,Imports,ImportClosure,Others,Rp,Rpx) :-
    macroRewrite(Els,Stmts,Rp,Rp0),
    -- _logmsg("After rewrite: \(Stmts)"),
    dependencies(Stmts,Groups,Public,Annots,Imps,Otrs,Rp0,Rp1),
    processImportGroup(Imps,Imports,ImportClosure,Lc,Repo,Base,IBase,Rp1,Rp2),
    checkGroups(Groups,Fields,Annots,Defs,pushFace(Fields,Lc,IBase),TheEnv,Path,Rp2,Rp3),
    checkOthers(Otrs,Others,TheEnv,Path,Rp3,Rpx).
    -- _logmsg("Checked defs: \(Defs)").

  private checkOthers:(list[ast],list[canonOther],list[env],string,report,report){}.
  checkOthers([],[],_,_,Rp,Rp).
  checkOthers([St,..Stmts],Ass,Env,Path,Rp,Rpx) :-
    checkOther(St,Ass,More,Env,Rp,Rp0)!,
    checkOthers(Stmts,More,Env,Path,Rp0,Rpx).
  checkOthers([St,..Stmts],Ass,Env,Path,Rp,Rpx) :-
    reportError("cannot understand statement: \(St)",St.loc,Rp,Rp0),
    checkOthers(Stmts,Ass,Env,Path,Rp0,Rpx).

  private checkOther:(ast,list[canonOther],list[canonOther],list[env],report,report){}.
  checkOther(St,[integrity(Lc,Cond),..More],More,Env,Rp,Rpx) :-
    isUnary(St,"assert",Lc,C),
    checkCond(C,Env,_,Cond,Rp,Rpx).
  checkOther(St,[expShow(Lc,Show),..More],More,Env,Rp,Rpx) :-
    isUnary(St,"show",Lc,E),
    typeOfTerm(E,findType("string",Lc,Env,Rp,Rp0),Env,_,Show,Rp0,Rpx).

  processImportGroup:all r ~~ repository[r] |: (list[ast],list[(visibility,pkg)],list[pkgSpec],location,r,list[env],list[env],report,report){}.
  processImportGroup(Stmts,Imports,ImportClosure,Lc,Repo,Env,Ex,Rp,Rpx) :-
    findAllImports(Stmts,Imports),
    ImportedPkgs = Imports//second,
    ImportClosure = importClosure(ImportedPkgs,[],Repo,Rp,Rpx),
    importAllDefs(ImportClosure,Lc,Env,Ex).

  findAllImports:(list[ast],list[(visibility,pkg)]){}.
  findAllImports([],[]).
  findAllImports([St,..More],[findImport(St,priVate),..Imports]) :-
    findAllImports(More,Imports).

  findImport:(ast,visibility)=>(visibility,pkg).
  findImport(St,_) => findImport(I,priVate) :-
    isUnary(St,"private",_,I).
  findImport(St,_) => findImport(I,pUblic):-
    isUnary(St,"public",_,I).
  findImport(St,Viz) => (Viz,pkgName(P)) :-
    isUnary(St,"import",_,P).

  private second:all u,v ~~ ((u,v))=>v.
  second((a,b)) => b.

  addPublicImports:(list[(visibility,pkg)],location,list[(location,visibility,pkg)]){}.
  addPublicImports([],_,[]).
  addPublicImports([(pUblic,Pkg),..I],Lc,[(Lc,pUblic,Pkg),..Rest]) :-
    addPublicImports(I,Lc,Rest).
  addPublicImports([(priVate,_),..I],Lc,Rest) :-
    addPublicImports(I,Lc,Rest).

  importAllDefs:(list[pkgSpec],location,list[env],list[env]){}.
  importAllDefs([],_,Env,Env).
  importAllDefs([Spec,..Specs],Lc,Env,Ex) :-
    importDefs(Spec,Lc,Env,Ev0),
    importAllDefs(Specs,Lc,Ev0,Ex).

  importDefs:(pkgSpec,location,list[env],list[env]){}.
  importDefs(pkgSpec(_,Exported,Types,_,Cons,_,_),Lc,Env,Ex) :-
    Ex = importContracts(Cons,Lc,importTypes(Types,Lc,declareFields(Exported,Lc,Env))).

  declareFields:(list[(string,tipe)],location,list[env]) => list[env].
  declareFields([],_,Env) => Env.
  declareFields([(Nm,Tp),..More],Lc,Env) =>
    declareFields(More,Lc,declareVar(Nm,vr(v(Lc,Nm),Tp),Env)).

  importTypes:(list[(string,tipe)],location,list[env]) => list[env].
  importTypes([],_,Env)=>Env.
  importTypes([(Nm,Rule),..More],Lc,Env) => importTypes(More,Lc,declareType(Nm,tpDef(Lc,pickTypeTemplate(Rule),Rule),Env)).

  pickTypeTemplate:(tipe)=>tipe.
  pickTypeTemplate(univType(B,Tp)) => pickTypeTemplate(Tp).
  pickTypeTemplate(typeRule(Lhs,_)) => pickTypeTemplate(Lhs).
  pickTypeTemplate(constrained(Tp,_)) => pickTypeTemplate(Tp).
  pickTypeTemplate(tipe(Nm)) => tipe(Nm).
  pickTypeTemplate(typeExp(Op,_)) => Op.

  importContracts:(list[conEntry],location,list[env])=>list[env].
  importContracts([],_,Env)=>Env.
  importContracts([C,..L],Lc,E)=>importContracts(L,Lc,E1) :-
    defineContract(Lc,C,E,E1).

  private checkGroups:(list[list[defn]],list[(string,tipe)],list[(string,ast)],list[canonDef],list[env],list[env],string,report,report){}.
  checkGroups([],_,_,[],E,E,_,Rp,Rp).
  checkGroups([Gp,..More],Fields,Annots,Defs,Env,E,Path,Rp,Rpx) :-
    checkGroup(Gp,Gp,Fields,Annots,Defs,D0,Env,E0,Path,Rp,Rp0),
    checkGroups(More,Fields,Annots,D0,E0,E,Path,Rp0,Rpx).

  private checkGroup:(list[defn],list[defn],list[(string,tipe)],list[(string,ast)],list[canonDef],list[canonDef],list[env],list[env],string,report,report){}.
  checkGroup(Grp,[defn(_,tpe,_,_,_),.._],_,_,Defs,Dx,Env,Ex,Path,Rp,Rpx) :-
    typeGroup(Grp,Defs,Dx,Env,Ex,Path,Rp,Rpx).
  checkGroup(Grp,[defn(_,valu,_,_,_),.._],Fields,Annots,Defs,Dx,Env,Ex,Path,Rp,Rpx) :-
    varGroup(Grp,Fields,Annots,Defs,Dx,Env,Ex,Path,Rp,Rpx).
  checkGroup(Grp,[defn(_,con,_,_,_),.._],_,_,Defs,Dx,Env,Ex,Path,Rp,Rpx) :-
    contractGroup(Grp,Defs,Dx,Env,Ex,Path,Rp,Rpx).
  checkGroup(Grp,[defn(_,impl,_,_,_),.._],_,_,Defs,Dx,Env,Ex,Path,Rp,Rpx) :-
    implementationGroup(Grp,Defs,Dx,Env,Ex,Path,Rp,Rpx).

  -- This is very elaborate - to support mutual recursion amoung types.

  private typeGroup:(list[defn],list[canonDef],list[canonDef],list[env],list[env],string,report,report){}.
  typeGroup(Grp,Defs,Dx,Env,Ex,Path,Rp,Rpx) :-
    defineTypes(Grp,Env,TmpEnv,Path,Rp,Rp0),
    parseTypeDefs(Grp,TpDefs,[],TmpEnv,Path,Rp0,Rpx),
    declareTypes(TpDefs,Defs,Dx,Env,Ex).

  private defineTypes:(list[defn],list[env],list[env],string,report,report){}.
  defineTypes([],Env,Env,_,Rp,Rp).
  defineTypes([defn(N,tpe,Lc,_,[Stmt]),..More],Env,Ex,Path,Rp,Rpx) :-
    defineType(N,Lc,Stmt,Env,E0,Path,Rp,Rp0),
    defineTypes(More,E0,Ex,Path,Rp0,Rpx).
  defineTypes([defn(N,tpe,Lc,_,[_,.._]),..More],Env,Ex,Path,Rp,Rpx) :-
    reportError("multiple type definition statements for \(N)",Lc,Rp,Rp0),
    defineTypes(More,Env,Ex,Path,Rp0,Rpx).

  private defineType:(string,location,ast,list[env],list[env],string,report,report){}.
  defineType(N,Lc,St,Env,Ex,Path,Rp,Rpx) :-
    ( isType(N,Env,OLc,_) ?
        reportError("type \(N) already defined at \(OLc)",Lc,Rp,Rpx),
        Ex = Env |
        parseTypeCore(St,TpCore,Path),
        Rp=Rpx,
        Ex = declareType(N,tpDef(Lc,TpCore,faceType([])),Env)).

  private parseTypeDefs:(list[defn],list[canonDef],list[canonDef],list[env],string,report,report){}.
  parseTypeDefs([],Defs,Defs,_,_,Rp,Rp).
  parseTypeDefs([defn(N,tpe,Lc,_,[Stmt]),..More],Defs,Dx,TmpEnv,Path,Rp,Rpx) :-
    parseTypeDefinition(N,Lc,Stmt,Defs,D0,TmpEnv,Path,Rp,Rp0),
    parseTypeDefs(More,D0,Dx,TmpEnv,Path,Rp0,Rpx).

  parseTypeDefinition:(string,location,ast,list[canonDef],list[canonDef],list[env],string,report,report){}.
  parseTypeDefinition(N,Lc,St,[typeDef(Lc,N,Type,FaceRule),..Defs],Defs,Env,Path,Rp,Rpx) :-
    isUnary(St,"type",_,InSt),
    parseTypeRule(InSt,[],Env,FaceRule,Path,Rp,Rpx),
    isType(N,Env,_,Type). -- pick up existing template

  private declareTypes:(list[canonDef],list[canonDef],list[canonDef],list[env],list[env]){}.
  declareTypes([],Defs,Defs,Env,Env).
  declareTypes([typeDef(Lc,N,Type,FaceRule),..More],[typeDef(Lc,N,Type,FaceRule),..Defs],Dx,Env,Ex) :-
    declareTypes(More,Defs,Dx,declareType(N,tpDef(Lc,Type,FaceRule),Env),Ex).

  private contractGroup:(list[defn],list[canonDef],list[canonDef],list[env],list[env],string,report,report){}.
  contractGroup([defn(N,con,Lc,_,[ConStmt]),.._],[cnDefn(Lc,N,Contract),..Defs],Defs,Env,Ex,Path,Rp,Rpx) :-
    parseContract(ConStmt,Env,Path,Contract,Rp,Rpx),
    defineContract(Lc,Contract,Env,Ex).

  private defineContract:(location,conEntry,list[env],list[env]){}.
  defineContract(Lc,conEntry(N,Nm,Spec,Face),E0,Ex) :-
    declareMethods(Spec,Face,Lc,declareContract(N,conEntry(N,Nm,Spec,Face),E0),Ex).

  private declareMethods:(constraint,tipe,location,list[env],list[env]){}.
  declareMethods(Spec,MtdsTp,Lc,Env,Ev) :-
    moveConQuants(Spec,Q,Con),
    moveQuants(MtdsTp,_,faceType(Methods)),
    formMethods(Methods,Lc,Q,Con,Env,Ev).

  private formMethods:(list[(string,tipe)],location,list[tipe],constraint,list[env],list[env]){}.
  formMethods([],_,_,_,Env,Env).
  formMethods([(Nm,Tp),..M],Lc,Q,Con,Env,Ev) :-
    moveQuants(Tp,FQ,QTp),
    moveQuants(MTp,merge(FQ,Q),constrained(QTp,Con)),
    formMethods(M,Lc,Q,Con,declareVar(Nm,vr(mtd(Lc,Nm),MTp),Env),Ev).

  -- handle program definitions
  private varGroup:(list[defn],list[(string,tipe)],list[(string,ast)],list[canonDef],list[canonDef],list[env],list[env],string,report,report){}.
  varGroup(Grp,Fields,Annots,Defs,Dx,Base,Env,Path,Rp,Rpx) :-
    parseAnnotations(Grp,Fields,Annots,Base,Env,Path,Rp,Rp0)!,
    checkVarRules(Grp,Env,Defs,Dx,Path,Rp0,Rpx).

  private parseAnnotations:(list[defn],list[(string,tipe)],list[(string,ast)],list[env],list[env],string,report,report){}.
  parseAnnotations([],_,_,Env,Env,_,Rp,Rp).
  parseAnnotations([defn(Nm,valu,_,_,_),..More],Fields,Annots,Env,Ex,Path,Rp,Rpx) :-
    ((Nm,Annot) in Annots)!,
    isBinary(Annot,":",Lc,_,T),
    parseType(T,Env,Tp,Rp,Rp0),
    parseAnnotations(More,Fields,Annots,declareVar(Nm,vr(v(Lc,Nm),Tp),Env),Ex,Path,Rp0,Rpx).
  parseAnnotations([defn(N,valu,Lc,_,_),..More],Fields,Annots,Env,Ex,Path,Rp,Rpx) :-
    ((N,Tp) in Fields)!,
    parseAnnotations(More,Fields,Annots,declareVar(N,vr(v(Lc,N),Tp),Env),Ex,Path,Rp,Rpx).
  parseAnnotations([defn(N,valu,Lc,_,_),..More],Fields,Annots,Env,Ex,Path,Rp,Rpx) :-
    reportError("no type annotation for variable \(N)",Lc,Rp,Rp0),
    parseAnnotations(More,Fields,Annots,Env,Ex,Path,Rp0,Rpx).

  private checkVarRules:(list[defn],list[env],list[canonDef],list[canonDef],string,report,report){}.
  checkVarRules([],_,Defs,Defs,_,Rp,Rp).
  checkVarRules([defn(N,valu,Lc,_,Stmts),..More],Env,Defs,Dx,Path,Rp,Rpx) :-
    -- _logmsg("checking var rules \(Stmts)"),
    (Q,PT) = skolemize(pickupVarType(N,Lc,Env,Rp,Rp0),pickupThisType(Env)),
    declareTypeVars(pairs(Q),Lc,Env,SEnv),
    moveConstraints(PT,Cx,ProgramType),
    declareConstraints(Cx,SEnv,StmtEnv),
    processStmts(Stmts,ProgramType,Rules,[],StmtEnv,Path,Rp0,Rp1),
    collectPrograms(Rules,Env,Cx,Defs,D0),
    checkVarRules(More,Env,D0,Dx,Path,Rp1,Rpx).

  private pickupVarType:(string,location,list[env],report,report) => tipe.
  pickupVarType(N,_,Env,Rp,Rp)=>Tp :-
    isVar(N,Env,vr(_,Tp)).
  pickupVarType(N,Lc,_,Rp,Rpx) => newVar("_") :-
    reportError("\(N) not declared",Lc,Rp,Rpx).

  private declareTypeVars:(list[(string,tipe)],location,list[env],list[env]){}.
  declareTypeVars([],_,Env,Env).
  declareTypeVars([("this",_),..Vars],Lc,Env,Ex) :-
    declareTypeVars(Vars,Lc,Env,Ex).
  declareTypeVars([(Nm,Tp),..Vars],Lc,Env,Ex) :-
    declareTypeVars(Vars,Lc,declareTypeExists(Nm,Lc,Tp,Env),Ex).

  private declareConstraints:(list[constraint],list[env],list[env]){}.
  declareConstraints([],Env,Env).
  declareConstraints([C,..L],E,Ex) :-
    declareConstraints(L,declareConstraint(C,E),Ex).

  private processStmts:(list[ast],tipe,list[canonRule],list[canonRule],list[env],string,report,report){}.
  processStmts([],_,Defs,Defs,_,_,Rp,Rp).
  processStmts([St,..More],ProgramType,Defs,Dx,Env,Path,Rp,Rpx) :-
    processStmt(St,ProgramType,Defs,D0,Env,Path,Rp,Rp0)!,
    processStmts(More,ProgramType,D0,Dx,Env,Path,Rp0,Rpx).

  private processStmt:(ast,tipe,list[canonRule],list[canonRule],list[env],string,report,report){}.
  processStmt(St,ProgramType,Defs,Defx,E,_,Rp,Rpx) :-
    isBinary(St,"=>",Lc,L,R),
    checkEquation(Lc,L,iden(Lc,"true"),R,ProgramType,Defs,Defx,E,Rp,Rpx).
  processStmt(St,ProgramType,Defs,Defx,E,_,Rp,Rpx) :-
    isBinary(St,":-",Lc,L,G),
    isBinary(L,"=>",_,H,R),
    checkEquation(Lc,H,G,R,ProgramType,Defs,Defx,E,Rp,Rpx).
  processStmt(St,ProgramType,Defs,Defx,E,Pth,Rp,Rpx) :-
    isBinary(St,":-",Lc,L,G),
    isBinary(L,"<=",_,H,R),
    checkClassRule(Lc,H,G,R,ProgramType,Defs,Defx,E,Pth,Rp,Rpx).
  processStmt(St,ProgramType,Defs,Dfx,E,_,Rp,Rpx) :-
    isBinary(St,":-",Lc,L,R),
    checkClause(Lc,L,R,ProgramType,Defs,Dfx,E,Rp,Rpx).
  processStmt(St,predType(AT),[clause(Lc,Nm,Args,trueCond),..Defs],Defs,E,_,Rp,Rpx) :-
    splitHead(St,Lc,Nm,A),
    typeOfArg(A,AT,pushScope(E),E0,Args,Rp,Rpx).
  processStmt(St,Tp,Defs,Dx,Env,_,Rp,Rpx) :-
    isBinary(St,"=",Lc,L,R),
    checkDefn(Lc,L,iden(Lc,"true"),R,Tp,Defs,Dx,Env,Rp,Rpx).
  processStmt(St,ProgramType,Defs,Defx,E,Pth,Rp,Rpx) :-
    isBinary(St,"<=",Lc,H,R),
    checkClassRule(Lc,H,iden(Lc,"true"),R,ProgramType,Defs,Defx,E,Pth,Rp,Rpx).
  processStmt(St,Tp,Defs,Dx,E,_,Rp,Rpx) :-
    isBinary(St,"-->",Lc,L,R),
    checkGrammarRule(Lc,L,R,Tp,Defs,Dx,E,Rp,Rpx).
  processStmt(St,Tp,Defs,Defs,_,_,Rp,Rpx) :-
    reportError("Statement \(St) not consistent with expected type \(Tp)",St.loc,Rp,Rpx).

  private splitHead:(ast,location,string,ast){}.
  splitHead(T,Lc,Nm,A) :- isRound(T,Lc,N,A), isIden(N,_,Nm).
  splitHead(T,Lc,Nm,roundTuple(Lc,[])) :- isIden(T,Lc,Nm).

  private checkEquation:(location,ast,ast,ast,tipe,list[canonRule],list[canonRule],list[env],report,report){}.
  checkEquation(Lc,H,G,R,funType(AT,RT),[equation(Lc,Nm,Args,Exp,Cond),..Defs],Defs,E,Rp,Rpx) :-
    splitHead(H,_,Nm,A),
    typeOfArg(A,AT,pushScope(E),E0,Args,Rp,Rp0),
    checkCond(G,E0,E1,Cond,Rp0,Rp1),
    typeOfTerm(R,RT,E1,_,Exp,Rp1,Rpx).
  checkEquation(Lc,_,_,_,ProgramType,Defs,Defs,_,Rp,Rpx) :-
    reportError("equation not consistent with expected type: \(ProgramType)",Lc,Rp,Rpx).

  private checkClause:(location,ast,ast,tipe,list[canonRule],list[canonRule],list[env],report,report){}.
  checkClause(Lc,L,R,predType(AT),[clause(Lc,Nm,Args,Body),..Defs],Defs,E,Rp,Rpx) :-
    splitHead(L,_,Nm,A),
    typeOfArg(A,AT,pushScope(E),E0,Args,Rp,Rp0),
    checkCond(R,E0,_,Body,Rp0,Rpx).

  private checkDefn:(location,ast,ast,ast,tipe,list[canonRule],list[canonRule],list[env],report,report){}
  checkDefn(Lc,L,C,R,Tp,[vrDef(Lc,Nm,Value,Cond),..Dx],Dx,E,Rp,Rpx) :-
    isIden(L,_,Nm),
    checkCond(C,pushScope(E),E1,Cond,Rp,Rp0),
    typeOfTerm(R,Tp,E1,_,Value,Rp0,Rpx).

  private checkGrammarRule:(location,ast,ast,tipe,list[canonRule],list[canonRule],list[env],report,report){}.
  checkGrammarRule(Lc,L,R,grammarType(AT,Tp),[grRule(Lc,Nm,Args,grTerms(PB),Body),..Defs],Defs,E,Rp,Rpx) :-
    splitGrHead(L,Nm,A,P),
    ElTp=newVar("_E"),
    typeOfArg(A,AT,declareVar("stream$X",vr(v(Lc,"stream$X"),Tp),pushScope(E)),E2,Args,Rp,Rp0),
    checkNonTerminal(R,Tp,ElTp,E2,E3,Body,Rp0,Rp1),
    typeOfTerm(iden(Lc,"_hdtl"),predType(tupleType([StrmTp,ElTp,StrmTp])),E3,_,HDTL,Rp1,Rp2),
    checkTerminals(P,HDTL,PB,ElTp,E3,_,Rp2,Rpx).

  private splitGrHead:(ast,string,ast,list[ast]){}.
  splitGrHead(Term,Nm,Args,Hed) :-
    isBinary(Term,",",_,L,R),
    isSquareTuple(R,_,Hed),
    splitHead(L,_,Nm,Args).
  splitGrHead(Term,Nm,Args,Hed) :-
    isRoundTuple(Term,_,[T]),
    splitGrHead(T,Nm,Args,Hed).
  splitGrHead(Term,Nm,Args,[]) :-
    splitHead(Term,_,Nm,Args).

  private checkClassRule:(location,ast,ast,ast,tipe,list[canonRule],list[canonRule],list[env],string,report,report){}.
  checkClassRule(_,H,G,R,ClassTp,[clRule(Lc,Nm,Hd,theta(ClDefs,ClOthers),Cond,faceType(Types)),..Defs],Defs,E,Pth,Rp,Rpx) :-
    isBraceTuple(R,Lc,Els),
    checkClassHead(H,ClassTp,SuperTp,pushScope(E),E1,Nm,Hd,Rp,Rp0),
    checkCond(G,E1,E2,Cond,Rp0,Rp1),
    checkThetaTerm(SuperTp,Lc,Els,E1,ClDefs,ClOthers,Types,subPath(Pth,marker(clss),Nm),Rp0,Rpx).
  checkClassRule(Lc,H,G,R,ClassTp,[clRule(Lc,Nm,Hd,Repl,Cond,SuperFace),..Defs],Defs,E,Pth,Rp,Rpx) :-
    checkClassHead(H,ClassTp,_,pushScope(E),E1,Nm,Hd,Rp,Rp0),
    checkCond(G,E1,E2,Cond,Rp0,Rp1),
    SuperTp = newVar("SpTp"),
    typeOfTerm(R,SuperTp,E2,_,Repl,Rp1,Rpx),
    faceOfType(SuperTp,E2,SuperFace).

  private checkClassHead:(ast,tipe,tipe,list[env],list[env],string,canonTerm,report,report){}.
  checkClassHead(Term,Tp,Tp,Env,Env,Nm,v(Lc,Nm),Rp,Rp) :-
    isIden(Term,Lc,Nm).
  checkClassHead(Term,classType(AT,Tp),Tp,Env,Ev,Nm,apply(Lc,v(Lc,Nm),Args),Rp,Rpx) :-
    splitHead(Term,Lc,Nm,A),
    typeOfArg(A,AT,Env,Ev,Args,Rp,Rpx).

  private checkThetaTerm:(tipe,location,list[ast],list[env],list[canonDef],list[canonOther],list[(string,tipe)],string,report,report){}.
  checkThetaTerm(ClassTp,Lc,Els,Env,Defs,Others,Types,ClassPath,Rp,Rpx) :-
    faceOfType(deRef(ClassTp),Env,Face),
    moveConstraints(Face,_,faceType(Fields)),
    thetaEnv(ClassPath,coreRepo,Lc,Els,Fields,declareVar("this",vr(v(Lc,"this"),ClassTp),Env),_OEnv,Defs,Public,_Imports,_,Others,Rp,Rpx),
    computeExport(Defs,Fields,Public,_,Types,_,[],[]).

  private implementationGroup:(list[defn],list[canonDef],list[canonDef],list[env],list[env],string,report,report){}.
  implementationGroup([defn(INm,impl,_,_,[Stmt])],[Impl,..Defs],Defs,Env,Ex,Path,Rp,Rpx) :-
    isUnary(Stmt,"implementation",Lc,I),
    isBinary(I,"<=",_,Sq,Body),
    isBraceTuple(Body,_,Els),
    parseContractConstraint(Sq,Env,Nm,Spec,Rp,Rp0),
    isContract(Nm,Env,conEntry(_,CNm,FullSpec,ConFace)),
    -- We have to unify the implemented contract and the contract (spec)ification
    moveConQuants(FullSpec,_,conTract(ConNm,OArgs,ODeps)),
    moveConQuants(Spec,SQ,ASpec),
    moveConConstraints(ASpec,AC,conTract(ConNm,AArgs,ADeps)),
    sameLength(OArgs,AArgs,Lc,Rp0,Rp1),
    sameLength(ODeps,ADeps,Lc,Rp1,Rp2),
    -- match up the type variables of the original contract with the actual implemented contract
    QQ = bindAT(ODeps,ADeps,bindAT(OArgs,AArgs,[])),
    moveQuants(ConFace,_,CFace),
    (_,F) = freshen(CFace,QQ), -- rewrite the face to be consistent with our local types
    moveConstraints(CF,AC,F),
    moveQuants(FT,SQ,CF), -- construct the required type signature of the implementation
    (IQ,SF) = skolemize(FT,[]),
    moveConstraints(SF,SC,Face),
    declareConstraints(SC,pushScope(Env),E0),
    declareTypeVars(pairs(IQ),Lc,E0,SEnv),
    implementationName(conTract(CNm,AArgs,ADeps)) = ImplName,
    checkThetaTerm(Face,Lc,Els,SEnv,ThDefs,Others,Types,ImplName,Rp0,Rpx),
    Impl = implDef(Lc,INm,ImplName,Spec,SC,tpl([]),theta(ThDefs,Others),Face),
    Ex=declareImplementation(Nm,ImplName,implEntry(ImplName,Spec),Env).
  implementationGroup([defn(INm,impl,Lc,_,Stmt)],Defs,Defs,Env,E,Path,Rp,Rpx) :-
    reportError("could not check implementation statement \(Stmt)",Lc,Rp,Rpx).

  private sameLength:all e~~(list[e],list[e],location,report,report){}.
  sameLength(L1,L2,_,Rp,Rp) :- length(L1)=length(L2).
  sameLength(L1,_,Lc,Rp,Rpx) :-
    reportError("expecting \(length(L1)) elements",Lc,Rp,Rpx).

  private checkCond:(ast,list[env],list[env],canonCond,report,report){}.
  checkCond(Term,Env,Env,trueCond,Rp,Rp) :-
    isIden(Term,Lc,"true").
  checkCond(Term,Env,Env,falseCond,Rp,Rp) :-
    isIden(Term,Lc,"false").
  checkCond(Term,Env,Ex,conjCond(Lhs,Rhs),Rp,Rpx) :-
    isBinary(Term,",",_,L,R),
    checkCond(L,Env,E1,Lhs,Rp,Rp0),
    checkCond(R,E1,Ex,Rhs,Rp0,Rpx).
  checkCond(Term,Env,Ex,condCond(Test,Either,Or),Rp,Rpx) :-
    isBinary(Term,"|",_,L,R),
    isBinary(L,"?",_,T,Th),
    checkCond(T,Env,E0,Test,Rp,Rp0),
    checkCond(Th,E0,E1,Either,Rp0,Rp1),
    checkCond(R,E1,Ex,Or,Rp1,Rpx).
  checkCond(Term,Env,Ex,disjCond(Either,Or),Rp,Rpx) :-
    isBinary(Term,"|",_,L,R),
    checkCond(L,Env,E1,Either,Rp,Rp0),
    checkCond(R,E1,Ex,Or,Rp0,Rpx).
  checkCond(Term,Env,Ex,oneCond(Test),Rp,Rpx) :-
    isUnary(Term,"!",_,N),
    checkCond(N,Env,Ex,Test,Rp,Rpx).
  checkCond(Term,Env,Env,negCond(Test),Rp,Rpx) :-
    isUnary(Term,"\\+",_,N),
    checkCond(N,Env,_,Test,Rp,Rpx).
  checkCond(Term,Env,Env,forallCond(Gen,Test),Rp,Rpx) :-
    isBinary(Term,"*>",_,L,R),
    checkCond(L,Env,E0,Gen,Rp,Rp0),
    checkCond(R,E0,_,Test,Rp0,Rpx).
  checkCond(Term,Env,Ex,Cond,Rp,Rpx) :-
    isRoundTuple(Term,_,C),
    checkConds(C,Env,Ex,Cond,Rp,Rpx).
  checkCond(Term,Env,Ev,negCond(unifyCond(Lc,Lhs,Rhs)),Rp,Rpx) :-
    isBinary(Term,"\\=",Lc,L,R),
    TV = newVar("_#"),
    typeOfTerm(L,TV,Env,E0,Lhs,Rp,Rp0),
    typeOfTerm(R,TV,E0,Ev,Rhs,Rp0,Rpx).
  checkCond(Term,Env,Ev,unifyCond(Lc,Lhs,Rhs),Rp,Rpx) :-
    isBinary(Term,"=",Lc,L,R),
    TV = newVar("_#"),
    typeOfTerm(L,TV,Env,E0,Lhs,Rp,Rp0),
    typeOfTerm(R,TV,E0,Ev,Rhs,Rp0,Rpx).
  checkCond(Term,Env,Ev,phraseCond(Lc,NT,Strm,Rest),Rp,Rpx) :-
    isBinary(Term,"%%",Lc,L,R),
    isBinary(R,"~",_,S,M),
    StrmTp = newVar("_S"),
    ElTp = newVar("_E"),
    checkGrammarType(Lc,Env,StrmTp,ElTp,Rp,Rp0),
    typeOfTerm(S,StrmTp,Env,E0,Strm,Rp0,Rp1),
    typeOfTerm(M,StrmTp,E0,E1,Rest,Rp1,Rp2),
    checkNonTerminal(L,StrmTp,ElTp,declareVar(streamVar,vr(v(Lc,streamVar),StrmTp),E1),Ev,NT,Rp2,Rpx).
  checkCond(Term,Env,Ev,phraseCond(Lc,NT,Strm,Rest),Rp,Rpx) :-
    isBinary(Term,"%%",Lc,L,R),
    StrmTp = newVar("_S"),
    ElTp = newVar("_E"),
    checkGrammarType(Lc,Env,StrmTp,ElTp,Rp,Rp0),
    typeOfTerm(R,StrmTp,Env,E0,Strm,Rp0,Rp1),
    M = iden(Lc,_str_gen("_")),
    typeOfTerm(M,StrmTp,E0,E1,Rest,Rp1,Rp2),
    checkNonTerminal(binary(Lc,",",L,iden(Lc,"eof")),StrmTp,ElTp,declareVar("stream_X",vr(v(Lc,"stream_X"),StrmTp),E1),Ev,NT,Rp2,Rpx).
  checkCond(Term,Env,Ev,Call,Rp,Rpx) :-
    isRound(Term,Lc,F,A),
    PrTp = newVar("_P"),
    knownType(F,PrTp,Env,E0,Pred,Rp,Rp0),
    ( deRef(PrTp) = predType(ArgTp) ?
      typeOfArg(A,ArgTp,E0,Ev,Arg,Rp0,Rpx),
      Call = callCond(Lc,Pred,Arg) |
      reportError("\(Pred)\:\(PrTp) not a predicate",Lc,Rp0,Rpx),
      E0=Ev, Call = trueCond).
  checkCond(Term,Env,Ev,isTrue(Exp),Rp,Rpx) :-
    knownType(Term,findType("logical",Lc,Env,Rp,Rp0),Env,Ev,Exp,Rp0,Rpx).

  private checkConds:(list[ast],list[env],list[env],canonCond,report,report){}.
  checkConds([],Env,Env,trueCond,Rp,Rp).
  checkConds([C],Ev,Env,Cond,Rp,Rpx) :-
    checkCond(C,Ev,Env,Cond,Rp,Rpx).
  checkConds([C,..L],Ev,Env,conjCond(C0,Cm),Rp,Rpx) :-
    checkCond(C,Ev,E0,C0,Rp,Rp0),
    checkConds(L,E0,Env,Cm,Rp0,Rpx).

  private typeOfArg:(ast,tipe,list[env],list[env],canonTerm,report,report){}.
  typeOfArg(Term,Tp,Env,Ev,Exp,Rp,Rpx) :-
    ( isRoundTuple(Term,Lc,A) ?
      ArgTps = genTpVars(A),
      checkType(Lc,tupleType(ArgTps),Tp,Env,Rp,Rp0),
      typeOfTerms(A,ArgTps,Env,Ev,Lc,Els,Rp0,Rpx),
      Exp = tpl(Els) |
      typeOfTerm(Term,Tp,Env,Ev,Exp,Rp,Rpx)).

  private typeOfTerm:(ast,tipe,list[env],list[env],canonTerm,report,report){}.
  typeOfTerm(V,_,Env,Env,v(Lc,_str_gen("_")),Rp,Rp) :- isIden(V,Lc,"_").
  typeOfTerm(V,Tp,Env,Ev,Term,Rp,Rpx) :-
    isIden(V,Lc,Nm),
    (
      isVar(Nm,Env,Spec) ?
      typeOfVar(Lc,Spec,Tp,Env,Term,Rp,Rpx), Env=Ev |
      isKeyword(Nm) ?
      reportError("unexpected keyword: \(Nm)",Lc,Rp,Rpx),
      Term = v(Lc,_str_gen("_")) |
      Ev = declareVar(Nm,vr(v(Lc,Nm),Tp),Env), Term=v(Lc,Nm), Rp=Rpx).
  typeOfTerm(intg(Lc,Ix),Tp,Env,Env,int(Ix),Rp,Rpx) :-
    checkType(Lc,findType("integer",Lc,Env,Rp,Rp0),Tp,Env,Rp0,Rpx).
  typeOfTerm(flot(Lc,Dx),Tp,Env,Env,flt(Dx),Rp,Rpx) :-
    checkType(Lc,findType("float",Lc,Env,Rp,Rp0),Tp,Env,Rp0,Rpx).
  typeOfTerm(strg(Lc,Sx),Tp,Env,Env,str(Sx),Rp,Rpx) :-
    checkType(Lc,findType("string",Lc,Env,Rp,Rp0),Tp,Env,Rp0,Rpx).
  typeOfTerm(Term,Tp,Env,Ev,Exp,Rp,Rpx) :-
    isBinary(Term,":",Lc,L,R),
    ( parseType(R,Env,RT,Rp,Rp0) ?
        checkType(Lc,RT,Tp,Env,Rp0,Rp1),
        typeOfTerm(L,RT,Env,Ev,Exp,Rp1,Rpx) |
        reportError("cannot parse type \(R)",Lc,Rp0,Rp1),
        typeOfTerm(L,Tp,Env,Ev,Exp,Rp1,Rpx)).
  typeOfTerm(Term,Tp,Env,Ev,Exp,Rp,Rpx) :-
    isBinary(Term,"::",Lc,L,R),
    typeOfTerm(binary(Lc,":",unary(Lc,"_coerce",L),R),Tp,Env,Ev,Exp,Rp,Rpx).
  typeOfTerm(P,Tp,Env,Ex,whre(Ptn,Cond),Rp,Rpx) :-
    isBinary(P,"@@",_,L,R),
    typeOfTerm(L,Tp,Env,E0,Ptn,Rp,Rp0),
    checkCond(R,E0,Ex,Cond,Rp0,Rpx).
  typeOfTerm(Call,Tp,Env,Ev,whre(V,Cond),Rp,Rpx) :-
    isUnary(Call,"@",Lc,Test), -- @Test = NV @@ NV.Test where NV is a new name
    isRoundTerm(Test,_,_,_),
    NV = iden(Lc,_str_gen("_")),
    typeOfTerm(NV,Tp,Env,E0,V,Rp,Rp0),
    checkCond(binary(Lc,".",NV,Test),E0,Ev,Cond,Rp0,Rpx).
  typeOfTerm(Term,Tp,Env,Ev,Exp,Rp,Rpx) :-
    isBinary(Term,".",Lc,L,F),
    isIden(F,FLc,Fld),
    recordAccessExp(FLc,L,Fld,Tp,Env,Ev,Exp,Rp,Rpx).
  typeOfTerm(Term,Tp,Env,Ev,condExp(Test,Then,Else),Rp,Rpx) :-
    isBinary(Term,"|",Lc,L,El),
    isBinary(L,"?",_,Tst,Th),
    checkCond(Tst,Env,E0,Test,Rp,Rp0),
    typeOfTerm(Th,Tp,E0,E1,Then,Rp0,Rp1),
    typeOfTerm(El,Tp,E1,Ev,Else,Rp1,Rpx).
  typeOfTerm(Term,Tp,Env,Ev,Exp,Rp,Rpx) :-
    isSquareTuple(Term,Lc,Els),
    checkSquareTuple(Lc,Els,Tp,Env,Ev,Exp,Rp,Rpx).
  typeOfTerm(tupl(_,"()",[Inner]),Tp,Env,Ev,Exp,Rp,Rpx) :-  -- a unary round tuple might just be parenthetic expression
    \+ isRoundTuple(Inner,_,_),
    typeOfTerm(Inner,Tp,Env,Ev,Exp,Rp,Rpx).
  typeOfTerm(Term,Tp,Env,Ev,tpl(Els),Rp,Rpx) :-
    isRoundTuple(Term,Lc,A),
    ArgTps = genTpVars(A),
    checkType(Lc,tupleType(ArgTps),Tp,Env,Rp,Rp0),
    typeOfTerms(A,ArgTps,Env,Ev,Lc,Els,Rp0,Rpx).
  typeOfTerm(Term,Tp,Env,Env,int(-Ix),Rp,Rpx) :-
    isUnary(Term,"-",Lc,intg(_,Ix)),
    checkType(Lc,findType("integer",Lc,Env,Rp,Rp0),Tp,Env,Rp0,Rpx).
  typeOfTerm(Term,Tp,Env,Env,flt(-Dx),Rp,Rpx) :-
    isUnary(Term,"-",Lc,flot(_,Dx)),
    checkType(Lc,findType("float",Lc,Env,Rp,Rp0),Tp,Env,Rp0,Rpx).
  typeOfTerm(Term,Tp,Env,Env,Exp,Rp,Rpx) :-
    isUnary(Term,"-",Lc,Arg),         -- handle unary minus
    typeOfTerm(binary(Lc,"-",iden(Lc,"zero"),Arg),Tp,Env,Ev,Exp,Rp,Rpx).
  typeOfTerm(Term,Tp,Env,Env,lambda(Eqn),Rp,Rpx) :-
    isBinary(Term,"=>",Lc,Lhs,Rhs),
    checkEquation(Lc,appl(Lc,iden(Lc,"fun"),Lhs),iden(Lc,"true"),Rhs,deRef(Tp),[Eqn,.._],_,Env,Rp,Rpx).
  typeOfTerm(Term,Tp,Env,Env,lambda(Eqn),Rp,Rpx) :-
    isBinary(Term,":-",Lc,L,G),
    isBinary(L,"=>",_,H,R),
    checkEquation(Lc,appl(Lc,iden(Lc,"fun"),H),G,R,deRef(Tp),[Eqn,.._],_,Env,Rp,Rpx).
  typeOfTerm(Term,Tp,Env,Env,lambda(Clse),Rp,Rpx) :-
    isBinary(Term,":-",Lc,Lhs,Rhs),
    checkClause(Lc,appl(Lc,iden(Lc,"pred"),Lhs),Rhs,deRef(Tp),[Clse],[],Env,Rp,Rpx).
  typeOfTerm(Term,Tp,Env,Env,lambda(Rle),Rp,Rpx) :-
    isBinary(Term,"-->",Lc,Lhs,Rhs),
    checkGrammarRule(Lc,appl(Lc,iden(Lc,"grm"),Lhs),R,deRef(Tp),[Rle],[],Env,Rp,Rpx).
  typeOfTerm(Term,Tp,Env,Ev,Exp,Rp,Rpx) :-
    isRound(Term,Lc,F,A),
    FnTp = newVar("F"),
    knownType(F,FnTp,Env,E0,Fun,Rp,Rp0),
    typeOfCall(Lc,Fun,A,deRef(FnTp),Tp,E0,Ev,Exp,Rp0,Rpx).
  typeOfTerm(Term,Tp,Env,Ev,Exp,Rp,Rpx) :-
    isSquareTerm(Term,Lc,F,[A]),
    typeOfIndex(Lc,F,A,Tp,Env,Ev,Exp,Rp,Rpx).
  typeOfTerm(Term,Tp,Env,Env,theta(Defs,Others),Rp,Rpx) :-
    isBraceTuple(Term,Lc,Els),
    checkThetaTerm(Tp,Lc,Els,Env,Defs,Others,Types,_str_gen("theta"),Rp,Rpx).
  typeOfTerm(Term,Tp,Env,Env,v(Lc,_str_gen("_")),Rp,Rpx) :-
    reportError("illegal expression: \(Term), expecting a \(Tp)",Term.loc,Rp,Rpx).

  typeOfTerms:(list[ast],list[tipe],list[env],list[env],location,list[canonTerm],report,report){}.
  typeOfTerms([],[],Env,Env,_,[],Rp,Rp).
  typeOfTerms([],[T,.._],Env,Env,Lc,[],Rp,Rpx) :-
    reportError("insufficient arguments, expecting a \(T)",Lc,Rp,Rpx).
  typeOfTerms([A,.._],[],Env,Env,_,[],Rp,Rpx) :-
    reportError("too many arguments: \(A)",A.loc,Rp,Rpx).
  typeOfTerms([A,..As],[ElTp,..ElTypes],Env,Ev,_,[Term,..Els],Rp,Rpx) :-
    typeOfTerm(A,ElTp,Env,E0,Term,Rp,Rp0),
    typeOfTerms(As,ElTypes,E0,Ev,A.loc,Els,Rp0,Rpx).

  typeOfIndex:(location,ast,ast,tipe,list[env],list[env],canonTerm,report,report){}.
  typeOfIndex(Lc,Mp,Arg,Tp,Env,Ev,Exp,Rp,Rpx) :-
    isBinary(Arg,"->",_,Ky,Vl),
    typeOfTerm(ternary(Lc,"_put",Mp,Ky,Vl),Tp,Env,Ev,Exp,Rp,Rpx).
  typeOfIndex(Lc,Mp,Arg,Tp,Env,Ev,Exp,Rp,Rpx) :-
    isUnary(Arg,"\\+",_,Ky),
    typeOfTerm(binary(Lc,"_remove",Mp,Ky),Tp,Env,Ev,Exp,Rp,Rpx).
  typeOfIndex(Lc,Mp,Arg,Tp,Env,Ev,Exp,Rp,Rpx) :-
    typeOfTerm(binary(Lc,"find",Mp,Arg),Tp,Env,Ev,Exp,Rp,Rpx).

  -- Analyse a list term to try to disambiguate maps from lists.

  private checkSquareTuple:(location,list[ast],tipe,list[env],list[env],canonTerm,report,report){}.
  checkSquareTuple(Lc,Els,Tp,Env,Ev,Exp,Rp,Rpx) :-
    ((isMapSequence(Els) | isMapType(Tp,Lc,Env)) ?
      checkType(Lc,typeExp(findType("map",Lc,Env,Rp,Rp1),[newVar("K"),newVar("V")]),Tp,Env,Rp1,Rp2),
      typeOfTerm(macroMapEntries(Lc,Els,Rp2,Rp3),Tp,Env,Ev,Exp,Rp3,Rpx)|
    (isListSequence(Els) | isListType(Tp,Lc,Env)) ?
      ElTp = newVar("El"),
      ListTp = typeExp(findType("list",Lc,Env,Rp,Rp1),[ElTp]),
      checkType(Lc,ListTp,Tp,Env,Rp1,Rp2),
      typeOfListTerm(Els,Lc,ElTp,ListTp,Env,Ev,Exp,Rp2,Rpx)|
    checkSequenceTerm(Lc,Els,Tp,Env,Ev,Exp,Rp,Rpx)).

  private isMapSequence:(list[ast]){}.
  isMapSequence(Els) :-
    E in Els,
    isBinary(E,"->",_,_,_).

  private isMapType:(tipe,location,list[env]){}.
  isMapType(Tp,Lc,Env) :-
    isType("map",Env,_,MpTp),
    typeExp(MpOp,_) = deRef(Tp),
    deRef(MpOp)=MpTp.

  -- Looks for ,.. at end, and no -> in the elements
  private isListSequence:(list[ast]){}.
  isListSequence([E,.._]) :-
    \+ isBinary(E,"->",_,_,_).

  private isListType:(tipe,location,list[env]){}.
  isListType(Tp,Lc,Env) :-
    isType("list",Env,_,T),
    typeExp(LsOp,_) = deRef(Tp),
    deRef(LsOp)=LsTp.

  private typeOfListTerm:(list[ast],location,tipe,tipe,list[env],list[env],canonTerm,report,report){}.
  typeOfListTerm([],Lc,_,ListTp,Env,Ev,Exp,Rp,Rpx) :-
    typeOfTerm(iden(Lc,"[]"),ListTp,Env,Ev,Exp,Rp,Rpx).
  typeOfListTerm([Last],_,ElTp,ListTp,Env,Ev,apply(Lc,Op,tpl([Hd,Tl])),Rp,Rpx) :-
    isBinary(Last,",..",Lc,L,R),
    knownType(iden(Lc,",.."),newVar("_"),Env,E0,Op,Rp,Rp0),
    typeOfTerm(L,ElTp,E0,E1,Hd,Rp0,Rp1),
    typeOfTerm(R,ListTp,E1,Ev,Tl,Rp1,Rpx).
  typeOfListTerm([El,..More],_,ElTp,ListTp,Env,Ev,apply(Lc,Op,tpl([Hd,Tl])),Rp,Rpx) :-
    Lc = El.loc,
    knownType(iden(Lc,",.."),newVar("_"),Env,E0,Op,Rp,Rp0),
    typeOfTerm(El,ElTp,E0,E1,Hd,Rp0,Rp1),
    typeOfListTerm(More,Lc,ElTp,ListTp,E1,Ev,Tl,Rp1,Rpx).

  private checkSequenceTerm:(location,list[ast],tipe,list[env],list[env],canonTerm,report,report){}.
  checkSequenceTerm(Lc,Els,Tp,Env,Ev,Exp,Rp,Rpx) :-
    Seq = genIden(Lc),
    macroSequenceTerm(Els,Lc,Seq,Tsts),
    typeOfTerm(binary(Lc,"@@",Seq,roundTuple(Lc,Tsts)),Tp,Env,Ev,Exp,Rp,Rpx).

  private macroSequenceTerm:(list[ast],location,ast,list[ast]){}.
  macroSequenceTerm([],Lc,V,[unary(Lc,"_eof",V)]).
  macroSequenceTerm([E,..L],_,V,[ternary(E.loc,"_hdtl",V,E,NX),..M]) :-
    NX = genIden(Lc),
    macroSequenceTerm(L,Lc,NX,M).

  macroMapEntries:(location,list[ast],report,report) => ast.
  macroMapEntries(Lc,[],Rp,Rp) => iden(Lc,"_empty").
  macroMapEntries(_,[E,..L],Rp,Rpx) => roundTerm(Lc,iden(Lc,"_put"),[macroMapEntries(Lc,L,Rp,Rpx),Ky,Vl]) :-
    isBinary(E,"->",Lc,Ky,Vl).
  macroMapEntries(Lc,[E,..L],Rp,Rpx) => macroMapEntries(Lc,L,Rp0,Rpx) :-
    reportError("invalid entry in map \(E)",E.loc,Rp,Rp0).

  recordAccessExp:(location,ast,string,tipe,list[env],list[env],canonTerm,report,report){}.
  recordAccessExp(Lc,Rc,Fld,ET,Env,Ev,dot(Rec,Fld),Rp,Rpx) :-
    AT = newVar("_R"),
    knownType(Rc,AT,Env,Ev,Rec,Rp,Rp0),
    faceOfType(deRef(AT),Env,Face),
    moveConstraints(Face,_,faceType(Fields)),
    fieldInFace(Fields,AT,Fld,Lc,FTp,Rp0,Rp1)!,
    (_,Tp) = freshen(FTp,[]), -- the record is this to the right of dot.
    checkType(Lc,Tp,ET,Env,Rp1,Rpx).

  fieldInFace:(list[(string,tipe)],tipe,string,location,tipe,report,report){}.
  fieldInFace(Fields,_,Nm,_,Tp,Rp,Rp) :-
    (Nm,Tp) in Fields!.
  fieldInFace(_,Tp,Nm,Lc,anonType,Rp,Rpx) :-
    reportError("field \(Nm) not declared in \(Tp)",Lc,Rp,Rpx).

  private genTpVars:(list[ast])=>list[tipe].
  genTpVars([])=>[].
  genTpVars([_,..I]) => [newVar("__"),..genTpVars(I)].

  private checkNonTerminal:(ast,tipe,tipe,list[env],list[env],canonNT,report,report){}.
  checkNonTerminal(Tpl,StrmTp,ElTp,E,Env,grTerms(Terms),Rp,Rpx) :-
    isSquareTuple(Tpl,Lc,Els),
    typeOfTerm(iden(Lc,"_hdtl"),predType(tupleType([StrmTp,ElTp,StrmTp])),E,E0,HDTL,Rp,Rp0),
    checkTerminals(Els,HDTL,Terms,ElTp,E0,Env,Rp0,Rpx).
  checkNonTerminal(strg(Lc,Text),StrmTp,ElTp,E,Env,grTerms(Terms),Rp,Rpx) :-
    typeOfTerm(iden(Lc,"_hdtl"),predType(tupleType([StrmTp,ElTp,StrmTp])),E,E0,HDTL,Rp,Rp0),
    checkTerminals(explodeStringLit(Lc,Text),HDTL,Terms,ElTp,E0,Env,Rp0,Rpx).  -- strings are exploded into code points
  checkNonTerminal(Term,Tp,ElTp,Env,Ex,GrNT,Rp,Rpx) :-
    isRoundTuple(Term,Lc,Els),
    checkNonTerminals(Els,Tp,ElTp,Env,Ex,GrNT,Rp,Rpx)!.
  checkNonTerminal(Term,Tp,ElTp,Env,Ex,grConj(Lhs,Rhs),Rp,Rpx) :-
    isBinary(Term,",",Lc,L,R),
    checkNonTerminal(L,Tp,ElTp,Env,E1,Lhs,Rp,Rp0),
    checkNonTerminal(R,Tp,ElTp,E1,Ex,Rhs,Rp0,Rpx).
  checkNonTerminal(Term,Tp,ElTp,Env,Ex,grCond(Test,Either,Or),Rp,Rpx) :-
    isBinary(Term,"|",_,L,R),
    isBinary(L,"?",_,T,Th),
    checkNonTerminal(T,Tp,ElTp,Env,E0,Test,Rp,Rp0),
    checkNonTerminal(Th,Tp,ElTp,E0,E1,Either,Rp0,Rp1),
    checkNonTerminal(R,Tp,ElTp,E1,Ex,Or,Rp1,Rpx).
  checkNonTerminal(Term,Tp,ElTp,Env,Ex,grDisj(Either,Or),Rp,Rpx) :-
    isBinary(Term,"|",_,L,R),
    \+isBinary(L,"?",_,_,_),
    checkNonTerminal(L,Tp,ElTp,Env,E1,Either,Rp,Rp0),
    checkNonTerminal(R,Tp,ElTp,E1,Ex,Or,Rp0,Rpx).
  checkNonTerminal(Term,Tp,ElTp,Env,Ex,grOne(Test),Rp,Rpx) :-
    isUnary(Term,"!",_,N),
    checkNonTerminal(N,Tp,ElTp,Env,Ex,Test,Rp,Rpx).
  checkNonTerminal(Term,Tp,ElTp,Env,Env,grNeg(Test),Rp,Rpx) :-
    isUnary(Term,"\\+",Lc,N),
    checkNonTerminal(N,Tp,ElTp,Env,_,Test,Rp,Rpx).
  checkNonTerminal(Term,Tp,ElTp,Env,Env,grAhed(Test),Rp,Rpx) :-
    isUnary(Term,"+",Lc,N),
    checkNonTerminal(N,Tp,ElTp,Env,_,Test,Rp,Rpx).
  checkNonTerminal(Term,_,_,Env,Ev,grTest(unifyCond(Lc,Lhs,Rhs)),Rp,Rpx) :-
    isBinary(Term,"=",Lc,L,R),
    TV = newVar("_"),
    typeOfTerm(L,TV,Env,E0,Lhs,Rp,Rp0),
    typeOfTerm(R,TV,E0,Ev,Rhs,Rp0,Rpx).
  checkNonTerminal(Term,_,_,Env,Ev,grTest(negCond(unifyCond(Lc,Lhs,Rhs))),Rp,Rpx) :-
    isBinary(Term,"\\=",Lc,L,R),
    TV = newVar("_"),
    typeOfTerm(L,TV,Env,E0,Lhs,Rp,Rp0),
    typeOfTerm(R,TV,E0,Ev,Rhs,Rp0,Rpx).
  checkNonTerminal(Term,Tp,_,Env,Ev,grDip(v(Lc,NV),Cond),Rp,Rpx) :-
    isUnary(Term,"@",Lc,Test),
    isRoundTerm(Test,_,Op,Args),
    NV = _str_gen("_"),
    checkCond(appl(Lc,binary(Lc,".",iden(Lc,NV),Op),tupl(Lc,"()",Args)),declareVar(NV,vr(v(Lc,NV),Tp),Env),Ev,Cond,Rp,Rpx).
  checkNonTerminal(Term,Tp,_,Env,Ev,NT,Rp,Rpx) :-
    isRound(Term,Lc,F,A),
    GrTp = newVar("_G"),
    knownType(F,GrTp,Env,E0,Op,Rp,Rp0),
    ( deRef(GrTp) = grammarType(ArgTp,StrmTp) ?
      ( checkType(Lc,StrmTp,Tp,Env,Rp0,Rp1) ?
        typeOfArg(A,ArgTp,E0,Ev,Arg,Rp1,Rpx),
        NT = grCall(Lc,Op,Arg) |
        reportError("type of \(Op) : \(GrTp) not consistent with stream type \(Tp)",Lc,Rp0,Rpx),
        NT = grTerms([]), Ev = E0) |
      reportError("\(F) : \(GrTp) not a grammar",Lc,Rp0,Rpx),
      NT = grTerms([]),
      Ev = Env).
  checkNonTerminal(Term,StreamTp,ElTp,Env,Ev,grDip(v(Lc,NV),Cond),Rp,Rpx) :-
    isIden(Term,Lc,"eof"),
    NV = _str_gen("_"),
    checkCond(unary(Lc,"_eof",iden(Lc,NV)),declareVar(NV,vr(v(Lc,NV),StreamTp),Env),Ev,Cond,Rp,Rpx).
  checkNonTerminal(Term,_,_,Env,Ex,grTest(Cond),Rp,Rpx) :-
    isBraceTuple(Term,Lc,Els),
    checkConds(Els,Env,Ex,Cond,Rp,Rpx).

  private checkNonTerminals:(list[ast],tipe,tipe,list[env],list[env],canonNT,report,report){}.
  checkNonTerminals([],_,_,Env,Env,grTest(trueCond),Rp,Rp).
  checkNonTerminals([N,..Els],Tp,ElTp,Env,Ev,grConj(Lhs,Rhs),Rp,Rpx) :-
    checkNonTerminal(N,Tp,ElTp,Env,E0,Lhs,Rp,Rp0),
    checkNonTerminals(Els,Tp,ElTp,E0,Ev,Rhs,Rp0,Rpx).

  private checkTerminals:(list[ast],canonTerm,list[(location,canonTerm,canonTerm)],tipe,list[env],list[env],report,report){}.
  checkTerminals([],_,[],_,Env,Env,Rp,Rp).
  checkTerminals([T,..L],V,[(T.loc,V,TT),..M],ElTp,Env,Ev,Rp,Rpx) :-
    typeOfTerm(T,ElTp,Env,E0,TT,Rp,Rp0),
    checkTerminals(L,V,M,ElTp,E0,Ev,Rp0,Rpx).

  collectPrograms:(list[canonRule],list[env],list[constraint],list[canonDef],list[canonDef]){}.
  collectPrograms([],_,_,Defs,Defs).
  collectPrograms([Eqn,..Stmts],Env,Cx,[funDef(Lc,Nm,Tp,Cx,[Eqn,..Eqns]),..Defs],Dx) :-
    Eqn = equation(Lc,Nm,_,_,_),
    collectEquations(Stmts,S0,Nm,Eqns),
    isVar(Nm,Env,vr(_,Tp)),
    collectPrograms(S0,Env,Cx,Defs,Dx).
  collectPrograms([Cl,..Stmts],Env,Cx,[relDef(Lc,Nm,Tp,Cx,[Cl,..Clses]),..Defs],Dx) :-
    Cl = clause(Lc,Nm,_,_),
    collectClauses(Stmts,S0,Nm,Clses),
    isVar(Nm,Env,vr(_,Tp)),
    collectPrograms(S0,Env,Cx,Defs,Dx).
  collectPrograms([vrDef(Lc,Nm,Value,Cond),..Stmts],Env,Cx,[varDef(Lc,Nm,Tp,Cx,Value,Cond),..Defs],Dx) :-
    isVar(Nm,Env,vr(_,Tp)),
    collectPrograms(Stmts,Env,Cx,Defs,Dx).
  collectPrograms([Cl,..Stmts],Env,Cx,[classDef(Lc,Nm,Tp,Cx,[Cl,..Rules],Face),..Defs],Dx) :-
    isRuleForClass(Cl,Lc,Nm,Face),
    collectClassRules(Stmts,S0,Nm,Rules),
    isVar(Nm,Env,vr(_,Tp)),
    collectPrograms(S0,Env,Cx,Defs,Dx).
  collectPrograms([Rl,..Stmts],Env,Cx,[grammDef(Lc,Nm,Tp,Cx,[Rl,..Rules]),..Defs],Dx) :-
    isGrammarRule(Rl,Lc,Nm),
    collectGrammarRules(Stmts,S0,Nm,Rules),
    isVar(Nm,Env,vr(_,Tp)),
    collectPrograms(S0,Env,Cx,Defs,Dx).

  collectClauses:(list[canonRule],list[canonRule],string,list[canonRule]){}.
  collectClauses([],[],_,[]).
  collectClauses([Cl,..Stmts],Sx,Nm,[Cl,..Ex]) :-
    Cl = clause(_,Nm,_,_),
    collectMoreClauses(Stmts,Sx,Nm,Ex).

  collectMoreClauses:(list[canonRule],list[canonRule],string,list[canonRule]){}.
  collectMoreClauses([Cl,..Stmts],Sx,Nm,[Cl,..Ex]) :-
    Cl = clause(_,Nm,_,_),
    collectMoreClauses(Stmts,Sx,Nm,Ex).
  collectMoreClauses([Rl,..Stmts],[Rl,..Sx],Nm,Eqns) :-
    \+Rl = clause(_,Nm,_,_),
    collectMoreClauses(Stmts,Sx,Nm,Eqns).
  collectMoreClauses([],[],_,[]).

  collectEquations:(list[canonRule],list[canonRule],string,list[canonRule]){}.
  collectEquations([Eqn,..Stmts],Sx,Nm,[Eqn,..Ex]) :-
    Eqn = equation(_,Nm,_,_,_),
    collectEquations(Stmts,Sx,Nm,Ex).
  collectEquations([Rl,..Stmts],[Rl,..Sx],Nm,Eqns) :-
    \+Rl=equation(_,Nm,_,_,_),
    collectEquations(Stmts,Sx,Nm,Eqns).
  collectEquations([],[],_,[]).

  collectGrammarRules:(list[canonRule],list[canonRule],string,list[canonRule]){}.
  collectGrammarRules([Rl,..Stmts],Sx,Nm,[Rl,..Ex]) :-
    isGrammarRule(Rl,_,Nm),
    collectGrammarRules(Stmts,Sx,Nm,Ex).
  collectGrammarRules([Rl,..Stmts],[Rl,..Sx],Nm,Eqns) :-
    collectGrammarRules(Stmts,Sx,Nm,Eqns).
  collectGrammarRules([],[],_,[]).

  isGrammarRule:(canonRule,location,string){}.
  isGrammarRule(grRule(Lc,Nm,_,_,_),Lc,Nm).

  collectClassRules:(list[canonRule],list[canonRule],string,list[canonRule]){}.
  collectClassRules([Cl,..Stmts],Sx,Nm,[Cl,..Ex]) :-
    isRuleForClass(Cl,_,Nm,_),
    collectClassRules(Stmts,Sx,Nm,Ex).
  collectClassRules([Rl,..Stmts],[Rl,..Sx],Nm,Eqns) :-
    collectClassRules(Stmts,Sx,Nm,Eqns).
  collectClassRules([],[],_,[]).

  isRuleForClass:(canonRule,location,string,tipe){}.
  isRuleForClass(clRule(Lc,Nm,_,_,_,Face),Lc,Nm,Face).

  private explodeStringLit:(location,string) => list[ast].
  explodeStringLit(Lc,Str) => makeIntList(explode(Str),Lc).

  private makeIntList:(list[integer],location) => list[ast].
  makeIntList([],_) => [].
  makeIntList([Code,..L],Lc) => [intg(Lc,Code),..makeIntList(L,Lc)].

  private streamVar:string.
  streamVar = "stream_X".

  private typeOfVar:(location,vr,tipe,list[env],canonTerm,report,report){}.
  typeOfVar(Lc,vr(V,VT),Tp,Env,Term,Rp,Rpx) :-
    (_,FTp) = freshen(VT,pickupThisType(Env)),
    manageConstraints(FTp,[],Lc,relocate(V,Lc),MTp,Term),
    checkType(Lc,MTp,Tp,Env,Rp,Rpx).

  private manageConstraints:(tipe,list[constraint],location,canonTerm,tipe,canonTerm){}.
  manageConstraints(constrained(T,C),Cons,Lc,V,MTp,Exp) :-
    manageConstraints(T,[C,..Cons],Lc,V,MTp,Exp).
  manageConstraints(Tp,[],_,V,Tp,V).
  manageConstraints(Tp,Cons,Lc,V,Tp,over(Lc,V,reverse(Cons))).

  private knownType:(ast,tipe,list[env],list[env],canonTerm,report,report){}.
  knownType(V,Tp,Env,Env,Term,Rp,Rpx) :-
    ( isIden(V,Lc,Nm) ?
      ( isVar(Nm,Env,Spec) ?
        typeOfVar(Lc,Spec,Tp,Env,Term,Rp,Rpx), Env=Ev |
        reportError("variable \(V) not declared",Lc,Rp,Rpx),
        Term=v(Lc,Nm)) |
      typeOfTerm(V,Tp,Env,Ex,Term,Rp,Rpx)).

  private typeOfCall:(location,canonTerm,ast,tipe,tipe,list[env],list[env],canonTerm,report,report){}.
  typeOfCall(Lc,Fun,A,funType(ArgTp,ResTp),Tp,Env,Ev,apply(Lc,Fun,Args),Rp,Rpx) :-
    checkType(Lc,ResTp,Tp,Env,Rp,Rp0),
    typeOfArg(A,ArgTp,Env,Ev,Args,Rp0,Rpx).
  typeOfCall(Lc,Fun,A,classType(ArgTp,ResTp),Tp,Env,Ev,apply(Lc,Fun,Args),Rp,Rpx) :-
    checkType(Lc,ResTp,Tp,Env,Rp,Rp0),
    typeOfArg(A,ArgTp,Env,Ev,Args,Rp0,Rpx).
  typeOfCall(Lc,Fun,_,Ftp,_,Env,Env,Fun,Rp,Rpx) :-
    reportError("\(Fun) : \(Ftp) is not a function",Lc,Rp,Rpx).

  private checkType:(location,tipe,tipe,list[env],report,report){}.
  checkType(Lc,Actual,Expected,Env,Rp,Rpx) :-
    ( sameType(Actual,Expected,Env) ? Rp=Rpx | reportError("\(Actual) not consistent with \(Expected)",Lc,Rp,Rpx)).

  private checkGrammarType:(location,list[env],tipe,tipe,report,report){}.
  checkGrammarType(Lc,Env,Tp,ElTp,Rp,Rpx) :-
    isContract("stream",Env,conEntry(_,_,Spec,_)),
    (_,conTract(_,[Arg],[Dep])) = freshen(Spec,pickupThisType(Env)),
    checkType(Lc,Arg,Tp,Env,Rp,Rp0),
    checkType(Lc,Dep,ElTp,Env,Rp0,Rpx).

  private pickupThisType:(list[env]) => map[string,tipe].
  pickupThisType(Env) => [ "this" -> ThisType] :- isVar("this",Env,vr(_,ThisType)).
  pickupThisType(_) => [].

  private findType:(string,location,list[env],report,report) => tipe.
  findType(Nm,_,Env,Rp,Rp) => Tp :-
    isType(Nm,Env,_,Tp).
  findType(Nm,Lc,_,Rp,Rpx) => anonType :-
    reportError("type \(Nm) not known",Lc,Rp,Rpx).

  private mkTypes:(integer) => list[tipe].
  mkTypes(0) => [].
  mkTypes(N) => [newVar("_"),..mkTypes(N-1)].

  private computeNewVars:(list[env]) => list[canonTerm].
  computeNewVars(Env) => (values(topVars(Env))//pickVar).

  private pickVar:(vr) => canonTerm.
  pickVar(vr(Trm,_)) => Trm.

  private pushFace:(list[(string,tipe)],location,list[env]) => list[env].
  pushFace([],_,E) => E.
  pushFace([(N,T),..L],Lc,E) => pushFace(L,Lc,declareVar(N,vr(v(Lc,N),T),E)).

  computeExport:(list[canonDef],list[(string,tipe)],list[(string,defnKind)],
                  list[(string,tipe)],list[(string,tipe)],list[string],list[conEntry],list[implEntry]){}.
  computeExport([],_,_,[],[],[],[],[]).
  computeExport([Def,..Defs],Fields,Public,Exports,Types,Enums,Contracts,Impls) :-
    exportDef(Def,Fields,Public,Exports,Ex,Types,Tx,Enums,Clx,Contracts,Cx,Impls,Ix)!,
    computeExport(Defs,Fields,Public,Ex,Tx,Clx,Cx,Ix).

  exportDef:(canonDef,list[(string,tipe)],list[(string,defnKind)],
          list[(string,tipe)],list[(string,tipe)],
          list[(string,tipe)],list[(string,tipe)],
          list[string],list[string],
          list[conEntry],list[conEntry],
          list[implEntry],list[implEntry]){}.
  exportDef(funDef(_,Nm,Tp,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Enums,Enums,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(relDef(_,Nm,Tp,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Enums,Enums,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(classDef(_,Nm,Tp,_,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,[Nm,..Clx],Clx,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(typeDef(_,Nm,_,FaceRule),_,Public,Exports,Exports,[(Nm,FaceRule),..Tx],Tx,Enums,Enums,Cons,Cons,Impl,Impl) :-
    isPublicType(Nm,Public).
  exportDef(varDef(_,Nm,Tp,_,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Enums,Enums,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(grammDef(_,Nm,Tp,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Enums,Enums,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(cnDefn(_,Nm,Contract),_,Public,Ex,Ex,Types,Types,Enums,Enums,[Contract,..Cons],Cons,Impl,Impl) :-
    (Nm,con) in Public.
  exportDef(implDef(_,INm,ImplName,Spec,_,_,_,_),_,Public,Ex,Ex,Tps,Tps,Enums,Enums,Cons,Cons,[implEntry(ImplName,Spec),..Ix],Ix) :-
    isPublicImplementation(INm,Public)!.
  exportDef(_,_,_,Ex,Ex,Tps,Tps,Enums,Enums,Cons,Cons,Impls,Impls).

  exportViz:(string,defnKind,list[(string,defnKind)]) => visibility.
  exportViz(Nm,K,P) => pUblic :- (Nm,K) in P.
  exportViz(_,_,_) => priVate.

  isPublicVar:(string,list[(string,tipe)],list[(string,defnKind)]){}.
  isPublicVar(Nm,_,Public) :-
    (Nm,valu) in Public.
  isPublicVar(Nm,Fields,_) :-
    (Nm,_) in Fields.

  isPublicType:(string,list[(string,defnKind)]){}.
  isPublicType(Nm,Public) :-
    (Nm,tpe) in Public.

  isPublicImplementation:(string,list[(string,defnKind)]){}.
  isPublicImplementation(Nm,Public) :-
    (Nm,impl) in Public.

  findImportedImplementations:(list[pkgSpec],list[implEntry],list[implEntry]){}.
  findImportedImplementations([pkgSpec(_,_,_,_,_,Impls,_),..Specs],D0,D1) :-
    findImportedImplementations(Specs,Impls<>D0,D1).
  findImportedImplementations([],D,D).
}
