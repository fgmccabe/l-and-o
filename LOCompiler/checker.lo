lo.comp.typecheck{
  import lo.
  import lo.comp.location.
  import lo.comp.ast.
  import lo.comp.abstract.
  import lo.comp.wff.
  import lo.comp.canon.
  import lo.comp.types.
  import lo.comp.parseType.
  import lo.comp.freshen.
  import lo.comp.unify.
  import lo.comp.dependencies.
  import lo.comp.dict.
  import lo.comp.errors.
  import lo.comp.macro.
  import lo.comp.repository.
  import lo.comp.imports.

  public checkProgram:(ast,repository)=>canonProg.
  checkProgram(Prog,Repo) => prog(Pkg,Imports,ODefs,OOthers,Exports,Types,Contracts,Impls)) :-
    isBraceTerm(Prog,Lc,Pk,Els),
    thetaEnv(packageName(Pk),Repo,Lc,Els,[],pushScope(stdDict),_,Defs,Public,Imports,Others,reportBase,Rp0),
    findImportedImplementations(Imports,[],OverDict),
    overload(Defs,OverDict,ODict,ODefs,Rp0,Rp1),
    overloadOthers(Others,ODict,OOthers,Rp1,Rpx),
    computeExport(ODefs,[],Public,Exports,Types,Contracts,Impls).

  private thetaEnv:(string,repository,location,list[ast],list[(string,tipe)],list[env],list[env],
      list[canonDef],list[(string,defnKind)],list[(visibility,uri,version)],list[canonDef],report,report){}.
  thetaEnv(Path,Repo,Lc,Els,Fields,Base,TheEnv,Defs,Public,Imports,Others,Rp,Rpx) :-
    macroRewrite(Els,Stmts,Rp,Rp0),
    dependencies(Stmts,Groups,Public,Annots,Imps,Otrs,Rp0,Rp1),
    processImportGroup(Imps,Imports,Repo,Base,IBase,Rp1,Rp2),
    checkGroups(Groups,Fields,Annots,Defs,pushFace(Fields,Lc,IBase),TheEnv,Path,Rp2,Rp3),
    checkOthers(Otrs,Others,TheEnv,Path,Rp3,Rpx).

  processImportGroup:(list[ast],list[pkgSpec],repository,list[env],list[env],report,report){}.
  processImportGroup(Stmts,ImportSpecs,Repo,Env,Ex,Rp,Rpx) :-
    findAllImports(Stmts,Imports),
    importAll(Imports,Repo,[],AllImports),
    importAllDefs(AllImports,ImportSpecs,Repo,Env,Ex,Rp,Rpx).

  findAllImports:(list[ast],list[(location,visibility,pkg)]){}.
  findAllImports([],[]).
  findAllImports([St,..More],[findImport(St,private),..Imports]) :-
    findAllImports(More,Imports).

  findImport:(ast,visibility)=>(location,visibility,pkg).
  findImport(St,_) => findImport(I,priVate) :-
    isUnary(St,"private",_,I),
    findImport(I,_,private,Spec).
  findImport(St,_) => findImport(I,pUblic):-
    isUnary(St,"public",Lc,I).
  findImport(St,Viz) => (Lc,Viz,Pkg) :-
    isUnary(St,"import",Lc,P),
    pkgName(P,Pkg).

  importAll:(list[(location,visibility,pkg)],repository,list[(location,visibility,pkg)],list[(location,visibility,pkg)],report,report){}.
  importAll([],Repo,AllImports,AllImports,Rp,Rp).
  importAll([P,..L],Repo,SoFar,All,Rp,Rpx) :-
    (P in SoFar ?
      importAll(L,Repo,SoFar,All,Rp,Rpx) |
      importMore(Repo,P,SoFar,SoF,L,Lx,Rp,Rp0),
      importAll(Lc,Repo,SoF,All,Rp0,Rpx)).

  importMore:(repository,(location,visibility,pkg),list[(location,visibility,pkg)],list[(location,visibility,pkg)],list[(location,visibility,pkg)],report,report){}.
  importMore(Repo,(Lc,Viz,Pkg),SoFar,[(Lc,Viz,Pkg),..SoFar],Inp,More,Rp,Rp) :-
    importPkg(Pkg,Repo,pkgSpec(_,_,_,_,_,_,_,Imports)),
    addPublicImports(Imports,Inp,More).
  importMore(_,(Lc,_,Pkg),SoFar,SoFar,Inp,Inp,Rp,reportError("could not import package $(Pkg)",Lc,Rp)).

  addPublicImports:(list[(location,visibility,pkg)],list[(location,visibility,pkg)],list[(location,visibility,pkg)]){}.
  addPublicImports([],Imp,Imp).
  addPublicImports([(Lc,pUblic,Pkg),..I],Rest,[(Lc,pUblic,Pkg),..Out]) :-
    addPublicImports(I,Rest,Out).
  addPublicImports([(_,priVate,_),..I],Rest,Out) :-
    addPublicImports(I,Rest,Out).

  importAllDefs:(list[(location,visibility,pkg)],list[pkgSpec],repository,list[env],list[env]){}.
  importAllDefs([],[],_,Env,Env).
  importAllDefs([(Lc,Viz,Pkg),..More], [Spec,..Specs],Repo,Env,Ex) :-
    importDefs(Spec,Lc,Env,Ev0),
    importAllDefs(More,Specs,Repo,Ev0,Ex).

  importDefs:(pkgSpec,location,list[env],list[env]){}.
  importDefs(pkgSpec(_,_,faceType(Exported),faceType(Types),_,Cons,_,_),Lc,Env,Ex) :-
    importContracts(Cons,importTypes(Types,Lc,declareFields(Exported,Lc,Env)),Ex).

  declareFields:(list[(string,tipe)],location,list[env]) => list[env].
  declareFields([],_,Env) => Env.
  declareFields([(Nm,Tp),..More],Lc,Env) =>
    declareFields(More,Lc,declareVar(Nm,vr(Lc,v(Nm),Tp),Env)).

  importTypes:(list[(string,tipe)],location,list[env]) => list[env].
  importTypes([],_,Env)=>Env.
  importTypes([(Nm,Rule),..More],Lc,Env) => importTypes(More,Lc,E0) :-
    pickTypeTemplate(Rule,Type),
    declareType(Nm,tpDef(Lc,Type,Rule),Env,E0).

  pickTypeTemplate:(tipe)=>tipe.
  pickTypeTemplate(univType(B,Tp)) => univType(B,pickTypeTemplate(Tp))).
  pickTypeTemplate(typeRule(Lhs,_) => Lhs.

  importContracts:(list[conDef],list[env],list[env]){}.
  importContracts([],Env,Env).
  importContracts([C,..L],E,Env) :-
    C = conDef(Nm,_,_,_,_),
    declareContract(Nm,C,E,E0),
    importContracts(L,E0,Env).

  private checkGroups:(list[list[defn]],list[(string,tipe)],list[(string,ast)],list[canonDef],list[env],list[env],string,report,report){}.
  checkGroups([],_,_,[],E,E,_,Rp,Rp).
  checkGroups([Gp,..More],Fields,Annots,Defs,Env,E,Path,Rp,Rpx) :-
    checkGroup(Gp,Gp,Fields,Annots,Defs,D0,Env,E0,Path,Rp,Rp0),
    checkGroups(More,Fields,Annots,D0,E0,E,Path,Rp0,Rpx).

  private checkGroup:(list[defn],list[defn],list[(string,tipe)],list[(string,ast)],list[canonDef],list[canonDef],list[env],list[env],string,report,report){}.
  checkGroup(Grp,[defn(_,tpe,_,_,_),.._],_,_,Defs,Dx,Env,Ex,Path,Rp,Rpx) :-
    typeGroup(Grp,Defs,Dx,Env,Ex,Path,Rp,Rpx).
  checkGroup(Grp,[defn(_,var,_,_,_),.._],Fields,Annots,Defs,Dx,Env,Ex,Path,Rp,Rpx) :-
    varGroup(Grp,Fields,Annots,Defs,Dx,Env,Ex,Path,Rp,Rpx).
  checkGroup(Grp,[defn(_,con,_,_,_),.._],_,_,Defs,Dx,Env,Ex,Path,Rp,Rpx) :-
    contractGroup(Grp,Defs,Dx,Env,Ex,Path,Rp,Rpx).
  checkGroup(Grp,[defn(_,impl,_,_,_),.._],_,_,Defs,Dx,Env,Ex,Path,Rp,Rpx) :-
    implementationGroup(Grp,Defs,Dx,Env,Ex,Path).

  -- This is very elaborate - to support mutual recursion amoung types.

  private typeGroup:(list[defn],list[canonDef],list[canonDef],list[env],list[env],string,report,report){}.
  typeGroup(Grp,Defs,Dx,Env,Ex,Path,Rp,Rpx) :-
    defineTypes(Grp,Env,TmpEnv,Path,Rp,Rp0),
    parseTypeDefs(Grp,TpDefs,[],TmpEnv,Path,Rp0,Rpx),
    declareTypes(TpDefs,Defs,Dx,Env,Ex).

  private defineTypes:(list[defn],list[env],list[env],string,report,report){}.
  defineTypes([],Env,Env,_,Rp,Rp).
  defineTypes([defn(N,tpe,Lc,_,[Stmt]),..More],Env,Ex,Path,Rp,Rpx) :-
    defineType(N,Lc,Stmt,Env,E0,Path,Rp,Rp0),
    defineTypes(More,E0,Ex,Path,Rp0,Rpx).
  defineTypes([defn(N,tpe,Lc,_,[_,.._]),..More],Env,Ex,Path,Rp,Rpx) :-
    Rp0=reportError("multiple type definition statements for $(N)",Lc,Rp),
    defineTypes(More,Env,Ex,Path,Rp0,Rpx).

  private defineType:(string,location,ast,list[env],list[env],string,report,report){}.
  defineType(N,Lc,_,Env,Ex,Path,Rp,Rpx) :-
    ( isType(N,Env,OLc,_) ?
        Rpx=reportError("type $(N) already defined at $(OLc)",Lc,Rp),
        Ex = Env |
        parseTypeTemplate(St,[],Env,Type,Path,Rp,Rpx),
        declareType(N,tpDef(Lc,Type,faceType([])),Env,Ex)).

  private parseTypeDefs:(list[defn],list[canonDef],list[canonDef],list[env],string,report,report){}.
  parseTypeDefs([],Defs,Defs,_,_,Rp,Rp).
  parseTypeDefs([defn(N,tpe,Lc,_,[Stmt]),..More],Defs,Dx,TmpEnv,Path,Rp,Rpx) :-
    parseTypeDefinition(N,Lc,Stmt,Defs,D0,TmpEnv,Path,Rp,Rp0),
    parseTypeDefs(More,D0,Dx,TmpEnv,Path,Rp0,Rpx).

  private declareTypes:(list[canonDef],list[canonDef],list[canonDef],list[env],list[env]){}.
  declareTypes([],Defs,Defs,Env,Env).
  declareTypes([typeDef(Lc,N,Type,FaceRule),..More],[typeDef(Lc,N,Type,FaceRule),..Defs],Dx,Env,Ex) :-
    declareType(N,tpDef(Lc,Type,FaceRule),Env,E0),
    declareTypes(More,Defs,Dx,E0,Ex).

  -- handle program definitions
  private varGroup:(list[defn],list[(string,tipe)],list[(string,ast)],list[canonDef],list[canonDef],list[env],list[env],string,report,report){}.
  varGroup(Grp,Fields,Annots,Defs,Dx,Base,Env,Path,Rp,Rpx) :-
    parseAnnotations(Grp,Fields,Annots,Base,Env,Path,Rp,Rp0)!,
    checkVarRules(Grp,Env,Defs,Dx,Path,Rp0,Rpx).

  private parseAnnotations:(list[defn],list[(string,ast)],list[env],list[env],string,report,report){}.
  parseAnnotations([],_,_,Env,Env,_,Rp,Rp).
  parseAnnotations([defn(Nm,var,_,_,_),..More],Fields,Annots,Env,Ex,Path,Rp,Rpx) :-
    ((Nm,Annot) in Annots)!,
    isBinary(Annot,":",Lc,_,T),
    parseType(T,Env,Tp,Rp,Rp0),
    declareVar(Nm,vr(Nm,Lc,Tp),Env,E0),
    parseAnnotations(More,Fields,Annots,E0,Ex,Path,Rp0,Rpx).
  parseAnnotations([defn(N,var,Lc,_,_),..More],Fields,Annots,Env,Ex,Path,Rp,Rpx) :-
    ((N,Tp) in Fields)!,
    declareVar(N,vr(N,Lc,Tp),Env,E0),
    parseAnnotations(More,Fields,Annots,E0,Ex,Path,Rp,Rpx).
  parseAnnotations([defn(N,var,Lc,_,_),..More],Fields,Annots,Env,Ex,Path,Rp,Rpx) :-
    Rp0=reportError("no type annotation for variable $(N)",Lc,Rp),
    parseAnnotations(More,Fields,Annots,Env,Ex,Path,Rp0,Rpx).

  private checkVarRules:(list[defn],list[env],list[canonDef],list[canonDef],string,report,report){}.
  checkVarRules([],_,Defs,Defs,_,Rp,Rp).
  checkVarRules([defn(N,var,Lc,_,Stmts),..More],Env,Defs,Dx,Path,Rp,Rpx) :-
    forEvidence(pickupVarType(N,Lc,Env,Rp,Rp0),pickupThisType(Env),Q,PT),
    declareTypeVars(pairs(Q),Lc,Env,StmtEnv),
    moveConstraints(PT,Cx,ProgramType),
    processStmts(Stmts,ProgramType,Rules,[],StmtEnv,Path,Rp0,Rp1),
    collectPrograms(Rules,Env,Cx,Defs,D0),
    checkVarRules(More,Env,D0,Dx,Path,Rp1,Rpx).

  private pickupVarType:(string,location,list[env],report,report) => tipe.
  pickupVarType(N,_,Env,Rp,Rp)=>Tp :-
    isVar(N,Env,vr(_,_,Tp)).
  pickupVarType(N,Lc,_,Rp,Rpx) => newVar("_") :- Rpx=reportError("$(N) not declared",Lc.Rp).

  private declareTypeVars:(list[(string,tipe)],location,list[env],list[env]){}.
  declareTypeVars([],_,Env,Env).
  declareTypeVars([("this",_),..Vars],Lc,Env,Ex) :- !,
    declareTypeVars(Vars,Lc,Env,Ex).
  declareTypeVars([(Nm,Tp),..Vars],Lc,Env,Ex) :-
    declareTypeVars(Vars,Lc,declareTypeExists(Nm,Tp,some(Lc),Env),Ex).

  private processStmts:(list[ast],tipe,list[canonRule],list[canonRule],list[env],string,report,report){}.
  processStmts([],_,Defs,Defs,_,_,Rp,Rp).
  processStmts([St,..More],ProgramType,Defs,Dx,Env,Path,Rp,Rpx) :-
    processStmt(St,ProgramType,Defs,D0,Env,Path,Rp,Rp0)!,
    processStmts(More,ProgramType,D0,Dx,Env,Path,Rp0,Rpx).

  private processStmt:(ast,tipe,list[canonRule],list[canonRule],list[env],string,report,report){}.
  processStmt(St,ProgramType,Defs,Defx,E,_,Rp,Rpx) :-
    isBinary(St,"=>",Lc,L,R),
    checkEquation(Lc,L,iden(Lc,"true"),R,ProgramType,Defs,Defx,E,Rp,Rpx).
  processStmt(St,ProgramType,Defs,Defx,E,_,Rp,Rpx) :-
    isBinary(St,":-",Lc,L,G),
    isBinary(L,"=>",_,H,R),
    checkEquation(Lc,H,G,R,ProgramType,Defs,Defx,E,Rp,Rpx).
  processStmt(St,ProgramType,Defs,Defx,E,_,Rp,Rpx) :-
    isBinary(St,":-",Lc,L,G),
    isBinary(L,"<=",_,H,R),
    checkClassRule(Lc,H,G,R,ProgramType,Defs,Defx,E,Rp,Rpx).
  processStmt(St,predType(AT),[clause(Lc,Nm,Args,Body),..Defs],Defs,E,_,Rp,Rpx) :-
    isBinary(St,":-",Lc,L,R),
    splitHead(L,Nm,A),
    typeOfTerm(A,AT,pushScope(E),E0,Lc,Args,Rp,Rp0),
    checkCond(R,E1,_,Body,Rp0,Rpx).
  processStmt(St,predType(AT),[clause(Lc,Nm,Args,trueCond,..Defs],Defs,E,_,Rp,Rpx) :-
    splitHead(St,Nm,A),
    typeOfTerm(A,AT,pushScope(E),E0,St.loc,Args,Rp,Rpx).
  processStmt(St,Tp,Defs,Dx,Env,_,Rp,Rpx) :-
    isBinary(St,"=",Lc,L,R),
    checkDefn(Lc,L,iden(Lc,"true"),R,Tp,Defs,Dx,Env,Rp,Rpx).
  processStmt(St,ProgramType,Defs,Defx,E,_,Rp,Rpx) :-
    isBinary(St,"<=",Lc,H,R),
    checkClassRule(Lc,H,iden(Lc,"true"),R,ProgramType,Defs,Defx,E,Rp,Rpx).
  processStmt(St,Tp,[clBody(Lc,Nm,tpl([]),Stmts,Others,Types),..Defs],Defs,E,Path,Rp,Rpx) :-
    isBraceTerm(St,Lc,L,Els),
    isIden(L,_,Nm),
    subPath(Path,marker(clss),Nm,ClassPath),
    checkClassBody(Tp,Lc,Els,pushScope(E),Stmts,Others,Types,ClassPath,Rp,Rpx).
  processStmt(St,classType(AT,Tp),[clBody(Lc,Nm,Arg,Stmts,Others,Types),..Defs],Defs,E,Path,Rp,Rpx) :-
    isBraceTerm(St,Lc,L,Els),
    splitHead(L,Nm,A),
    typeOfTerm(A,AT,pushScope(E),E1,Arg,Rp,Rp0),
    subPath(Path,marker(clss),Nm,ClassPath),
    checkClassBody(Tp,Lc,Els,E1,Stmts,Others,Types,_,ClassPath,Rp0,Rpx).
  processStmt(St,Tp,Defs,Dx,E,Path,Rp,Rpx) :-
    isBinary(St,"-->",Lc,L,R),
    checkGrammarRule(Lc,L,R,Tp,Defs,Dx,E,Path,Rp,Rpx).
  processStmt(St,Tp,Defs,Defs,_,_,Rp,Rpx) :-
    Rpx=reportError("Statement $(St) not consistent with expected type $(Tp)",St.loc,Rp).

  private splitHead:(ast,string,ast){}.
  splitHead(T,Nm,A) :- isRound(T,_,Nm,A).
  splitHead(T,Nm,Tp) :- isIden(T,Lc,Nm), isRoundTuple(Tp,Lc,[]).

  private checkEquation:(location,ast,ast,ast,tipe,list[canonRule],list[canonRule],list[env],report,report){}.
  checkEquation(Lc,H,G,R,funType(AT,RT),[equation(Lc,Nm,Args,Cond,Exp),..Defs],Defs,E,Rp,Rpx) :-
    splitHead(H,Nm,A),
    typeOfTerm(A,AT,pushScope(E),E0,Lc,Args,Rp,Rp0),
    checkCond(G,E0,E1,Cond,Rp0,Rp1),
    typeOfTerm(R,RT,E1,_,Exp,Rp1,Rpx).
  checkEquation(Lc,_,_,_,ProgramType,Defs,Defs,_,Rp,Rpx) :-
    Rpx=reportError("equation not consistent with expected type: $(ProgramType)",Lc,Rp).

  private checkDefn:(location,ast,ast,ast,tipe,list[canonDef],list[canonDef],report,report){}
  checkDefn(Lc,L,C,R,Tp,[vrDef(Lc,Nm,Cond,Value),..Dx],Dx,E,Rp,Rpx) :-
    isIden(L,_,Nm),
    checkCond(C,pushScope(E),E1,Cond,Rp,Rp0),
    typeOfTerm(R,Tp,E1,_,Value,Rp0,Rpx).

  private checkClassRule:(location,ast,ast,ast,tipe,list[canonRule],list[canonRule],list[env],report,report){}.
  checkClassRule(Lc,H,G,R,classType(AT,_),[clRule(Lc,Nm,Arg,Repl,Cond,SuperFace),..Defs],Defs,E,Rp,Rpx) :-
    splitHead(H,Nm,A),
    typeOfTerm(A,AT,pushScope(E),E1,Arg,Rp,Rp0),
    SuperTp = newVar("S"),
    checkCond(G,E1,E2,Cond,Rp0,Rp1),
    typeOfTerm(R,SuperTp,E2,_,Repl,Rp1,Rpx),
    generateClassFace(SuperTp,E1,SuperFace).

  private generateClassFace:(tipe,list[env],tipe){}.
  generateClassFace(Tp,Env,Face) :-
    freshen(Tp,voidType,Q,Plate),
    (Plate = classType(_,T); T=Plate),
    getTypeFace(T,Env,F),
    freezeType(F,Q,Face),!.

  private checkClassBody:(tipe,location,list[ast],list[env],list[canonDef],list[canonOther],list[canonDef],string,report,report){}.
  checkClassBody(ClassTp,Lc,Els,Env,Defs,Others,Types,BodyDefs,ClassPath,Rp,Rpx) :-
    getTypeFace(ClassTp,Env,Face),
    moveConstraints(Face,_,faceType(Fields)),
    declareVar("this",vr("this",Lc,ClassTp),pushScope(Env),ThEnv),
    thetaEnv(ClassPath,nullRepo,Lc,Els,Fields,ThEnv,_OEnv,Defs,Public,_Imports,Others,Rp,Rpx),
    computeExport(Defs,Fields,Public,BodyDefs,Types,[],[]).

  private checkCond:(ast,list[env],list[env],canonCond,report,report){}.
  checkCond(Term,Env,Env,trueCond,Rp,Rp) :-
    isIden(Term,Lc,"true").
  checkCond(Term,Env,Env,falseCond,Rp,Rp) :-
    isIden(Term,Lc,"false").
  checkCond(Term,Env,Ex,conjCond(Lhs,Rhs),Rp,Rpx) :-
    isBinary(Term,",",_,L,R),
    checkCond(L,Env,E1,Lhs,Rp,Rp0),
    checkCond(R,E1,Ex,Rhs,Rp0,Rpx).
  checkCond(Term,Env,Ex,condCond(Test,Either,Or),Rp,Rpx) :-
    isBinary(Term,"|",_,L,R),
    isBinary(L,"?",T,Th),
    checkCond(T,Env,E0,Test,Rp,Rp0),
    checkCond(Th,E0,E1,Either,Rp0,Rp1),
    checkCond(R,E1,Ex,Or,Rp1,Rpx).
  checkCond(Term,Env,Ex,disjCond(Either,Or),Rp,Rpx) :-
    isBinary(Term,"|",_,L,R),
    checkCond(L,Env,E1,Either,Rp,Rp0),
    checkCond(R,E1,Ex,Or,Rp0,Rpx).
  checkCond(Term,Env,Ex,oneCond(Test),Rp,Rpx) :-
    isUnary(Term,"!",_,N),
    checkCond(N,Env,Ex,Test,Rp,Rpx).
  checkCond(Term,Env,Env,negCond(Test),Rp,Rpx) :-
    isUnary(Term,"\\+",_,N),
    checkCond(N,Env,_,Test,Rp,Rpx).
  checkCond(Term,Env,Env,forallCond(Gen,Test),Rp,Rpx) :-
    isBinary(Term,"*>",_,L,R),
    checkCond(L,Env,E0,Gen,Rp,Rp0),
    checkCond(R,E0,_,Test,Rp0,Rpx).
  checkCond(Term,Env,Ex,Cond,Rp,Rpx) :-
    isRoundTuple(Term,_,C),
    checkConds(C,Env,Ex,Cond,Rp,Rpx).
  checkCond(Term,Env,Ev,negCond(unifyCond(Lhs,Rhs)),Rp,Rpx) :-
    isBinary(Term,"\\=",_,L,R),
    TV = newVar("_#"),
    typeOfTerm(L,TV,Env,E0,Lhs,Rp,Rp0),
    typeOfTerm(R,TV,E0,Ev,Rhs,Rp0,Rpx).
  checkCond(Term,Env,Ev,unifyCond(Lhs,Rhs),Rp,Rpx) :-
    isBinary(Term,"=",_,L,R),
    TV = newVar("_#"),
    typeOfTerm(L,TV,Env,E0,Lhs,Rp,Rp0),
    typeOfTerm(R,TV,E0,Ev,Rhs,Rp0,Rpx).
  checkCond(Term,Env,Ev,phraseCond(Lc,NT,Strm,Rest),Rp,Rpx) :-
    isBinary(Term,"%%",Lc,L,R),
    isBinary(R,"~",_,S,M),
    StrmTp = newVar("_S"),
    ElTp = newVar("_E"),
    checkGrammarType(Lc,Env,StrmTp,ElTp,Rp,Rp0),
    typeOfTerm(S,StrmTp,Env,E0,Strm,Rp0,Rp1),
    typeOfTerm(M,StrmTp,E0,E1,Rest,Rp1,Rp2),
    declareVar(streamVar,vr(Lc,v(streamVar),StrmTp),E1,E2),
    checkNonTerminals(L,StrmTp,E2,Ev,NT,Rp2,Rpx).
  checkCond(Term,Env,Ev,phraseCond(Lc,NT,Strm,Rest),Rp,Rpx) :-
    isBinary(Term,"%%",Lc,L,R),
    StrmTp = newVar("_S"),
    ElTp = newVar("_E"),
    checkGrammarType(Lc,Env,StrmTp,ElTp,Rp,Rp0),
    typeOfTerm(S,StrmTp,Env,E0,Strm,Rp0,Rp1),
    M = iden(Lc,_str_gen("_")),
    typeOfTerm(M,StrmTp,E0,E1,Rest,Rp1,Rp2),
    declareVar("stream_X",vr(Lc,v("stream_X"),StrmTp),E1,E2),
    checkNonTerminals(binary(Lc,",",L,iden(Lc,"eof")),StrmTp,E2,Ev,NT,Rp2,Rpx).
  checkCond(Term,Env,Ev,Call,Rp,Rpx) :-
    isRound(Term,Lc,F,A),
    PrTp = newVar("_P"),
    typeOfKnown(F,PrTp,Env,E0,Pred,Rp,Rp0),
    ( deRef(PrTp) = predType(ArgTp) ?
      typeOfTerm(A,ArgTp,E0,Ev,Arg,Rp0,Rpx),
      Call = goal(Lc,Pred,Arg) |
      Rpx=reportError("$(Pred)|=$(Tp) not a predicate",Lc,Rp0),
      Call = trueCond).
  checkCond(Term,Env,Env,trueCond,Rp,Rpx) :-
    Rpx=reportError("cannot understand condition $(Term)",Term.loc,Rp).

  private checkConds:(list[ast],list[env],list[env],list[canonCond],report,report){}.
  checkConds([],Env,Env,[],Rp,Rp).
  checkConds([C,..L],Ev,Env,[Co,..M],Rp,Rpx) :-
    checkCond(C,Ev,E0,Co,Rp,Rp0),
    checkConds(L,E0,Env,M,Rp0,Rpx).

  private typeOfTerm:(ast,tipe,list[env],list[env],canonTerm,report,report){}.
  typeOfTerm(V,_,Env,Env,v(_str_gen("_")),Rp,Rp) :- isIden(V,_,"_").
  typeOfTerm(V,Tp,Env,Ev,Term,Rp,Rpx) :-
    isIden(V,Lc,Nm),
    ( isVar(Nm,Env,Spec) ?
      typeOfVar(Lc,Spec,Tp,Env,Term,Rp,Rpx), Env=Ev |
      Ev = declareVar(Nm,vr(Lc,v(Nm),Tp),Env), Term=v(Nm), Rp=Rpx).
  typeOfTerm(intg(Lc,Ix),Tp,Env,Env,int(Ix),Rp,Rpx) :- 
    checkType(Lc,findType("integer",Lc,Env),Tp,Env,Rp,Rpx).
  typeOfTerm(flot(Lc,Dx),Tp,Env,Env,flt(Ix),Rp,Rpx) :- 
    checkType(Lc,findType("float",Lc,Env),Tp,Env,Rp,Rpx).
  typeOfTerm(strg(Lc,Sx),Tp,Env,Env,str(Sx),Rp,Rpx) :- 
    checkType(Lc,findType("string",Lc,Env),Tp,Env,Rp,Rpx).
  typeOfTerm(Term,Tp,Env,Ev,Exp) :-
    isBinary(Term,":",Lc,L,R),
    ( parseType(R,Env,RT) ?
        checkType(Lc,RT,Tp,Env),
        typeOfTerm(L,RT,Env,Ev,Exp) |
        reportError("cannot parse type $(R)",Lc),
        typeOfTerm(L,Tp,Env,Ev,Exp)).  
  typeOfTerm(Term,Tp,Env,Ev,Exp) :-
    isBinary(Term,"::",Lc,L,R),
    typeOfTerm(binary(Lc,":",unary(Lc,"_coerce",L),R),Tp,Env,Ev,Exp).
  typeOfTerm(P,Tp,Env,Ex,whre(Ptn,Cond)) :-
    isBinary(P,"@@",_,L,R),
    typeOfTerm(L,Tp,Env,E0,Ptn),
    checkCond(R,E0,Ex,Cond).
  typeOfTerm(Call,Tp,Env,Ev,whre(V,Cond)) :-
    isUnary(Call,"@",Lc,Test), -- @Test = NV @@ NV.Test where NV is a new name
    isRoundTerm(Test,_,_,_),
    NV = iden(Lc,_str_gen("_")),
    typeOfTerm(NV,Tp,Env,E0,V),
    checkCond(binary(Lc,".",NV,Test),E0,Ev,Cond).
  typeOfTerm(Term,Tp,Env,Ev,Exp) :-
    isBinary(Term,".",Lc,L,F),
    isIden(F,Fld),
    recordAccessExp(Lc,L,Fld,Tp,Env,Ev,Exp).
  typeOfTerm(Term,Tp,Env,Ev,conExp(Lc,Test,Then,Else)) :-
    isBinary(Term,"|",Lc,L,El),
    isBinary(L,"?",_,Tst,Th),
    checkCond(Tst,Env,E0,Test),
    typeOfTerm(Th,Tp,E0,E1,Then),
    typeOfTerm(El,Tp,E1,Ev,Else).
  typeOfTerm(Term,Tp,Env,Ev,Exp) :-
    isSquareTuple(Term,Lc,Els),
    typeExp(_,[ElTp]) = findType("list",Lc,Env),
    checkType(Lc,ListTp,Tp,Env),
    typeOfListTerm(Els,Lc,ElTp,ListTp,classType(tupleType([ElTp,ListTp]),Env,Ev,Exp).
  typeOfTerm(tuple(_,"()",[Inner]),Tp,Env,Ev,Exp) :-  -- a unary round tuple might just be parenthetic expression
    \+ isRoundTuple(Inner,_,_),
    typeOfTerm(Inner,Tp,Env,Ev,Exp).
  typeOfTerm(Term,Tp,Env,Ev,tpl(Els)) :-
    isRoundTuple(Term,Lc,A),
    genTpVars(A,ArgTps),
    checkType(Lc,tupleType(ArgTps),Tp,Env),
    typeOfTerms(A,ArgTps,Env,Ev,Lc,Els).
  typeOfTerm(Term,Tp,Env,Ev,dict(Lc,Entries)) :-
    isBraceTuple(Term,Lc,Els),
    MapTp = findType("map",Lc,Env),
    MapTp = typeExp(_,[KyTp,ElTp]),
    checkType(Lc,MapTp,Tp,Env),
    typeMapEntries(Els,KyTp,ElTp,Env,Ev,Entries).
  typeOfTerm(Term,Tp,Env,Env,Exp) :-
    isUnary(Term,"-",Lc,Arg),         -- handle unary minus
    typeOfTerm(binary(Lc,"-",name(Lc,"zero"),Arg),Tp,Env,Ev,Exp).
  typeOfTerm(Term,Tp,Env,Ev,Exp) :-
    isBinary(Term,"=>",Lc,Lhs,Rhs),
    isRoundTuple(Lhs,_,A),
    ArgTp = tupleType(mkTypes(length(A))),
    ResTp = newVar("_"),
    FunTp = funType(ArgTp,ResTp),
    checkType(Lc,FunTp,Tp,Env),
    E0 = pushScope(Env),
    typeOfTerm(Lhs,ArgTp,E0,E1,Arg),
    typeOfTerm(Rhs,ResTp,E1,E2,Res),
    Exp = lambda(equation(Lc,Arg,Res,trueCond)). -- Have to sort out free variables at some point
  typeOfTerm(Term,Tp,Env,Ev,Exp) :-
    isRound(Term,Lc,F,A),
    FnTp = newVar("F"),
    knownType(F,FnTp,Env,E0,Fun),
    typeOfCall(Lc,Fun,A,deRef(FnTp),Tp,E0,Ev,Exp).
  typeOfTerm(Term,Tp,Env,Ev,Exp) :-
    isSquareTerm(Term,Lc,F,[A]),
    typeOfTerm(binary(Lc,"find",F,A),Tp,Env,Ev,Exp).
  typeOfTerm(Term,Tp,Env,Env,v(_str_gen("_"))) :-
    reportError("illegal expression: $(Term), expecting a $(Tp)",Term.loc).

  private checkNonTerminals:(ast,tipe,tipe,list[env],list[env],canonNT){}.
  checkNonTerminals(Tpl,_,ElTp,E,Env,grTerms(Terms)) :-
    isSquareTuple(Tpl,_,Els),
    checkTerminals(Els,"_hdtl",Terms,ElTp,E,Env).
  checkNonTerminals(strg(Lc,Text),_,ElTp,Env,Env,grTerms(Lc,Terms)) :- !,
    checkTerminals(explodeStringLit(Lc,Text),"_hdtl",Terms,ElTp,Env,_).  -- strings are exploded into code points
  checkNonTerminals(Term,Tp,ElTp,Env,Ex,GrNT) :-
    isRoundTuple(Term,_,[NT]),
    checkNonTerminals(NT,Tp,ElTp,Env,Ex,GrNT).
  checkNonTerminals(Term,Tp,ElTp,Env,Ex,grConj(Lhs,Rhs)) :-
    isBinary(Term,",",Lc,L,R),
    checkNonTerminals(L,Tp,ElTp,Env,E1,Lhs),
    checkNonTerminals(R,Tp,ElTp,E1,Ex,Rhs).
  checkNonTerminals(Term,Tp,ElTp,Env,Ex,grCond(Test,Either,Or)) :-
    isBinary(Term,"|",_,L,R),
    isBinary(L,"?",_,T,Th),!,
    checkNonTerminals(T,Tp,ElTp,Env,E0,Test),
    checkNonTerminals(Th,Tp,ElTp,E0,E1,Either),
    checkNonTerminals(R,Tp,ElTp,E1,Ex,Or).
  checkNonTerminals(Term,Tp,ElTp,Env,Ex,grDisj(Either,Or)) :-
    isBinary(Term,"|",_,L,R),
    \+isBinary(L,"?",_,_,_),
    checkNonTerminals(L,Tp,ElTp,Env,E1,Either),
    checkNonTerminals(R,Tp,ElTp,E1,Ex,Or).
  checkNonTerminals(Term,Tp,ElTp,Env,Ex,grOne(Test)) :-
    isUnary(Term,"!",_,N),
    checkNonTerminals(N,Tp,ElTp,Env,Ex,Test).
  checkNonTerminals(Term,Tp,ElTp,Env,Env,grNeg(Test)) :-
    isUnary(Term,"\\+",Lc,N),
    checkNonTerminals(N,Tp,ElTp,Env,_,Test).
  checkNonTerminals(Term,Tp,ElTp,Env,Env,grAhed(Test)) :-
    isUnary(Term,"+",Lc,N),
    checkNonTerminals(N,Tp,ElTp,Env,_,Test).
  checkNonTerminals(Term,_,_,Env,Ev,grTest(unify(Lc,Lhs,Rhs))) :-
    isBinary(Term,"=",Lc,L,R),
    TV = newVar("_"),
    typeOfTerm(L,TV,Env,E0,Lhs),
    typeOfTerm(R,TV,E0,Ev,Rhs).
  checkNonTerminals(Term,_,_,Env,Ev,grTest(negCond(unify(Lc,Lhs,Rhs)))) :-
    isBinary(Term,"\\=",Lc,L,R),
    TV = newVar("_"),
    typeOfTerm(L,TV,Env,E0,Lhs),
    typeOfTerm(R,TV,E0,Ev,Rhs).
  checkNonTerminals(Term,Tp,_,Env,Ev,dip(v(Lc,NV),Cond)) :-
    isUnary(Term,"@",Lc,Test),
    isRoundTerm(Test,_,Op,Args),
    genstr("_",NV),
    declareVar(NV,vr(NV,Lc,Tp),Env,E0),
    binary(Lc,".",iden(Lc,NV),Op,NOp),
    checkCond(appl(Lc,NOp,tupl(Lc,"()",Args)),E0,Ev,Cond).
  checkNonTerminals(Term,Tp,_,Env,Ev,NT) :-
    isRound(Term,Lc,F,A),
    GrTp = newVar("_G"),
    typeOfKnown(F,GrTp,Env,E0,Op),
    ( deRef(GrTp) = grammarType(ArgTp,StrmTp) ?
      ( checkType(Lc,StrmTp,Tp,Env) ?
        typeOfTerm(A,ArgTp,E0,Ev,Arg),
        NT = grCall(Lc,Op,Arg) |
        reportError("type of $(Op) : $(GrTp) not consistent with stream type $(Tp)"),
        NT = grTerms([]), Ev = E0) |
      reportError("$(F) : $(GrTp) not a grammar"),
      NT = grTerms([]),
      Ev = Env).
  checkNonTerminals(Term,_,_,Env,Env,grTest(EOF)) :-
    isIden(Term,Lc,"eof"),
    checkCond(unary(Lc,"_eof",iden(Lc,streamVar)),Env,_,EOF).
  checkNonTerminals(Term,_,_,Env,Ex,grTest(Cond)) :-
    isBraceTuple(Term,Lc,Els),
    checkConds(Els,Env,Ex,Cond).

  private checkTerminals:(list[ast],string,list[canonNT],tipe,list[env],list[env]){}.
  checkTerminals([],_,[],_,Env,Env).
  checkTerminals([T,..L],V,[(Lc.loc,V,TT),..M],ElTp,Env,Ev) :-
    typeOfTerm(T,ElTp,Env,E0,TT),
    checkTerminals(L,V,M,ElTp,E0,Ev).



  collectPrograms:(list[canonRule],list[env],list[constraint],list[canonDef],list[canonDef]){}.
  collectPrograms([],_,_,Defs,Defs).
  collectPrograms([Eqn,..Stmts],Env,Cx,[function(Lc,Nm,Tp,Cx,[Eqn,..Eqns]),..Defs],Dx) :-
    Eqn = equation(Lc,Nm,_,_,_),
    collectEquations(Stmts,S0,Nm,Eqns),
    isVar(Nm,Env,vr(_,_,Tp)),
    collectPrograms(S0,Env,Cx,Defs,Dx).
  collectPrograms([Cl,..Stmts],Env,Cx,[predicate(Lc,Nm,Tp,Cx,[Cl,..Clses]),..Defs],Dx) :-
    Cl = clause(Lc,Nm,_,_,_),
    collectClauses(Stmts,S0,Nm,Clses),
    isVar(Nm,Env,vr(_,_,Tp)),
    collectPrograms(S0,Env,Cx,Defs,Dx).
  collectPrograms([defn(Lc,Nm,Cond,Value),..Stmts],Env,Cx,[defn(Lc,Nm,Cx,Cond,Tp,Value),..Defs],Dx) :-
    isVar(Nm,Env,vr(_,_,Tp)),
    collectPrograms(Stmts,Env,Cx,Defs,Dx).
  collectPrograms([Cl,..Stmts],Env,Cx,[enum(Lc,Nm,Tp,Cx,[Cl,..Rules],Face),..Defs],Dx) :-
    isRuleForEnum(Cl,Lc,Nm),!,
    collectEnumRules(Stmts,S0,Nm,Rules),
    isVar(Nm,Env,vr(_,_,Tp)),
    generateClassFace(Tp,Env,Face),
    collectPrograms(S0,Env,Cx,Defs,Dx).
  collectPrograms([Cl,..Stmts],Env,Cx,[class(Lc,Nm,Tp,Cx,[Cl,..Rules],Face),..Defs],Dx) :-
    isRuleForClass(Cl,Lc,Nm),!,
    collectClassRules(Stmts,S0,Nm,Rules),
    isVar(Nm,Env,vr(_,_,Tp)),
    generateClassFace(Tp,Env,Face),
    collectPrograms(S0,Env,Cx,Defs,Dx).
  collectPrograms([Rl,..Stmts],Env,Cx,[grammar(Lc,Nm,Tp,Cx,[Rl,..Rules]),..Defs],Dx) :-
    isGrammarRule(Rl,Lc,Nm),
    collectGrammarRules(Stmts,S0,Nm,Rules),
    isVar(Nm,Env,vr(_,_,Tp)),
    collectPrograms(S0,Env,Cx,Defs,Dx).

  collectClauses:(list[canonRule],list[canonRule],string,list[canonRule]){}.
  collectClauses([],[],_,[]).
  collectClauses([Cl,..Stmts],Sx,Nm,[Cl,..Ex]) :-
    Cl = clause(_,Nm,_,_,_),
    collectMoreClauses(Stmts,Sx,Nm,Ex).

  collectMoreClauses:(list[canonRule],list[canonRule],string,list[canonRule]){}.
  collectMoreClauses([Cl,..Stmts],Sx,Nm,[Cl,..Ex]) :-
    Cl = clause(_,Nm,_,_,_),
    collectMoreClauses(Stmts,Sx,Nm,Ex).
  collectMoreClauses([Rl,..Stmts],[Rl,..Sx],Nm,Eqns) :-
    \+Rl = clause(_,Nm,_,_,_),
    collectMoreClauses(Stmts,Sx,Nm,Eqns).
  collectMoreClauses([],[],_,[]).

  collectEquations:(list[canonRule],list[canonRule],string,list[canonRule]){}.
  collectEquations([Eqn,..Stmts],Sx,Nm,[Eqn,..Ex]) :-
    Eqn = equation(_,Nm,_,_,_),
    collectEquations(Stmts,Sx,Nm,Ex).
  collectEquations([Rl,..Stmts],[Rl,..Sx],Nm,Eqns) :-
    \+Rl=equation(_,Nm,_,_,_),
    collectEquations(Stmts,Sx,Nm,Eqns).
  collectEquations([],[],_,[]).

  collectGrammarRules:(list[canonRule],list[canonRule],string,list[canonRule]){}.
  collectGrammarRules([Rl,..Stmts],Sx,Nm,[Rl,..Ex]) :-
    isGrammarRule(Rl,_,Nm),
    collectGrammarRules(Stmts,Sx,Nm,Ex).
  collectGrammarRules([Rl,..Stmts],[Rl,..Sx],Nm,Eqns) :-
    collectGrammarRules(Stmts,Sx,Nm,Eqns).
  collectGrammarRules([],[],_,[]).

  isGrammarRule:(canonRule,location,string){}.
  isGrammarRule(grammarRule(Lc,Nm,_,_,_),Lc,Nm).

  collectClassRules:(list[canonRule],list[canonRule],string,list[canonRule]){}.
  collectClassRules([Cl,..Stmts],Sx,Nm,[Cl,..Ex]) :-
    isRuleForClass(Cl,_,Nm),
    collectClassRules(Stmts,Sx,Nm,Ex).
  collectClassRules([Rl,..Stmts],[Rl,..Sx],Nm,Eqns) :-
    collectClassRules(Stmts,Sx,Nm,Eqns).
  collectClassRules([],[],_,[]).

  isRuleForClass:(canonRule,location,string){}.
  isRuleForClass(labelRule(Lc,Nm,_,_,_),Lc,Nm).
  isRuleForClass(classBody(Lc,Nm,_,_,_,_),Lc,Nm).

  collectEnumRules:(list[canonRule],list[canonRule],string,list[canonRule]){}.
  collectEnumRules([Cl,..Stmts],Sx,Nm,[Cl,..Ex]) :-
    isRuleForEnum(Cl,_,Nm),
    collectEnumRules(Stmts,Sx,Nm,Ex).
  collectEnumRules([Rl|Stmts],[Rl|Sx],Nm,Eqns) :-
    \+isRuleForEnum(Rl,_,Nm),
    collectEnumRules(Stmts,Sx,Nm,Eqns).
  collectEnumRules([],[],_,[]).

  isRuleForEnum:(canonRule,location,string){}.
  isRuleForEnum(labelRule(Lc,Nm,enum(_,_),_,_),Lc,Nm).
  isRuleForEnum(classBody(Lc,Nm,enum(_,_),_,_,_),Lc,Nm).

  private explodeStringLit:(location,string) => list[ast].
  explodeStringLit(Lc,Str) => makeIntList(explode(Str),Lc).

  private makeIntList:(list[integer],location) => lisst[ast].
  makeIntList([],_) => [].
  makeIntList([Code,..L],Lc) => [intg(Lc,Code),..makeIntList(L,Lc)].

  private streamVar:string.
  streamVar = "stream_X".

  private typeOfVar:(location,vr,tipe,list[env],canonTerm){}.
  typeOfVar(Lc,vr(VLc,VNm,VT),Tp,Env,Term) :-
    manageConstraints(freshen(VT,pickupThisType(Env)),[],VNm,MTp,Term),
    checkType(Lc,MTp,Tp,Env).

  private manageConstraints:(tipe,list[constraint],canonTerm,tipe,canonTerm){}.
  manageConstraints(constrained(T,C),Cons,V,MTp,Exp) :-
    manageConstraints(T,[C,..Cons],V,MTp,Exp).
  manageConstraints(Tp,[],V,Tp,V).
  manageConstraints(Tp,Cons,V,Tp,over(V,Cons)).

  private knownType:(ast,tipe,list[env],list[env],canonTerm){}.
  knownType(V,Tp,Env,Env,Term) :-
    ( isIden(V,Lc,Nm) ?
      ( isVar(Nm,Env,Spec) ?
        typeOfVar(Lc,Spec,Tp,Env,Term), Env=Ev |
        reportError("variable $(V) not declared",Lc),
        Term=v(Nm)) |
      typeOfTerm(V,Tp,Env,Ex,Term)).

  private typeOfCall:(location,canonTerm,canonTerm,tipe,tipe,list[env],list[env],canonTerm){}.
  typeOfCall(Lc,Fun,A,funType(ArgTp,ResTp),Tp,Env,Ev,apply(Lc,Fun,Args)) :-
    checkType(Lc,ResTp,Tp,Env),
    typeOfTerm(A,ArgTp,Env,Ev,Args).
  typeOfCall(Lc,Fun,A,classType(ArgTp,ResTp),Tp,Env,Ev,apply(Lc,Fun,Args)) :-
    checkType(Lc,ResTp,Tp,Env),
    typeOfTerm(A,ArgTp,Env,Ev,Args).
  typeOfCall(Lc,Fun,_,Ftp,_,Env,Env,Fun) :-
    reportError("$(Fun) : $(Ftp) is not a function",Lc).

  private typeOfListTerm:(list[ast],location,tipe,tipe,tipe,list[env],list[env],canonTerm){}.
  typeOfListTerm([],Lc,_,ListTp,_,Env,Ev,Exp) :-
    typeOfTerm(iden(Lc,"[]"),ListTp,Env,Ev,Exp).
  typeOfListTerm([Last],_,ElTp,ListTp,ConTp,Env,Ev,apply(Op,[Hd,Tl])) :-
    isBinary(Last,",..",Lc,L,R),
    typeOfKnown(iden(Lc,",.."),ConTp,Env,E0,Op),
    typeOfTerm(L,ElTp,E0,E1,Hd),
    typeOfTerm(R,ListTp,E1,Ev,Tl).
  typeOfListTerm([El,..More],_,ElTp,ListTp,ConTp,Env,Ev,apply(Lc,Op,tpl([Hd,Tl]))) :-
    Lc = EL.loc,
    typeOfKnown(iden(Lc,",.."),ConTp,Env,E0,Op),
    typeOfTerm(El,ElTp,E0,E1,Hd),
    typeOfListTerm(More,Lc,ElTp,ListTp,ConTp,E1,Ev,Tl).

  private typeMapEntries:(list[ast],tipe,tipe,list[env],list[env],list[(string,canonTerm)]){}.
  typeMapEntries([],_,_,Env,Env,[]).
  typeMapEntries([En,..Els],KyTp,ElTp,Env,Ev,[(Ky,Vl),..Entries]) :-
    isBinary(En,"->",_,Lhs,Rhs),
    typeOfTerm(Lhs,KyTp,Env,E0,Ky),
    typeOfTerm(Rhs,ElTp,E0,E1,Vl),
    typeMapEntries(Els,KyTp,ElTp,E1,Ev,Entries).
  typeMapEntries([En,..Els],KyTp,ElTp,Env,Ev,Entries) :-
    reportError("invalid entry '$(En)' in map",En.loc),
    typeMapEntries(Els,KyTp,ElTp,Env,Ev,Entries).

  private checkType:(location,tipe,tipe,list[env],report,report){}.
  checkType(Lc,Actual,Expected,Env,Rp,Rpx) :-
    ( sameType(Actual,Expected,Env) ? Rp=Rpx | Rpx=reportError("$(Actual) not consistent with $(Expected)",Lc,Rp)).

  private checkGrammarType:(location,list[env],tipe,tipe,report,report){}.
  checkGrammarType(Lc,Env,Tp,ElTp,Rp,Rpx) :-
    isContract("stream",Env,conDef(_,_,Spec,_,_)),
    freshen(Spec,pickupThisType(Env)) = conTract(_,[Arg],[Dep]),
    checkType(Lc,Arg,Tp,Env,Rp,Rp0),
    checkType(Lc,Dep,ElTp,Env,Rp0,Rpx).

  private pickupThisType:(list[env]) => map[string,tipe].
  pickupThisType(Env) => { "this" -> ThisType} :- isVar("this",Env,vr(_,_,ThisType)).
  pickupThisType(_) => {}.

  private findType:(string,location,list[env]) => tipe.
  findType(Nm,_,Env) => freshen(T,pickupThisType(Env)) :-
    findType(Nm,Env,T).
  findType(Nm,Lc,_) => anonType :-
    reportError("type $(Nm) not known",Lc).

  private mkTypes:(integer) => list[tipe].
  mkTypes(0) => [].
  mkTypes(N) => [newVar("_"),..mkTypes(N-1)].

  private computeNewVars:(list[env]) => list[string].
  computeNewVars(Env) => keys(topVars(Env)).

  private pushFace:(list[(string,tipe)],location,list[env]) => list[env].
  pushFace([],_,E) => E.
  pushFace([(N,T),..L],Lc,E) => pushFace(L,Lc,declareVar(N,vr(Lc,v(N),T))).

  computeExport:(list[canonDef],list[(string,tipe)],list[(string,defnKind)],
                  list[canonDef],list[canonDef],list[canonDef],list[canonDef]){}.
  computeExport([],_,_,[],[],[],[]).
  computeExport([Def,..Defs],Fields,Public,Exports,Types,Contracts,Impls) :-
    exportDef(Def,Fields,Public,Exports,Ex,Types,Tx,Contracts,Cx,Impls,Ix)!,
    computeExport(Defs,Fields,Public,Ex,Tx,Cx,Ix).

  exportDef:(canonDef,list[(string,tipe)],list[(string,defnKind)],
          list[(string,tipe)],list[(string,tipe)],
          list[(string,tipe)],list[(string,tipe)],
          list[canonDef],list[canonDef],
          list[canonDef],list[canonDef]){}.
  exportDef(function(_,Nm,Tp,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(predicate(_,Nm,Tp,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(class(_,Nm,Tp,_,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(enum(_,Nm,Tp,_,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(typeDef(_,Nm,_,FaceRule),_,Public,Exports,Exports,[(Nm,FaceRule),..Tx],Tx,Cons,Cons,Impl,Impl) :-
    isPublicType(Nm,Public).
  exportDef(defn(_,Nm,_,Tp,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(grammar(_,Nm,Tp,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(Con,_,Public,Ex,Ex,Types,Types,[Con,..Cons],Cons,Impl,Impl) :-
    isPublicContract(Con,Public).
  exportDef(impl(_,INm,ImplName,_,Spec,_,_,_,_),_,Public,Ex,Ex,Tps,Tps,Cons,Cons,[imp(ImplName,Spec)|Ix],Ix) :-
    isPublicImplementation(INm,Public)!.
  exportDef(_,_,_,Ex,Ex,Tps,Tps,Cons,Cons,Impls,Impls).

  isPublicVar:(string,list[(string,tipe)],list[(string,defnKind)]){}.
  isPublicVar(Nm,_,Public) :-
    (Nm,valu) in Public.
  isPublicVar(Nm,Fields,_) :-
    (Nm,_) in Fields).

  isPublicType:(string,list[(string,defnKind)]){}.
  isPublicType(Nm,Public) :-
    (Nm,tpe) in Public.

  isPublicContract:(canonDef,list[(string,defnKind)]){}.
  isPublicContract(conDef(_,Nm,_,_),Public) :-
    (Nm,con) in Public.

  isPublicImplementation:(string,list[(string,defnKind)]){}.
  isPublicImplementation(Nm,Public) :-
    (Nm,impl) in Public.

  findImportedImplementations:(list[pkgSpec],list[implDef],list[implDef]){}.
  findImportedImplementations([pkgSpec(_,_,_,_,_,_,Impls,_),Specs],Impls<>D1,OverDict) :-
    findImportedImplementations(Specs,D1,OverDict).
  findImportedImplementations([],D,D).
}