lo.comp.typecheck{
  import lo.
  import lo.comp.location.
  import lo.comp.ast.
  import lo.comp.abstract.
  import lo.comp.wff.
  import lo.comp.keywords.
  import lo.comp.canon.
  import lo.comp.types.
  import lo.comp.parseType.
  import lo.comp.freshen.
  import lo.comp.unify.
  import lo.comp.dependencies.
  import lo.comp.dict.
  import lo.comp.errors.
  import lo.comp.macro.
  import lo.comp.package.
  import lo.comp.misc.
  import lo.uri.
  import lo.comp.repository.
  import lo.comp.imports.
  import lo.comp.resolve.

  public checkProgram:(ast,version,repository,report,report)=>canonPkg.
  checkProgram(Prog,V,Repo,Rp,Rpx) => canonPkg(pkgSpec(pkg(PkgNm,V),faceType(Exports),Types,Classes,Contracts,Impls,computeImports(Public,Imports)),Imports,ODefs,OOthers) :-
    isBraceTerm(Prog,Lc,Pk,Els),
    PkgNm = packageName(Pk),
    thetaEnv(PkgNm,Repo,Lc,Els,[],pushScope(stdDict),_,Defs,Public,Imports,Others,Rp,Rp0),
    findImportedImplementations(Imports,[],OverDict),
    overload(Defs,OverDict,ODict,ODefs,Rp0,Rp1),
    OOthers = overloadOthers(Others,ODict,Rp1,Rpx),
    computeExport(ODefs,[],Public,Exports,Types,Classes,Contracts,Impls).

  private computeImports:(list[(string,defnKind)],list[pkgSpec]) => list[(visibility,pkg)].
  computeImports(_,[])=>[].
  computeImports(Pub,[pkgSpec(pkg(Pk,V),_,_,_,_,_,_),..Pkgs]) => [(exportViz(Pk,imp,Pub),pkg(Pk,V)),..computeImports(Pub,Pkgs)].

  private thetaEnv:(string,repository,location,list[ast],list[(string,tipe)],list[env],list[env],
      list[canonDef],list[(string,defnKind)],list[pkgSpec],list[canonOther],report,report){}.
  thetaEnv(Path,Repo,Lc,Els,Fields,Base,TheEnv,Defs,Public,Imports,Others,Rp,Rpx) :-
    macroRewrite(Els,Stmts,Rp,Rp0),
    -- _logmsg("After rewrite: \(Stmts)"),
    dependencies(Stmts,Groups,Public,Annots,Imps,Otrs,Rp0,Rp1),
    processImportGroup(Imps,Imports,Lc,Repo,Base,IBase,Rp1,Rp2),
    checkGroups(Groups,Fields,Annots,Defs,pushFace(Fields,Lc,IBase),TheEnv,Path,Rp2,Rp3),
    checkOthers(Otrs,Others,TheEnv,Path,Rp3,Rpx).
    -- _logmsg("Checked defs: \(Defs)").

  private checkOthers:(list[ast],list[canonOther],list[env],string,report,report){}.
  checkOthers([],[],_,_,Rp,Rp).
  checkOthers([St,..Stmts],Ass,Env,Path,Rp,Rpx) :-
    checkOther(St,Ass,More,Env,Rp,Rp0)!,
    checkOthers(Stmts,More,Env,Path,Rp0,Rpx).
  checkOthers([St,..Stmts],Ass,Env,Path,Rp,Rpx) :-
    reportError("cannot understand statement: \(St)",St.loc,Rp,Rp0),
    checkOthers(Stmts,Ass,Env,Path,Rp0,Rpx).

  private checkOther:(ast,list[canonOther],list[canonOther],list[env],report,report){}.
  checkOther(St,[integrity(Lc,Cond),..More],More,Env,Rp,Rpx) :-
    isUnary(St,"assert",Lc,C),
    checkCond(C,Env,_,Cond,Rp,Rpx).
  checkOther(St,[expShow(Lc,Show),..More],More,Env,Rp,Rpx) :-
    isUnary(St,"show",Lc,E),  -- create the call formatSS(disp(E))
    typeOfTerm(unary(Lc,"formatSS",unary(Lc,"disp",E)),findType("string",Lc,Env,Rp,Rp0),Env,_,Show,Rp0,Rpx).

  processImportGroup:(list[ast],list[pkgSpec],location,repository,list[env],list[env],report,report){}.
  processImportGroup(Stmts,ImportSpecs,Lc,Repo,Env,Ex,Rp,Rpx) :-
    findAllImports(Stmts,Imports),
    importAll(Imports,Repo,[],AllImports,ImportSpecs,[],Rp,Rpx),
    importAllDefs(ImportSpecs,Lc,Repo,Env,Ex).

  findAllImports:(list[ast],list[(location,visibility,pkg)]){}.
  findAllImports([],[]).
  findAllImports([St,..More],[findImport(St,priVate),..Imports]) :-
    findAllImports(More,Imports).

  findImport:(ast,visibility)=>(location,visibility,pkg).
  findImport(St,_) => findImport(I,priVate) :-
    isUnary(St,"private",_,I).
  findImport(St,_) => findImport(I,pUblic):-
    isUnary(St,"public",Lc,I).
  findImport(St,Viz) => (Lc,Viz,pkgName(P)) :-
    isUnary(St,"import",Lc,P).

  importAll:(list[(location,visibility,pkg)],repository,list[(location,visibility,pkg)],list[(location,visibility,pkg)],list[pkgSpec],list[pkgSpec],report,report){}.
  importAll([],_,AllImports,AllImports,Specs,Specs,Rp,Rp).
  importAll([P,..L],Repo,SoFar,All,ImportSpecs,RestSpecs,Rp,Rpx) :-
    (alreadyImported(P,SoFar) ?
      importAll(L,Repo,SoFar,All,ImportSpecs,RestSpecs,Rp,Rpx) |
      importOne(Repo,P,SoFar,SoF,ImportSpecs,MoreSpecs,Rp,Rp0),
      importAll(L,Repo,SoF,All,MoreSpecs,RestSpecs,Rp0,Rpx)).

  alreadyImported:((location,visibility,pkg),list[(location,visibility,pkg)]){}.
  alreadyImported((_,_,Pk),SoFar) :-
    (_,_,Pk) in SoFar.

  importOne:(repository,(location,visibility,pkg),list[(location,visibility,pkg)],list[(location,visibility,pkg)],list[pkgSpec],list[pkgSpec],report,report){}.
  importOne(Repo,(Lc,Viz,Pkg),SoFar,All,[Spec,..More],Rest,Rp,Rpx) :-
    importPkg(Pkg,Repo,Spec,Rp,Rp0),
    Spec = pkgSpec(_,_,_,_,_,_,Imports),
    addPublicImports(Imports,Lc,Referenced),
    importAll(Referenced,Repo,[(Lc,Viz,Pkg),..SoFar],All,More,Rest,Rp0,Rpx).
  importOne(_,(Lc,_,Pkg),SoFar,SoFar,Specs,Specs,Rp,Rpx) :-
    reportError("could not import package \(Pkg)",Lc,Rp,Rpx).

  addPublicImports:(list[(visibility,pkg)],location,list[(location,visibility,pkg)]){}.
  addPublicImports([],_,[]).
  addPublicImports([(pUblic,Pkg),..I],Lc,[(Lc,pUblic,Pkg),..Rest]) :-
    addPublicImports(I,Lc,Rest).
  addPublicImports([(priVate,_),..I],Lc,Rest) :-
    addPublicImports(I,Lc,Rest).

  importAllDefs:(list[pkgSpec],location,repository,list[env],list[env]){}.
  importAllDefs([],_,_,Env,Env).
  importAllDefs([Spec,..Specs],Lc,Repo,Env,Ex) :-
    importDefs(Spec,Lc,Env,Ev0),
    importAllDefs(Specs,Lc,Repo,Ev0,Ex).

  importDefs:(pkgSpec,location,list[env],list[env]){}.
  importDefs(pkgSpec(_,faceType(Exported),Types,_,Cons,_,_),Lc,Env,Ex) :-
    Ex = importContracts(Cons,Lc,importTypes(Types,Lc,declareFields(Exported,Lc,Env))).

  declareFields:(list[(string,tipe)],location,list[env]) => list[env].
  declareFields([],_,Env) => Env.
  declareFields([(Nm,Tp),..More],Lc,Env) =>
    declareFields(More,Lc,declareVar(Nm,vr(Lc,v(Nm),Tp),Env)).

  importTypes:(list[(string,tipe)],location,list[env]) => list[env].
  importTypes([],_,Env)=>Env.
  importTypes([(Nm,Rule),..More],Lc,Env) => importTypes(More,Lc,declareType(Nm,tpDef(Lc,pickTypeTemplate(Rule),Rule),Env)).

  pickTypeTemplate:(tipe)=>tipe.
  pickTypeTemplate(univType(B,Tp)) => univType(B,pickTypeTemplate(Tp)).
  pickTypeTemplate(typeRule(Lhs,_)) => Lhs.

  importContracts:(list[conEntry],location,list[env])=>list[env].
  importContracts([],_,Env)=>Env.
  importContracts([C,..L],Lc,E)=>importContracts(L,Lc,E1) :-
    C = conEntry(Nm,_,_),
    defineContract(Nm,Lc,C,E,E1).

  private checkGroups:(list[list[defn]],list[(string,tipe)],list[(string,ast)],list[canonDef],list[env],list[env],string,report,report){}.
  checkGroups([],_,_,[],E,E,_,Rp,Rp).
  checkGroups([Gp,..More],Fields,Annots,Defs,Env,E,Path,Rp,Rpx) :-
    checkGroup(Gp,Gp,Fields,Annots,Defs,D0,Env,E0,Path,Rp,Rp0),
    checkGroups(More,Fields,Annots,D0,E0,E,Path,Rp0,Rpx).

  private checkGroup:(list[defn],list[defn],list[(string,tipe)],list[(string,ast)],list[canonDef],list[canonDef],list[env],list[env],string,report,report){}.
  checkGroup(Grp,[defn(_,tpe,_,_,_),.._],_,_,Defs,Dx,Env,Ex,Path,Rp,Rpx) :-
    typeGroup(Grp,Defs,Dx,Env,Ex,Path,Rp,Rpx).
  checkGroup(Grp,[defn(_,valu,_,_,_),.._],Fields,Annots,Defs,Dx,Env,Ex,Path,Rp,Rpx) :-
    varGroup(Grp,Fields,Annots,Defs,Dx,Env,Ex,Path,Rp,Rpx).
  checkGroup(Grp,[defn(_,con,_,_,_),.._],_,_,Defs,Dx,Env,Ex,Path,Rp,Rpx) :-
    contractGroup(Grp,Defs,Dx,Env,Ex,Path,Rp,Rpx).
  checkGroup(Grp,[defn(_,impl,_,_,_),.._],_,_,Defs,Dx,Env,Ex,Path,Rp,Rpx) :-
    implementationGroup(Grp,Defs,Dx,Env,Ex,Path,Rp,Rpx).

  -- This is very elaborate - to support mutual recursion amoung types.

  private typeGroup:(list[defn],list[canonDef],list[canonDef],list[env],list[env],string,report,report){}.
  typeGroup(Grp,Defs,Dx,Env,Ex,Path,Rp,Rpx) :-
    defineTypes(Grp,Env,TmpEnv,Path,Rp,Rp0),
    parseTypeDefs(Grp,TpDefs,[],TmpEnv,Path,Rp0,Rpx),
    declareTypes(TpDefs,Defs,Dx,Env,Ex).

  private defineTypes:(list[defn],list[env],list[env],string,report,report){}.
  defineTypes([],Env,Env,_,Rp,Rp).
  defineTypes([defn(N,tpe,Lc,_,[Stmt]),..More],Env,Ex,Path,Rp,Rpx) :-
    defineType(N,Lc,Stmt,Env,E0,Path,Rp,Rp0),
    defineTypes(More,E0,Ex,Path,Rp0,Rpx).
  defineTypes([defn(N,tpe,Lc,_,[_,.._]),..More],Env,Ex,Path,Rp,Rpx) :-
    reportError("multiple type definition statements for \(N)",Lc,Rp,Rp0),
    defineTypes(More,Env,Ex,Path,Rp0,Rpx).

  private defineType:(string,location,ast,list[env],list[env],string,report,report){}.
  defineType(N,Lc,St,Env,Ex,Path,Rp,Rpx) :-
    ( isType(N,Env,OLc,_) ?
        reportError("type \(N) already defined at \(OLc)",Lc,Rp,Rpx),
        Ex = Env |
        parseTypeTemplate(St,Env,Type,Path,Rp,Rpx),
        Ex = declareType(N,tpDef(Lc,Type,faceType([])),Env)).

  private parseTypeDefs:(list[defn],list[canonDef],list[canonDef],list[env],string,report,report){}.
  parseTypeDefs([],Defs,Defs,_,_,Rp,Rp).
  parseTypeDefs([defn(N,tpe,Lc,_,[Stmt]),..More],Defs,Dx,TmpEnv,Path,Rp,Rpx) :-
    parseTypeDefinition(N,Lc,Stmt,Defs,D0,TmpEnv,Path,Rp,Rp0),
    parseTypeDefs(More,D0,Dx,TmpEnv,Path,Rp0,Rpx).

  parseTypeDefinition:(string,location,ast,list[canonDef],list[canonDef],list[env],string,report,report){}.
  parseTypeDefinition(N,Lc,St,[typeDef(Lc,N,Type,FaceRule),..Defs],Defs,Env,Path,Rp,Rpx) :-
    isUnary(St,"type",_,InSt),
    parseTypeRule(InSt,[],Env,FaceRule,Path,Rp,Rpx),
    isType(N,Env,_,Type). -- pick up existing template

  private declareTypes:(list[canonDef],list[canonDef],list[canonDef],list[env],list[env]){}.
  declareTypes([],Defs,Defs,Env,Env).
  declareTypes([typeDef(Lc,N,Type,FaceRule),..More],[typeDef(Lc,N,Type,FaceRule),..Defs],Dx,Env,Ex) :-
    declareTypes(More,Defs,Dx,declareType(N,tpDef(Lc,Type,FaceRule),Env),Ex).

  private contractGroup:(list[defn],list[canonDef],list[canonDef],list[env],list[env],string,report,report){}.
  contractGroup([defn(N,con,Lc,_,[ConStmt]),.._],[cnDefn(Lc,N,Contract),..Defs],Defs,Env,Ex,Path,Rp,Rpx) :-
    parseContract(ConStmt,Env,Path,Contract,Rp,Rpx),
    defineContract(N,Lc,Contract,Env,Ex).

  private defineContract:(string,location,conEntry,list[env],list[env]){}.
  defineContract(N,Lc,conEntry(Nm,Spec,Face),E0,Ex) :-
    declareMethods(Spec,Face,Lc,declareContract(N,conEntry(Nm,Spec,Face),E0),Ex).

  private declareMethods:(constraint,tipe,location,list[env],list[env]){}.
  declareMethods(Spec,MtdsTp,Lc,Env,Ev) :-
    moveConQuants(Spec,Q,Con),
    moveQuants(MtdsTp,_,faceType(Methods)),
    formMethods(Methods,Lc,Q,Con,Env,Ev).

  private formMethods:(list[(string,tipe)],location,list[tipe],constraint,list[env],list[env]){}.
  formMethods([],_,_,_,Env,Env).
  formMethods([(Nm,Tp),..M],Lc,Q,Con,Env,Ev) :-
    moveQuants(Tp,FQ,QTp),
    moveQuants(MTp,merge(FQ,Q),constrained(QTp,Con)),
    formMethods(M,Lc,Q,Con,declareVar(Nm,vr(Lc,mtd(Lc,Nm),MTp),Env),Ev).

  -- handle program definitions
  private varGroup:(list[defn],list[(string,tipe)],list[(string,ast)],list[canonDef],list[canonDef],list[env],list[env],string,report,report){}.
  varGroup(Grp,Fields,Annots,Defs,Dx,Base,Env,Path,Rp,Rpx) :-
    parseAnnotations(Grp,Fields,Annots,Base,Env,Path,Rp,Rp0)!,
    checkVarRules(Grp,Env,Defs,Dx,Path,Rp0,Rpx).

  private parseAnnotations:(list[defn],list[(string,tipe)],list[(string,ast)],list[env],list[env],string,report,report){}.
  parseAnnotations([],_,_,Env,Env,_,Rp,Rp).
  parseAnnotations([defn(Nm,valu,_,_,_),..More],Fields,Annots,Env,Ex,Path,Rp,Rpx) :-
    ((Nm,Annot) in Annots)!,
    isBinary(Annot,":",Lc,_,T),
    parseType(T,Env,Tp,Rp,Rp0),
    parseAnnotations(More,Fields,Annots,declareVar(Nm,vr(Lc,v(Nm),Tp),Env),Ex,Path,Rp0,Rpx).
  parseAnnotations([defn(N,valu,Lc,_,_),..More],Fields,Annots,Env,Ex,Path,Rp,Rpx) :-
    ((N,Tp) in Fields)!,
    parseAnnotations(More,Fields,Annots,declareVar(N,vr(Lc,v(N),Tp),Env),Ex,Path,Rp,Rpx).
  parseAnnotations([defn(N,valu,Lc,_,_),..More],Fields,Annots,Env,Ex,Path,Rp,Rpx) :-
    reportError("no type annotation for variable \(N)",Lc,Rp,Rp0),
    parseAnnotations(More,Fields,Annots,Env,Ex,Path,Rp0,Rpx).

  private checkVarRules:(list[defn],list[env],list[canonDef],list[canonDef],string,report,report){}.
  checkVarRules([],_,Defs,Defs,_,Rp,Rp).
  checkVarRules([defn(N,valu,Lc,_,Stmts),..More],Env,Defs,Dx,Path,Rp,Rpx) :-
    -- _logmsg("checking var rules \(Stmts)"),
    (Q,PT) = skolemize(pickupVarType(N,Lc,Env,Rp,Rp0),pickupThisType(Env)),
    declareTypeVars(pairs(Q),Lc,Env,SEnv),
    moveConstraints(PT,Cx,ProgramType),
    declareConstraints(Cx,SEnv,StmtEnv),
    processStmts(Stmts,ProgramType,Rules,[],StmtEnv,Path,Rp0,Rp1),
    collectPrograms(Rules,Env,Cx,Defs,D0),
    checkVarRules(More,Env,D0,Dx,Path,Rp1,Rpx).

  private pickupVarType:(string,location,list[env],report,report) => tipe.
  pickupVarType(N,_,Env,Rp,Rp)=>Tp :-
    isVar(N,Env,vr(_,_,Tp)).
  pickupVarType(N,Lc,_,Rp,Rpx) => newVar("_") :- 
    reportError("\(N) not declared",Lc,Rp,Rpx).

  private declareTypeVars:(list[(string,tipe)],location,list[env],list[env]){}.
  declareTypeVars([],_,Env,Env).
  declareTypeVars([("this",_),..Vars],Lc,Env,Ex) :- 
    declareTypeVars(Vars,Lc,Env,Ex).
  declareTypeVars([(Nm,Tp),..Vars],Lc,Env,Ex) :-
    declareTypeVars(Vars,Lc,declareTypeExists(Nm,Lc,Tp,Env),Ex).

  private declareConstraints:(list[constraint],list[env],list[env]){}.
  declareConstraints([],Env,Env).
  declareConstraints([C,..L],E,Ex) :-
    declareConstraints(L,declareConstraint(C,E),Ex).

  private processStmts:(list[ast],tipe,list[canonRule],list[canonRule],list[env],string,report,report){}.
  processStmts([],_,Defs,Defs,_,_,Rp,Rp).
  processStmts([St,..More],ProgramType,Defs,Dx,Env,Path,Rp,Rpx) :-
    processStmt(St,ProgramType,Defs,D0,Env,Path,Rp,Rp0)!,
    processStmts(More,ProgramType,D0,Dx,Env,Path,Rp0,Rpx).

  private processStmt:(ast,tipe,list[canonRule],list[canonRule],list[env],string,report,report){}.
  processStmt(St,ProgramType,Defs,Defx,E,_,Rp,Rpx) :-
    isBinary(St,"=>",Lc,L,R),
    checkEquation(Lc,L,iden(Lc,"true"),R,ProgramType,Defs,Defx,E,Rp,Rpx).
  processStmt(St,ProgramType,Defs,Defx,E,_,Rp,Rpx) :-
    isBinary(St,":-",Lc,L,G),
    isBinary(L,"=>",_,H,R),
    checkEquation(Lc,H,G,R,ProgramType,Defs,Defx,E,Rp,Rpx).
  processStmt(St,ProgramType,Defs,Defx,E,Pth,Rp,Rpx) :-
    isBinary(St,":-",Lc,L,G),
    isBinary(L,"<=",_,H,R),
    checkClassRule(Lc,H,G,R,ProgramType,Defs,Defx,E,Pth,Rp,Rpx).
  processStmt(St,predType(AT),[clause(Lc,Nm,Args,Body),..Defs],Defs,E,_,Rp,Rpx) :-
    isBinary(St,":-",Lc,L,R),
    splitHead(L,_,Nm,A),
    typeOfArg(A,AT,pushScope(E),E0,Args,Rp,Rp0),
    checkCond(R,E0,_,Body,Rp0,Rpx).
  processStmt(St,predType(AT),[clause(Lc,Nm,Args,trueCond),..Defs],Defs,E,_,Rp,Rpx) :-
    splitHead(St,Lc,Nm,A),
    typeOfArg(A,AT,pushScope(E),E0,Args,Rp,Rpx).
  processStmt(St,Tp,Defs,Dx,Env,_,Rp,Rpx) :-
    isBinary(St,"=",Lc,L,R),
    checkDefn(Lc,L,iden(Lc,"true"),R,Tp,Defs,Dx,Env,Rp,Rpx).
  processStmt(St,ProgramType,Defs,Defx,E,Pth,Rp,Rpx) :-
    isBinary(St,"<=",Lc,H,R),
    checkClassRule(Lc,H,iden(Lc,"true"),R,ProgramType,Defs,Defx,E,Pth,Rp,Rpx).
  processStmt(St,Tp,[clRule(Lc,Nm,XNm,tpl([]),theta(Stmts,Others),trueCond,faceType(Types)),..Defs],Defs,E,Path,Rp,Rpx) :-
    isBraceTerm(St,Lc,L,Els),
    isIden(L,_,Nm),
    XNm = subPath(Path,marker(clss),Nm),
    checkClassBody(Tp,Lc,Els,pushScope(E),Stmts,Others,Types,XNm,Rp,Rpx).
  processStmt(St,classType(AT,Tp),[clRule(Lc,Nm,XNm,Arg,theta(Stmts,Others),trueCond,faceType(Types)),..Defs],Defs,E,Path,Rp,Rpx) :-
    isBraceTerm(St,Lc,L,Els),
    splitHead(L,_,Nm,A),
    typeOfArg(A,AT,pushScope(E),E1,Arg,Rp,Rp0),
    XNm = subPath(Path,marker(clss),Nm),
    checkClassBody(Tp,Lc,Els,E1,Stmts,Others,Types,XNm,Rp0,Rpx).
  processStmt(St,Tp,Defs,Dx,E,Path,Rp,Rpx) :-
    isBinary(St,"-->",Lc,L,R),
    checkGrammarRule(Lc,L,R,Tp,Defs,Dx,E,Path,Rp,Rpx).
  processStmt(St,Tp,Defs,Defs,_,_,Rp,Rpx) :-
    reportError("Statement \(St) not consistent with expected type \(Tp)",St.loc,Rp,Rpx).

  private splitHead:(ast,location,string,ast){}.
  splitHead(T,Lc,Nm,A) :- isRound(T,Lc,N,A), isIden(N,_,Nm).
  splitHead(T,Lc,Nm,roundTuple(Lc,[])) :- isIden(T,Lc,Nm).

  private checkEquation:(location,ast,ast,ast,tipe,list[canonRule],list[canonRule],list[env],report,report){}.
  checkEquation(Lc,H,G,R,funType(AT,RT),[equation(Lc,Nm,Args,Exp,Cond),..Defs],Defs,E,Rp,Rpx) :-
    splitHead(H,_,Nm,A),
    typeOfArg(A,AT,pushScope(E),E0,Args,Rp,Rp0),
    checkCond(G,E0,E1,Cond,Rp0,Rp1),
    typeOfTerm(R,RT,E1,_,Exp,Rp1,Rpx).
  checkEquation(Lc,_,_,_,ProgramType,Defs,Defs,_,Rp,Rpx) :-
    reportError("equation not consistent with expected type: \(ProgramType)",Lc,Rp,Rpx).

  private checkDefn:(location,ast,ast,ast,tipe,list[canonRule],list[canonRule],list[env],report,report){}
  checkDefn(Lc,L,C,R,Tp,[vrDef(Lc,Nm,Value,Cond),..Dx],Dx,E,Rp,Rpx) :-
    isIden(L,_,Nm),
    checkCond(C,pushScope(E),E1,Cond,Rp,Rp0),
    typeOfTerm(R,Tp,E1,_,Value,Rp0,Rpx).

  private checkGrammarRule:(location,ast,ast,tipe,list[canonRule],list[canonRule],list[env],string,report,report){}.
  checkGrammarRule(Lc,L,R,grammarType(AT,Tp),[grRule(Lc,Nm,Args,grTerms(PB),Body),..Defs],Defs,E,_,Rp,Rpx) :-
    splitGrHead(L,Nm,A,P),
    ElTp=newVar("_E"),
    typeOfArg(A,AT,declareVar("stream\$X",vr(Lc,v("stream\$X"),Tp),pushScope(E)),E2,Args,Rp,Rp0),
    checkNonTerminal(R,Tp,ElTp,E2,E3,Body,Rp0,Rp1),
    checkTerminals(P,"_cons",PB,ElTp,E3,_,Rp1,Rpx).

  private splitGrHead:(ast,string,ast,list[ast]){}.
  splitGrHead(Term,Nm,Args,Hed) :-
    isBinary(Term,",",_,L,R),
    isSquareTuple(R,_,Hed),
    splitHead(L,_,Nm,Args).
  splitGrHead(Term,Nm,Args,Hed) :-
    isRoundTuple(Term,_,[T]),
    splitGrHead(T,Nm,Args,Hed).
  splitGrHead(Term,Nm,Args,[]) :-
    splitHead(Term,_,Nm,Args).

  private checkClassRule:(location,ast,ast,ast,tipe,list[canonRule],list[canonRule],list[env],string,report,report){}.
  checkClassRule(Lc,H,G,R,classType(AT,_),[clRule(Lc,Nm,XNm,Arg,Repl,Cond,SuperFace),..Defs],Defs,E,Pth,Rp,Rpx) :-
    splitHead(H,_,Nm,A),
    typeOfArg(A,AT,pushScope(E),E1,Arg,Rp,Rp0),
    SuperTp = newVar("S"),
    checkCond(G,E1,E2,Cond,Rp0,Rp1),
    typeOfTerm(R,SuperTp,E2,_,Repl,Rp1,Rpx),
    XNm = subPath(Pth,marker(clss),Nm),
    faceOfType(SuperTp,Env,SuperFace).
    generateClassFace(SuperTp,E1,SuperFace).

  private generateClassFace:(tipe,list[env],tipe){}.
  generateClassFace(Tp,Env,Face) :-
    (Q,Plate) = skolemize(Tp,[]),
    (Plate = classType(_,T) | T=Plate),
    faceOfType(deRef(T),Env,F),
    freezeType(F,Q,Face).

  private checkClassBody:(tipe,location,list[ast],list[env],list[canonDef],list[canonOther],list[(string,tipe)],string,report,report){}.
  checkClassBody(ClassTp,Lc,Els,Env,Defs,Others,Types,ClassPath,Rp,Rpx) :-
    faceOfType(deRef(ClassTp),Env,Face),
    moveConstraints(Face,_,faceType(Fields)),
    thetaEnv(ClassPath,nullRepo,Lc,Els,Fields,declareVar("this",vr(Lc,v("this"),ClassTp),pushScope(Env)),_OEnv,Defs,Public,_Imports,Others,Rp,Rpx),
    computeExport(Defs,Fields,Public,_,Types,_,[],[]).

  private implementationGroup:(list[defn],list[canonDef],list[canonDef],list[env],list[env],string,report,report){}.
  implementationGroup([defn(INm,impl,_,_,[Stmt])],[Impl,..Defs],Defs,Env,Ex,Path,Rp,Rpx) :-
    isUnary(Stmt,"implementation",Lc,I),
    isBinary(I,"..",_,Sq,Body),
    isBraceTuple(Body,_,Els),
    parseContractConstraint(Sq,Env,Nm,Spec,Rp,Rp0),
    isContract(Nm,Env,conEntry(CNm,FullSpec,ConFace)),
    -- We have to unify the implemented contract and the contract (spec)ification
    moveConQuants(FullSpec,_,conTract(ConNm,OArgs,ODeps)),
    moveConQuants(Spec,_,ASpec),
    moveConConstraints(ASpec,AC,conTract(ConNm,AArgs,ADeps)),
    sameLength(OArgs,AArgs,Lc,Rp0,Rp1),
    sameLength(ODeps,ADeps,Lc,Rp1,Rp2),
    -- match up the type variables of the original contract with the actual implemented contract
    QQ = bindAT(ODeps,ADeps,bindAT(OArgs,AArgs,[])),
    moveQuants(ConFace,_,CFace),
    (_,Face) = freshen(CFace,QQ),
    implementationName(conTract(CNm,AArgs,ADeps)) = ImplName,
    checkClassBody(Face,Lc,Els,Env,ThDefs,Others,Types,ImplName,Rp0,Rpx),
    Impl = implDef(Lc,INm,ImplName,Spec,AC,tpl([]),theta(ThDefs,Others)),
    Ex=declareImplementation(Nm,ImplName,implEntry(ImplName,Spec),Env).
  implementationGroup([defn(INm,impl,Lc,_,Stmt)],Defs,Defs,Env,E,Path,Rp,Rpx) :-
    reportError("could not check implementation statement \(Stmt)",Lc,Rp,Rpx).

  private checkCond:(ast,list[env],list[env],canonCond,report,report){}.
  checkCond(Term,Env,Env,trueCond,Rp,Rp) :-
    isIden(Term,Lc,"true").
  checkCond(Term,Env,Env,falseCond,Rp,Rp) :-
    isIden(Term,Lc,"false").
  checkCond(Term,Env,Ex,conjCond(Lhs,Rhs),Rp,Rpx) :-
    isBinary(Term,",",_,L,R),
    checkCond(L,Env,E1,Lhs,Rp,Rp0),
    checkCond(R,E1,Ex,Rhs,Rp0,Rpx).
  checkCond(Term,Env,Ex,condCond(Test,Either,Or),Rp,Rpx) :-
    isBinary(Term,"|",_,L,R),
    isBinary(L,"?",_,T,Th),
    checkCond(T,Env,E0,Test,Rp,Rp0),
    checkCond(Th,E0,E1,Either,Rp0,Rp1),
    checkCond(R,E1,Ex,Or,Rp1,Rpx).
  checkCond(Term,Env,Ex,disjCond(Either,Or),Rp,Rpx) :-
    isBinary(Term,"|",_,L,R),
    checkCond(L,Env,E1,Either,Rp,Rp0),
    checkCond(R,E1,Ex,Or,Rp0,Rpx).
  checkCond(Term,Env,Ex,oneCond(Test),Rp,Rpx) :-
    isUnary(Term,"!",_,N),
    checkCond(N,Env,Ex,Test,Rp,Rpx).
  checkCond(Term,Env,Env,negCond(Test),Rp,Rpx) :-
    isUnary(Term,"\\+",_,N),
    checkCond(N,Env,_,Test,Rp,Rpx).
  checkCond(Term,Env,Env,forallCond(Gen,Test),Rp,Rpx) :-
    isBinary(Term,"*>",_,L,R),
    checkCond(L,Env,E0,Gen,Rp,Rp0),
    checkCond(R,E0,_,Test,Rp0,Rpx).
  checkCond(Term,Env,Ex,Cond,Rp,Rpx) :-
    isRoundTuple(Term,_,C),
    checkConds(C,Env,Ex,Cond,Rp,Rpx).
  checkCond(Term,Env,Ev,negCond(unifyCond(Lhs,Rhs)),Rp,Rpx) :-
    isBinary(Term,"\\=",_,L,R),
    TV = newVar("_#"),
    typeOfTerm(L,TV,Env,E0,Lhs,Rp,Rp0),
    typeOfTerm(R,TV,E0,Ev,Rhs,Rp0,Rpx).
  checkCond(Term,Env,Ev,unifyCond(Lhs,Rhs),Rp,Rpx) :-
    isBinary(Term,"=",_,L,R),
    TV = newVar("_#"),
    typeOfTerm(L,TV,Env,E0,Lhs,Rp,Rp0),
    typeOfTerm(R,TV,E0,Ev,Rhs,Rp0,Rpx).
  checkCond(Term,Env,Ev,phraseCond(Lc,NT,Strm,Rest),Rp,Rpx) :-
    isBinary(Term,"%%",Lc,L,R),
    isBinary(R,"~",_,S,M),
    StrmTp = newVar("_S"),
    ElTp = newVar("_E"),
    checkGrammarType(Lc,Env,StrmTp,ElTp,Rp,Rp0),
    typeOfTerm(S,StrmTp,Env,E0,Strm,Rp0,Rp1),
    typeOfTerm(M,StrmTp,E0,E1,Rest,Rp1,Rp2),
    checkNonTerminal(L,StrmTp,ElTp,declareVar(streamVar,vr(Lc,v(streamVar),StrmTp),E1),Ev,NT,Rp2,Rpx).
  checkCond(Term,Env,Ev,phraseCond(Lc,NT,Strm,Rest),Rp,Rpx) :-
    isBinary(Term,"%%",Lc,L,R),
    StrmTp = newVar("_S"),
    ElTp = newVar("_E"),
    checkGrammarType(Lc,Env,StrmTp,ElTp,Rp,Rp0),
    typeOfTerm(S,StrmTp,Env,E0,Strm,Rp0,Rp1),
    M = iden(Lc,_str_gen("_")),
    typeOfTerm(M,StrmTp,E0,E1,Rest,Rp1,Rp2),
    checkNonTerminal(binary(Lc,",",L,iden(Lc,"eof")),StrmTp,ElTp,declareVar("stream_X",vr(Lc,v("stream_X"),StrmTp),E1),Ev,NT,Rp2,Rpx).
  checkCond(Term,Env,Ev,Call,Rp,Rpx) :-
    isRound(Term,Lc,F,A),
    PrTp = newVar("_P"),
    knownType(F,PrTp,Env,E0,Pred,Rp,Rp0),
    ( deRef(PrTp) = predType(ArgTp) ?
      typeOfArg(A,ArgTp,E0,Ev,Arg,Rp0,Rpx),
      Call = callCond(Lc,Pred,Arg) |
      reportError("\(Pred)|=\(PrTp) not a predicate",Lc,Rp0,Rpx),
      Call = trueCond).
  checkCond(Term,Env,Ev,isTrue(Exp),Rp,Rpx) :-
    knownType(Term,findType("logical",Lc,Env,Rp,Rp0),Env,Ev,Exp,Rp0,Rpx).

  private checkConds:(list[ast],list[env],list[env],canonCond,report,report){}.
  checkConds([],Env,Env,trueCond,Rp,Rp).
  checkConds([C],Ev,Env,Cond,Rp,Rpx) :-
    checkCond(C,Ev,Env,Cond,Rp,Rpx).
  checkConds([C,..L],Ev,Env,conjCond(C0,Cm),Rp,Rpx) :-
    checkCond(C,Ev,E0,Co,Rp,Rp0),
    checkConds(L,E0,Env,Cm,Rp0,Rpx).

  private typeOfArg:(ast,tipe,list[env],list[env],canonTerm,report,report){}.
  typeOfArg(Term,Tp,Env,Ev,Exp,Rp,Rpx) :-
    ( isRoundTuple(Term,Lc,A) ?
      ArgTps = genTpVars(A),
      checkType(Lc,tupleType(ArgTps),Tp,Env,Rp,Rp0),
      typeOfTerms(A,ArgTps,Env,Ev,Lc,Els,Rp0,Rpx),
      Exp = tpl(Els) |
      typeOfTerm(Term,Tp,Env,Ev,Exp,Rp,Rpx)).

  private typeOfTerm:(ast,tipe,list[env],list[env],canonTerm,report,report){}.
  typeOfTerm(V,_,Env,Env,v(_str_gen("_")),Rp,Rp) :- isIden(V,_,"_").
  typeOfTerm(V,Tp,Env,Ev,Term,Rp,Rpx) :-
    isIden(V,Lc,Nm),
    ( isKeyword(Nm) ?
      reportError("unexpected keyword: \(Nm)",Lc,Rp,Rpx),
      Term = v(_str_gen("_")) |
      isVar(Nm,Env,Spec) ?
      typeOfVar(Lc,Spec,Tp,Env,Term,Rp,Rpx), Env=Ev |
      Ev = declareVar(Nm,vr(Lc,v(Nm),Tp),Env), Term=v(Nm), Rp=Rpx).
  typeOfTerm(intg(Lc,Ix),Tp,Env,Env,int(Ix),Rp,Rpx) :- 
    checkType(Lc,findType("integer",Lc,Env,Rp,Rp0),Tp,Env,Rp0,Rpx).
  typeOfTerm(flot(Lc,Dx),Tp,Env,Env,flt(Dx),Rp,Rpx) :- 
    checkType(Lc,findType("float",Lc,Env,Rp,Rp0),Tp,Env,Rp0,Rpx).
  typeOfTerm(strg(Lc,Sx),Tp,Env,Env,str(Sx),Rp,Rpx) :- 
    checkType(Lc,findType("string",Lc,Env,Rp,Rp0),Tp,Env,Rp0,Rpx).
  typeOfTerm(Term,Tp,Env,Ev,Exp,Rp,Rpx) :-
    isBinary(Term,":",Lc,L,R),
    ( parseType(R,Env,RT,Rp,Rp0) ?
        checkType(Lc,RT,Tp,Env,Rp0,Rp1),
        typeOfTerm(L,RT,Env,Ev,Exp,Rp1,Rpx) |
        reportError("cannot parse type \(R)",Lc,Rp0,Rp1),
        typeOfTerm(L,Tp,Env,Ev,Exp,Rp1,Rpx)).  
  typeOfTerm(Term,Tp,Env,Ev,Exp,Rp,Rpx) :-
    isBinary(Term,"::",Lc,L,R),
    typeOfTerm(binary(Lc,":",unary(Lc,"_coerce",L),R),Tp,Env,Ev,Exp,Rp,Rpx).
  typeOfTerm(P,Tp,Env,Ex,whre(Ptn,Cond),Rp,Rpx) :-
    isBinary(P,"@@",_,L,R),
    typeOfTerm(L,Tp,Env,E0,Ptn,Rp,Rp0),
    checkCond(R,E0,Ex,Cond,Rp0,Rpx).
  typeOfTerm(Call,Tp,Env,Ev,whre(V,Cond),Rp,Rpx) :-
    isUnary(Call,"@",Lc,Test), -- @Test = NV @@ NV.Test where NV is a new name
    isRoundTerm(Test,_,_,_),
    NV = iden(Lc,_str_gen("_")),
    typeOfTerm(NV,Tp,Env,E0,V,Rp,Rp0),
    checkCond(binary(Lc,".",NV,Test),E0,Ev,Cond,Rp0,Rpx).
  typeOfTerm(Term,Tp,Env,Ev,Exp,Rp,Rpx) :-
    isBinary(Term,".",Lc,L,F),
    isIden(F,_,Fld),
    recordAccessExp(Lc,L,Fld,Tp,Env,Ev,Exp,Rp,Rpx).
  typeOfTerm(Term,Tp,Env,Ev,condExp(Test,Then,Else),Rp,Rpx) :-
    isBinary(Term,"|",Lc,L,El),
    isBinary(L,"?",_,Tst,Th),
    checkCond(Tst,Env,E0,Test,Rp,Rp0),
    typeOfTerm(Th,Tp,E0,E1,Then,Rp0,Rp1),
    typeOfTerm(El,Tp,E1,Ev,Else,Rp1,Rpx).
  typeOfTerm(Term,Tp,Env,Ev,Exp,Rp,Rpx) :-
    isSquareTuple(Term,Lc,Els),
    checkSquareTuple(Lc,Els,Tp,Env,Ev,Exp,Rp,Rpx).
  typeOfTerm(tupl(_,"()",[Inner]),Tp,Env,Ev,Exp,Rp,Rpx) :-  -- a unary round tuple might just be parenthetic expression
    \+ isRoundTuple(Inner,_,_),
    typeOfTerm(Inner,Tp,Env,Ev,Exp,Rp,Rpx).
  typeOfTerm(Term,Tp,Env,Ev,tpl(Els),Rp,Rpx) :-
    isRoundTuple(Term,Lc,A),
    ArgTps = genTpVars(A),
    checkType(Lc,tupleType(ArgTps),Tp,Env,Rp,Rp0),
    typeOfTerms(A,ArgTps,Env,Ev,Lc,Els,Rp0,Rpx).
  typeOfTerm(Term,Tp,Env,Env,Exp,Rp,Rpx) :-
    isUnary(Term,"-",Lc,Arg),         -- handle unary minus
    typeOfTerm(binary(Lc,"-",iden(Lc,"zero"),Arg),Tp,Env,Ev,Exp,Rp,Rpx).
  typeOfTerm(Term,Tp,Env,Ev,Exp,Rp,Rpx) :-
    isBinary(Term,"=>",Lc,Lhs,Rhs),
    isRoundTuple(Lhs,_,A),
    ArgTp = tupleType(mkTypes(length(A))),
    ResTp = newVar("_"),
    FunTp = funType(ArgTp,ResTp),
    checkType(Lc,FunTp,Tp,Env,Rp,Rp0),
    typeOfTerm(Lhs,ArgTp,pushScope(Env),E1,Arg,Rp0,Rp1),
    typeOfTerm(Rhs,ResTp,E1,E2,Res,Rp1,Rpx),
    Exp = lambda(equation(Lc,_str_gen("L"),Arg,Res,trueCond)). -- Have to sort out free variables at some point
  typeOfTerm(Term,Tp,Env,Ev,Exp,Rp,Rpx) :-
    isRound(Term,Lc,F,A),
    FnTp = newVar("F"),
    knownType(F,FnTp,Env,E0,Fun,Rp,Rp0),
    typeOfCall(Lc,Fun,A,deRef(FnTp),Tp,E0,Ev,Exp,Rp0,Rpx).
  typeOfTerm(Term,Tp,Env,Ev,Exp,Rp,Rpx) :-
    isSquareTerm(Term,Lc,F,[A]),
    typeOfIndex(Lc,F,A,Tp,Env,Ev,Exp,Rp,Rpx).
  typeOfTerm(Term,Tp,Env,Env,theta(Defs,Others),Rp,Rpx) :-
    isBraceTuple(Term,Lc,Els),
    checkClassBody(Tp,Lc,Els,Env,Defs,Others,Types,_str_gen("theta"),Rp,Rpx).
  typeOfTerm(Term,Tp,Env,Env,v(_str_gen("_")),Rp,Rpx) :-
    reportError("illegal expression: \(Term), expecting a \(Tp)",Term.loc,Rp,Rpx).

  typeOfTerms:(list[ast],list[tipe],list[env],list[env],location,list[canonTerm],report,report){}.
  typeOfTerms([],[],Env,Env,_,[],Rp,Rp).
  typeOfTerms([],[T,.._],Env,Env,Lc,[],Rp,Rpx) :-
    reportError("insufficient arguments, expecting a \(T)",Lc,Rp,Rpx).
  typeOfTerms([A,.._],[],Env,Env,_,[],Rp,Rpx) :-
    reportError("too many arguments: \(A)",A.loc,Rp,Rpx).
  typeOfTerms([A,..As],[ElTp,..ElTypes],Env,Ev,_,[Term,..Els],Rp,Rpx) :-
    typeOfTerm(A,ElTp,Env,E0,Term,Rp,Rp0),
    typeOfTerms(As,ElTypes,E0,Ev,A.loc,Els,Rp0,Rpx).

  typeOfIndex:(location,ast,ast,tipe,list[env],list[env],canonTerm,report,report){}.
  typeOfIndex(Lc,Mp,Arg,Tp,Env,Ev,Exp,Rp,Rpx) :-
    isBinary(Arg,"->",_,Ky,Vl),
    typeOfTerm(ternary(Lc,"_put",Mp,Ky,Vl),Tp,Env,Ev,Exp,Rp,Rpx).
  typeOfIndex(Lc,Mp,Arg,Tp,Env,Ev,Exp,Rp,Rpx) :-
    isUnary(Arg,"\\+",_,Ky),
    typeOfTerm(binary(Lc,"_remove",Mp,Ky),Tp,Env,Ev,Exp,Rp,Rpx).
  typeOfIndex(Lc,Mp,Arg,Tp,Env,Ev,Exp,Rp,Rpx) :-
    typeOfTerm(binary(Lc,"find",Mp,Arg),Tp,Env,Ev,Exp,Rp,Rpx).

  -- Analyse a list term to try to disambiguate maps from lists.

  private checkSquareTuple:(location,list[ast],tipe,list[env],list[env],canonTerm,report,report){}.
  checkSquareTuple(Lc,Els,Tp,Env,Ev,Exp,Rp,Rpx) :-
    ((isMapSequence(Els) | isMapType(Tp,Lc,Env)) ?
      checkType(Lc,findType("map",Lc,Env,Rp,Rp1),Tp,Env,Rp1,Rp2),
      typeOfTerm(macroMapEntries(Lc,Els,Rp2,Rp3),Tp,Env,Ev,Exp,Rp3,Rpx)|
    (isListSequence(Els) | isListType(Tp,Lc,Env)) ?
      ListTp = findType("list",Lc,Env,Rp,Rp1),
      ListTp = typeExp(_,[ElTp]),
      checkType(Lc,ListTp,Tp,Env,Rp1,Rp2),
      typeOfListTerm(Els,Lc,ElTp,ListTp,Env,Ev,Exp,Rp2,Rpx)|
    checkSequenceTerm(Lc,Els,Tp,Env,Ev,Exp,Rp,Rpx)).

  private isMapSequence:(list[ast]){}.
  isMapSequence(Els) :-
    E in Els,
    isBinary(E,"->",_,_,_).

  private isMapType:(tipe,location,list[env]){}.
  isMapType(Tp,Lc,Env) :-
    isType("map",Env,_,T),
    moveQuants(T,_,typeExp(MpOp,_)),
    typeExp(MpOp,_) = deRef(Tp).
 
  -- Looks for ,.. at end, and no -> in the elements
  private isListSequence:(list[ast]){}.
  isListSequence([E,.._]) :-
    \+ isBinary(E,"->",_,_,_).

  private isListType:(tipe,location,list[env]){}.
  isListType(Tp,Lc,Env) :-
    isType("map",Env,_,T),
    moveQuants(T,_,typeExp(MpOp,_)),
    typeExp(MpOp,_) = deRef(Tp).

  private typeOfListTerm:(list[ast],location,tipe,tipe,list[env],list[env],canonTerm,report,report){}.
  typeOfListTerm([],Lc,_,ListTp,Env,Ev,Exp,Rp,Rpx) :-
    typeOfTerm(iden(Lc,"[]"),ListTp,Env,Ev,Exp,Rp,Rpx).
  typeOfListTerm([Last],_,ElTp,ListTp,Env,Ev,apply(Lc,Op,tpl([Hd,Tl])),Rp,Rpx) :-
    isBinary(Last,",..",Lc,L,R),
    knownType(iden(Lc,",.."),newVar("_"),Env,E0,Op,Rp,Rp0),
    typeOfTerm(L,ElTp,E0,E1,Hd,Rp0,Rp1),
    typeOfTerm(R,ListTp,E1,Ev,Tl,Rp1,Rpx).
  typeOfListTerm([El,..More],_,ElTp,ListTp,Env,Ev,apply(Lc,Op,tpl([Hd,Tl])),Rp,Rpx) :-
    Lc = El.loc,
    knownType(iden(Lc,",.."),newVar("_"),Env,E0,Op,Rp,Rp0),
    typeOfTerm(El,ElTp,E0,E1,Hd,Rp0,Rp1),
    typeOfListTerm(More,Lc,ElTp,ListTp,E1,Ev,Tl,Rp1,Rpx).

  private checkSequenceTerm:(location,list[ast],tipe,list[env],list[env],canonTerm,report,report){}.
  checkSequenceTerm(Lc,Els,Tp,Env,Ev,Exp,Rp,Rpx) :-
    Seq = genIden(Lc),
    macroSequenceTerm(Els,Lc,Seq,Tsts),
    typeOfTerm(binary(Lc,"@@",Seq,roundTuple(Lc,Tsts)),Tp,Env,Ev,Exp,Rp,Rpx).

  private macroSequenceTerm:(list[ast],location,ast,list[ast]){}.
  macroSequenceTerm([],Lc,V,[unary(Lc,"_eof",V)]).
  macroSequenceTerm([E,..L],_,V,[ternary(E.loc,"_hdtl",V,E,NX),..M]) :-
    NX = genIden(Lc),
    macroSequenceTerm(L,Lc,NX,M).

  macroMapEntries:(location,list[ast],report,report) => ast.
  macroMapEntries(Lc,[],Rp,Rp) => iden(Lc,"_empty").
  macroMapEntries(_,[E,..L],Rp,Rpx) => roundTerm(Lc,iden(Lc,"_put"),[macroMapEntries(Lc,L,Rp,Rpx),Ky,Vl]) :-
    isBinary(E,"->",Lc,Ky,Vl).
  macroMapEntries(Lc,[E,..L],Rp,Rpx) => macroMapEntries(Lc,L,Rp0,Rpx) :-
    reportError("invalid entry in map \(E)",E.loc,Rp,Rp0).

  recordAccessExp:(location,ast,string,tipe,list[env],list[env],canonTerm,report,report){}.
  recordAccessExp(Lc,Rc,Fld,ET,Env,Ev,dot(Rec,Fld),Rp,Rpx) :-
    AT = newVar("_R"),
    knownType(Rc,AT,Env,Ev,Rec,Rp,Rp0),
    faceOfType(deRef(AT),Env,Face),
    moveConstraints(Face,_,faceType(Fields)),
    fieldInFace(Fields,AT,Fld,Lc,FTp,Rp0,Rp1)!,
    (_,Tp) = freshen(FTp,[]), -- the record is this to the right of dot.
    checkType(Lc,Tp,ET,Env,Rp1,Rpx).

  fieldInFace:(list[(string,tipe)],tipe,string,location,tipe,report,report){}.
  fieldInFace(Fields,_,Nm,_,Tp,Rp,Rp) :-
    (Nm,Tp) in Fields!.
  fieldInFace(_,Tp,Nm,Lc,anonType,Rp,Rpx) :-
    reportError("field \(Nm) not declared in \(Tp)",Lc,Rp,Rpx).

  private genTpVars:(list[ast])=>list[tipe].
  genTpVars([])=>[].
  genTpVars([_,..I]) => [newVar("__"),..genTpVars(I)].

  private checkNonTerminal:(ast,tipe,tipe,list[env],list[env],canonNT,report,report){}.
  checkNonTerminal(Tpl,_,ElTp,E,Env,grTerms(Terms),Rp,Rpx) :-
    isSquareTuple(Tpl,_,Els),
    checkTerminals(Els,"_hdtl",Terms,ElTp,E,Env,Rp,Rpx).
  checkNonTerminal(strg(Lc,Text),_,ElTp,Env,Env,grTerms(Terms),Rp,Rpx) :-
    checkTerminals(explodeStringLit(Lc,Text),"_hdtl",Terms,ElTp,Env,_,Rp,Rpx).  -- strings are exploded into code points
  checkNonTerminal(Term,Tp,ElTp,Env,Ex,GrNT,Rp,Rpx) :-
    isRoundTuple(Term,Lc,Els),
    checkNonTerminals(Els,Tp,ElTp,Env,Ex,GrNT,Rp,Rpx)!.
  checkNonTerminal(Term,Tp,ElTp,Env,Ex,grConj(Lhs,Rhs),Rp,Rpx) :-
    isBinary(Term,",",Lc,L,R),
    checkNonTerminal(L,Tp,ElTp,Env,E1,Lhs,Rp,Rp0),
    checkNonTerminal(R,Tp,ElTp,E1,Ex,Rhs,Rp0,Rpx).
  checkNonTerminal(Term,Tp,ElTp,Env,Ex,grCond(Test,Either,Or),Rp,Rpx) :-
    isBinary(Term,"|",_,L,R),
    isBinary(L,"?",_,T,Th),
    checkNonTerminal(T,Tp,ElTp,Env,E0,Test,Rp,Rp0),
    checkNonTerminal(Th,Tp,ElTp,E0,E1,Either,Rp0,Rp1),
    checkNonTerminal(R,Tp,ElTp,E1,Ex,Or,Rp1,Rpx).
  checkNonTerminal(Term,Tp,ElTp,Env,Ex,grDisj(Either,Or),Rp,Rpx) :-
    isBinary(Term,"|",_,L,R),
    \+isBinary(L,"?",_,_,_),
    checkNonTerminal(L,Tp,ElTp,Env,E1,Either,Rp,Rp0),
    checkNonTerminal(R,Tp,ElTp,E1,Ex,Or,Rp0,Rpx).
  checkNonTerminal(Term,Tp,ElTp,Env,Ex,grOne(Test),Rp,Rpx) :-
    isUnary(Term,"!",_,N),
    checkNonTerminal(N,Tp,ElTp,Env,Ex,Test,Rp,Rpx).
  checkNonTerminal(Term,Tp,ElTp,Env,Env,grNeg(Test),Rp,Rpx) :-
    isUnary(Term,"\\+",Lc,N),
    checkNonTerminal(N,Tp,ElTp,Env,_,Test,Rp,Rpx).
  checkNonTerminal(Term,Tp,ElTp,Env,Env,grAhed(Test),Rp,Rpx) :-
    isUnary(Term,"+",Lc,N),
    checkNonTerminal(N,Tp,ElTp,Env,_,Test,Rp,Rpx).
  checkNonTerminal(Term,_,_,Env,Ev,grTest(unifyCond(Lhs,Rhs)),Rp,Rpx) :-
    isBinary(Term,"=",Lc,L,R),
    TV = newVar("_"),
    typeOfTerm(L,TV,Env,E0,Lhs,Rp,Rp0),
    typeOfTerm(R,TV,E0,Ev,Rhs,Rp0,Rpx).
  checkNonTerminal(Term,_,_,Env,Ev,grTest(negCond(unifyCond(Lhs,Rhs))),Rp,Rpx) :-
    isBinary(Term,"\\=",Lc,L,R),
    TV = newVar("_"),
    typeOfTerm(L,TV,Env,E0,Lhs,Rp,Rp0),
    typeOfTerm(R,TV,E0,Ev,Rhs,Rp0,Rpx).
  checkNonTerminal(Term,Tp,_,Env,Ev,grDip(v(NV),Cond),Rp,Rpx) :-
    isUnary(Term,"@",Lc,Test),
    isRoundTerm(Test,_,Op,Args),
    NV = _str_gen("_"),
    checkCond(appl(Lc,binary(Lc,".",iden(Lc,NV),Op),tupl(Lc,"()",Args)),declareVar(NV,vr(Lc,v(NV),Tp),Env),Ev,Cond,Rp,Rpx).
  checkNonTerminal(Term,Tp,_,Env,Ev,NT,Rp,Rpx) :-
    isRound(Term,Lc,F,A),
    GrTp = newVar("_G"),
    knownType(F,GrTp,Env,E0,Op,Rp,Rp0),
    ( deRef(GrTp) = grammarType(ArgTp,StrmTp) ?
      ( checkType(Lc,StrmTp,Tp,Env,Rp0,Rp1) ?
        typeOfTerm(A,ArgTp,E0,Ev,Arg,Rp1,Rpx),
        NT = grCall(Lc,Op,Arg) |
        reportError("type of \(Op) : \(GrTp) not consistent with stream type \(Tp)",Lc,Rp0,Rpx),
        NT = grTerms([]), Ev = E0) |
      reportError("\(F) : \(GrTp) not a grammar",Lc,Rp0,Rpx),
      NT = grTerms([]),
      Ev = Env).
  checkNonTerminal(Term,_,_,Env,Env,grTest(EOF),Rp,Rpx) :-
    isIden(Term,Lc,"eof"),
    checkCond(unary(Lc,"_eof",iden(Lc,streamVar)),Env,_,EOF,Rp,Rpx).
  checkNonTerminal(Term,_,_,Env,Ex,grTest(Cond),Rp,Rpx) :-
    isBraceTuple(Term,Lc,Els),
    checkConds(Els,Env,Ex,Cond,Rp,Rpx).

  private checkNonTerminals:(list[ast],tipe,tipe,list[env],list[env],canonNT,report,report){}.
  checkNonTerminals([],_,_,Env,Env,grTest(trueCond),Rp,Rp).
  checkNonTerminals([N,..Els],Tp,ElTp,Env,Ev,grConj(Lhs,Rhs),Rp,Rpx) :-
    checkNonTerminal(N,Tp,ElTp,Env,E0,Lhs,Rp,Rp0),
    checkNonTerminals(Els,Tp,ElTp,E0,Ex,Rhs,Rp0,Rpx).

  private checkTerminals:(list[ast],string,list[(location,string,canonTerm)],tipe,list[env],list[env],report,report){}.
  checkTerminals([],_,[],_,Env,Env,Rp,Rp).
  checkTerminals([T,..L],V,[(T.loc,V,TT),..M],ElTp,Env,Ev,Rp,Rpx) :-
    typeOfTerm(T,ElTp,Env,E0,TT,Rp,Rp0),
    checkTerminals(L,V,M,ElTp,E0,Ev,Rp0,Rpx).

  collectPrograms:(list[canonRule],list[env],list[constraint],list[canonDef],list[canonDef]){}.
  collectPrograms([],_,_,Defs,Defs).
  collectPrograms([Eqn,..Stmts],Env,Cx,[funDef(Lc,Nm,Tp,Cx,[Eqn,..Eqns]),..Defs],Dx) :-
    Eqn = equation(Lc,Nm,_,_,_),
    collectEquations(Stmts,S0,Nm,Eqns),
    isVar(Nm,Env,vr(_,_,Tp)),
    collectPrograms(S0,Env,Cx,Defs,Dx).
  collectPrograms([Cl,..Stmts],Env,Cx,[relDef(Lc,Nm,Tp,Cx,[Cl,..Clses]),..Defs],Dx) :-
    Cl = clause(Lc,Nm,_,_),
    collectClauses(Stmts,S0,Nm,Clses),
    isVar(Nm,Env,vr(_,_,Tp)),
    collectPrograms(S0,Env,Cx,Defs,Dx).
  collectPrograms([vrDef(Lc,Nm,Value,Cond),..Stmts],Env,Cx,[varDef(Lc,Nm,Tp,Cx,Value,Cond),..Defs],Dx) :-
    isVar(Nm,Env,vr(_,_,Tp)),
    collectPrograms(Stmts,Env,Cx,Defs,Dx).
  collectPrograms([Cl,..Stmts],Env,Cx,[classDef(Lc,Nm,XNm,Tp,Cx,[Cl,..Rules]),..Defs],Dx) :-
    isRuleForClass(Cl,Lc,Nm,XNm),
    collectClassRules(Stmts,S0,Nm,Rules),
    isVar(Nm,Env,vr(_,_,Tp)),
    collectPrograms(S0,Env,Cx,Defs,Dx).
  collectPrograms([Rl,..Stmts],Env,Cx,[grammDef(Lc,Nm,Tp,Cx,[Rl,..Rules]),..Defs],Dx) :-
    isGrammarRule(Rl,Lc,Nm),
    collectGrammarRules(Stmts,S0,Nm,Rules),
    isVar(Nm,Env,vr(_,_,Tp)),
    collectPrograms(S0,Env,Cx,Defs,Dx).

  collectClauses:(list[canonRule],list[canonRule],string,list[canonRule]){}.
  collectClauses([],[],_,[]).
  collectClauses([Cl,..Stmts],Sx,Nm,[Cl,..Ex]) :-
    Cl = clause(_,Nm,_,_),
    collectMoreClauses(Stmts,Sx,Nm,Ex).

  collectMoreClauses:(list[canonRule],list[canonRule],string,list[canonRule]){}.
  collectMoreClauses([Cl,..Stmts],Sx,Nm,[Cl,..Ex]) :-
    Cl = clause(_,Nm,_,_),
    collectMoreClauses(Stmts,Sx,Nm,Ex).
  collectMoreClauses([Rl,..Stmts],[Rl,..Sx],Nm,Eqns) :-
    \+Rl = clause(_,Nm,_,_),
    collectMoreClauses(Stmts,Sx,Nm,Eqns).
  collectMoreClauses([],[],_,[]).

  collectEquations:(list[canonRule],list[canonRule],string,list[canonRule]){}.
  collectEquations([Eqn,..Stmts],Sx,Nm,[Eqn,..Ex]) :-
    Eqn = equation(_,Nm,_,_,_),
    collectEquations(Stmts,Sx,Nm,Ex).
  collectEquations([Rl,..Stmts],[Rl,..Sx],Nm,Eqns) :-
    \+Rl=equation(_,Nm,_,_,_),
    collectEquations(Stmts,Sx,Nm,Eqns).
  collectEquations([],[],_,[]).

  collectGrammarRules:(list[canonRule],list[canonRule],string,list[canonRule]){}.
  collectGrammarRules([Rl,..Stmts],Sx,Nm,[Rl,..Ex]) :-
    isGrammarRule(Rl,_,Nm),
    collectGrammarRules(Stmts,Sx,Nm,Ex).
  collectGrammarRules([Rl,..Stmts],[Rl,..Sx],Nm,Eqns) :-
    collectGrammarRules(Stmts,Sx,Nm,Eqns).
  collectGrammarRules([],[],_,[]).

  isGrammarRule:(canonRule,location,string){}.
  isGrammarRule(grRule(Lc,Nm,_,_,_),Lc,Nm).

  collectClassRules:(list[canonRule],list[canonRule],string,list[canonRule]){}.
  collectClassRules([Cl,..Stmts],Sx,Nm,[Cl,..Ex]) :-
    isRuleForClass(Cl,_,Nm,_),
    collectClassRules(Stmts,Sx,Nm,Ex).
  collectClassRules([Rl,..Stmts],[Rl,..Sx],Nm,Eqns) :-
    collectClassRules(Stmts,Sx,Nm,Eqns).
  collectClassRules([],[],_,[]).

  isRuleForClass:(canonRule,location,string,string){}.
  isRuleForClass(clRule(Lc,Nm,XNm,_,_,_,_),Lc,Nm,XNm).

  private explodeStringLit:(location,string) => list[ast].
  explodeStringLit(Lc,Str) => makeIntList(explode(Str),Lc).

  private makeIntList:(list[integer],location) => list[ast].
  makeIntList([],_) => [].
  makeIntList([Code,..L],Lc) => [intg(Lc,Code),..makeIntList(L,Lc)].

  private streamVar:string.
  streamVar = "stream_X".

  private typeOfVar:(location,vr,tipe,list[env],canonTerm,report,report){}.
  typeOfVar(Lc,vr(VLc,VNm,VT),Tp,Env,Term,Rp,Rpx) :-
    (_,FTp) = freshen(VT,pickupThisType(Env)),
    manageConstraints(FTp,[],Lc,VNm,MTp,Term),
    checkType(Lc,MTp,Tp,Env,Rp,Rpx).

  private manageConstraints:(tipe,list[constraint],location,canonTerm,tipe,canonTerm){}.
  manageConstraints(constrained(T,C),Cons,Lc,V,MTp,Exp) :-
    manageConstraints(T,[C,..Cons],Lc,V,MTp,Exp).
  manageConstraints(Tp,[],_,V,Tp,V).
  manageConstraints(Tp,Cons,Lc,V,Tp,over(Lc,V,reverse(Cons))).

  private knownType:(ast,tipe,list[env],list[env],canonTerm,report,report){}.
  knownType(V,Tp,Env,Env,Term,Rp,Rpx) :-
    ( isIden(V,Lc,Nm) ?
      ( isVar(Nm,Env,Spec) ?
        typeOfVar(Lc,Spec,Tp,Env,Term,Rp,Rpx), Env=Ev |
        reportError("variable \(V) not declared",Lc,Rp,Rpx),
        Term=v(Nm)) |
      typeOfTerm(V,Tp,Env,Ex,Term,Rp,Rpx)).

  private typeOfCall:(location,canonTerm,ast,tipe,tipe,list[env],list[env],canonTerm,report,report){}.
  typeOfCall(Lc,Fun,A,funType(ArgTp,ResTp),Tp,Env,Ev,apply(Lc,Fun,Args),Rp,Rpx) :-
    checkType(Lc,ResTp,Tp,Env,Rp,Rp0),
    typeOfArg(A,ArgTp,Env,Ev,Args,Rp0,Rpx).
  typeOfCall(Lc,Fun,A,classType(ArgTp,ResTp),Tp,Env,Ev,apply(Lc,Fun,Args),Rp,Rpx) :-
    checkType(Lc,ResTp,Tp,Env,Rp,Rp0),
    typeOfArg(A,ArgTp,Env,Ev,Args,Rp0,Rpx).
  typeOfCall(Lc,Fun,_,Ftp,_,Env,Env,Fun,Rp,Rpx) :-
    reportError("\(Fun) : \(Ftp) is not a function",Lc,Rp,Rpx).

  private checkType:(location,tipe,tipe,list[env],report,report){}.
  checkType(Lc,Actual,Expected,Env,Rp,Rpx) :-
    ( sameType(Actual,Expected,Env) ? Rp=Rpx | reportError("\(Actual) not consistent with \(Expected)",Lc,Rp,Rpx)).

  private checkGrammarType:(location,list[env],tipe,tipe,report,report){}.
  checkGrammarType(Lc,Env,Tp,ElTp,Rp,Rpx) :-
    isContract("stream",Env,conEntry(_,Spec,_)),
    (_,conTract(_,[Arg],[Dep])) = freshen(Spec,pickupThisType(Env)),
    checkType(Lc,Arg,Tp,Env,Rp,Rp0),
    checkType(Lc,Dep,ElTp,Env,Rp0,Rpx).

  private pickupThisType:(list[env]) => map[string,tipe].
  pickupThisType(Env) => [ "this" -> ThisType] :- isVar("this",Env,vr(_,_,ThisType)).
  pickupThisType(_) => [].

  private findType:(string,location,list[env],report,report) => tipe.
  findType(Nm,_,Env,Rp,Rp) => FTp :-
    isType(Nm,Env,_,T),
    (_,FTp) = freshen(T,pickupThisType(Env)).
  findType(Nm,Lc,_,Rp,Rpx) => anonType :-
    reportError("type \(Nm) not known",Lc,Rp,Rpx).

  private mkTypes:(integer) => list[tipe].
  mkTypes(0) => [].
  mkTypes(N) => [newVar("_"),..mkTypes(N-1)].

  private computeNewVars:(list[env]) => list[string].
  computeNewVars(Env) => keys(topVars(Env)).

  private pushFace:(list[(string,tipe)],location,list[env]) => list[env].
  pushFace([],_,E) => E.
  pushFace([(N,T),..L],Lc,E) => pushFace(L,Lc,declareVar(N,vr(Lc,v(N),T),E)).

  computeExport:(list[canonDef],list[(string,tipe)],list[(string,defnKind)],
                  list[(string,tipe)],list[(string,tipe)],list[(string,string,tipe)],list[conEntry],list[implEntry]){}.
  computeExport([],_,_,[],[],[],[],[]).
  computeExport([Def,..Defs],Fields,Public,Exports,Types,Classes,Contracts,Impls) :-
    exportDef(Def,Fields,Public,Exports,Ex,Types,Tx,Classes,Clx,Contracts,Cx,Impls,Ix)!,
    computeExport(Defs,Fields,Public,Ex,Tx,Clx,Cx,Ix).

  exportDef:(canonDef,list[(string,tipe)],list[(string,defnKind)],
          list[(string,tipe)],list[(string,tipe)],
          list[(string,tipe)],list[(string,tipe)],
          list[(string,string,tipe)],list[(string,string,tipe)],
          list[conEntry],list[conEntry],
          list[implEntry],list[implEntry]){}.
  exportDef(funDef(_,Nm,Tp,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Classes,Classes,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(relDef(_,Nm,Tp,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Classes,Classes,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(classDef(_,Nm,XNm,Tp,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,[(Nm,XNm,Tp),..Clx],Clx,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(typeDef(_,Nm,_,FaceRule),_,Public,Exports,Exports,[(Nm,FaceRule),..Tx],Tx,Classes,Classes,Cons,Cons,Impl,Impl) :-
    isPublicType(Nm,Public).
  exportDef(varDef(_,Nm,Tp,_,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Classes,Classes,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(grammDef(_,Nm,Tp,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Classes,Classes,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(cnDefn(_,Nm,Contract),_,Public,Ex,Ex,Types,Types,Classes,Classes,[Contract,..Cons],Cons,Impl,Impl) :-
    (Nm,con) in Public.
  exportDef(implDef(_,INm,ImplName,Spec,_,_,_),_,Public,Ex,Ex,Tps,Tps,Classes,Classes,Cons,Cons,[implEntry(ImplName,Spec),..Ix],Ix) :-
    isPublicImplementation(INm,Public)!.
  exportDef(_,_,_,Ex,Ex,Tps,Tps,Classes,Classes,Cons,Cons,Impls,Impls).

  exportViz:(string,defnKind,list[(string,defnKind)]) => visibility.
  exportViz(Nm,K,P) => pUblic :- (Nm,K) in P.
  exportViz(_,_,_) => priVate.

  isPublicVar:(string,list[(string,tipe)],list[(string,defnKind)]){}.
  isPublicVar(Nm,_,Public) :-
    (Nm,valu) in Public.
  isPublicVar(Nm,Fields,_) :-
    (Nm,_) in Fields.

  isPublicType:(string,list[(string,defnKind)]){}.
  isPublicType(Nm,Public) :-
    (Nm,tpe) in Public.

  isPublicImplementation:(string,list[(string,defnKind)]){}.
  isPublicImplementation(Nm,Public) :-
    (Nm,impl) in Public.

  findImportedImplementations:(list[pkgSpec],list[implEntry],list[implEntry]){}.
  findImportedImplementations([pkgSpec(_,_,_,_,_,Impls,_),..Specs],D0,D1) :-
    findImportedImplementations(Specs,Impls<>D0,D1).
  findImportedImplementations([],D,D).
}