lo.comp.typecheck{
  import lo.
  import lo.comp.location.
  import lo.comp.ast.
  import lo.comp.abstract.
  import lo.comp.wff.
  import lo.comp.canon.
  import lo.comp.types.
  import lo.comp.parseType.
  import lo.comp.freshen.
  import lo.comp.unify.
  import lo.comp.dependencies.
  import lo.comp.dict.
  import lo.comp.errors.
  import lo.comp.macro.
  import lo.comp.repository.


  private thetaEnv:(string,repository,location,list[ast],list[(string,tipe)],list[env],list[env],
      list[canonDef],list[(string,defnKind)],list[(visibility,uri,version)],list[canonDef]){}.
  thetaEnv(Path,Repo,Lc,Els,Fields,Base,TheEnv,Defs,Public,Imports,Others) :-
    macroRewrite(Els,Stmts),
    displayAll(Stmts),
    dependencies(Stmts,Groups,Public,Annots,Imps,Otrs),
    processImportGroup(Imps,Imports,Repo,Base,IBase),
    checkGroups(Groups,Fields,Annots,Defs,pushFace(Fields,Lc,IBase),TheEnv,Path),
    checkOthers(Otrs,Others,TheEnv,Path).

  private checkGroups:(list[list[defn]],list[(string,tipe)],list[(string,ast)],list[canonDef],list[env],list[env],string){}.
  checkGroups([],_,_,[],E,E,_).
  checkGroups([Gp,..More],Fields,Annots,Defs,Env,E,Path) :-
    checkGroup(Gp,Gp,Fields,Annots,Defs,D0,Env,E0,Path),
    checkGroups(More,Fields,Annots,D0,E0,E,Path).

  private checkGroup:(list[defn],list[defn],list[(string,tipe)],list[(string,ast)],list[canonDef],list[canonDef],list[env],list[env],string){}.
  checkGroup(Grp,[defn(_,tpe,_,_,_),.._],_,_,Defs,Dx,Env,Ex,Path) :-
    typeGroup(Grp,Defs,Dx,Env,Ex,Path).
  checkGroup(Grp,[defn(_,var,_,_,_),.._],Fields,Annots,Defs,Dx,Env,Ex,Path) :-
    varGroup(Grp,Fields,Annots,Defs,Dx,Env,Ex,Path).
  checkGroup(Grp,[defn(_,con,_,_,_),.._],_,_,Defs,Dx,Env,Ex,Path) :-
    contractGroup(Grp,Defs,Dx,Env,Ex,Path).
  checkGroup(Grp,[defn(_,impl,_,_,_),.._],_,_,Defs,Dx,Env,Ex,Path) :-
    implementationGroup(Grp,Defs,Dx,Env,Ex,Path).

  -- This is very elaborate - to support mutual recursion amoung types.

  private typeGroup:(list[defn],list[canonDef],list[canonDef],list[env],list[env],string){}.
  typeGroup(Grp,Defs,Dx,Env,Ex,Path) :-
    defineTypes(Grp,Env,TmpEnv,Path),
    parseTypeDefs(Grp,TpDefs,[],TmpEnv,Path),
    declareTypes(TpDefs,Defs,Dx,Env,Ex).

  private defineTypes:(list[defn],list[env],list[env],string){}.
  defineTypes([],Env,Env,_).
  defineTypes([defn(N,tpe,Lc,_,[Stmt]),..More],Env,Ex,Path) :-
    defineType(N,Lc,Stmt,Env,E0,Path),
    defineTypes(More,E0,Ex,Path).
  defineTypes([defn(N,tpe,Lc,_,[_,.._]),..More],Env,Ex,Path) :-
    reportError("multiple type definition statement for $(N)",Lc),
    defineTypes(More,Env,Ex,Path).

  private defineType:(string,location,ast,list[env],list[env],string){}.
  defineType(N,Lc,_,Env,Ex,Path) :-
    ( isType(N,Env,OLc,_) ?
        reportError("type $(N) already defined at $(OLc)",Lc),
        Ex = Env |
        parseTypeTemplate(St,[],Env,Type,Path),
        declareType(N,tpDef(Lc,Type,faceType([])),Env,Ex)).

  private parseTypeDefs:(list[defn],list[canonDef],list[canonDef],list[env],string){}.
  parseTypeDefs([],Defs,Defs,_,_).
  parseTypeDefs([defn(N,tpe,Lc,_,[Stmt]),..More],Defs,Dx,TmpEnv,Path) :-
    parseTypeDefinition(N,Lc,Stmt,Defs,D0,TmpEnv,Path),
    parseTypeDefs(More,D0,Dx,TmpEnv,Path).

  private parseTypeDefinition:(string,location,ast,list[canonDef],list[canonDef],list[env],string){}.
  parseTypeDefinition(N,Lc,St,[typeDef(Lc,N,Type,FaceRule),..Defs],Defs,Env,Path) :-
    parseTypeRule(St,Env,FaceRule,Path),
    isType(N,Env,Type).

  private declareTypes:(list[canonDef],list[canonDef],list[canonDef],list[env],list[env]){}.
  declareTypes([],Defs,Defs,Env,Env).
  declareTypes([typeDef(Lc,N,Type,FaceRule),..More],[typeDef(Lc,N,Type,FaceRule),..Defs],Dx,Env,Ex) :-
    declareType(N,tpDef(Lc,Type,FaceRule),Env,E0),
    declareTypes(More,Defs,Dx,E0,Ex).

  -- handle program definitions
  private varGroup:(list[defn],list[(string,tipe)],list[(string,ast)],list[canonDef],list[canonDef],list[env],list[env],string){}.
  varGroup(Grp,Fields,Annots,Defs,Dx,Base,Env,Path) :-
    parseAnnotations(Grp,Fields,Annots,Base,Env,Path)!,
    checkVarRules(Grp,Env,Defs,Dx,Path).

  private parseAnnotations:(list[defn],list[(string,ast)],list[env],list[env],string){}.
  parseAnnotations([],_,_,Env,Env,_).
  parseAnnotations([defn(Nm,var,_,_,_),..More],Fields,Annots,Env,Ex,Path) :-
    ((Nm,Annot) in Annots)!,
    isBinary(Annot,":",Lc,_,T),
    parseType(T,Env,Tp),
    declareVar(Nm,vr(Nm,Lc,Tp),Env,E0),
    parseAnnotations(More,Fields,Annots,E0,Ex,Path).
  parseAnnotations([defn(N,var,Lc,_,_),..More],Fields,Annots,Env,Ex,Path) :-
    ((N,Tp) in Fields)!,
    declareVar(N,vr(N,Lc,Tp),Env,E0),
    parseAnnotations(More,Fields,Annots,E0,Ex,Path).
  parseAnnotations([defn(N,var,Lc,_,_),..More],Fields,Annots,Env,Ex,Path) :-
    reportError("no type annotation for variable $(N)",Lc),
    parseAnnotations(More,Fields,Annots,Env,Ex,Path).

  private checkVarRules:(list[defn],list[env],list[canonDef],list[canonDef],string){}.
  checkVarRules([],_,Defs,Defs,_).
  checkVarRules([defn(N,var,Lc,_,Stmts),..More],Env,Defs,Dx,Path) :-
    forEvidence(pickupVarType(N,Lc,Env),pickupThisType(Env),Q,PT),
    declareTypeVars(pairs(Q),Lc,Env,StmtEnv),
    moveConstraints(PT,Cx,ProgramType),
    processStmts(Stmts,ProgramType,Rules,[],StmtEnv,Path),
    generalizeStmts(Rules,Env,Cx,Defs,D0),
    checkVarRules(More,Env,D0,Dx,Path).

  private pickupVarType:(string,location,list[env]) => tipe.
  pickupVarType(N,_,Env)=>Tp :-
    isVar(N,Env,vr(_,_,Tp)),!.
  pickupVarType(N,Lc,_) => newVar("_") :- reportError("$(N) not declared",Lc).

  private declareTypeVars:(list[(string,tipe)],location,list[env],list[env]){}.
  declareTypeVars([],_,Env,Env).
  declareTypeVars([("this",_),..Vars],Lc,Env,Ex) :- !,
    declareTypeVars(Vars,Lc,Env,Ex).
  declareTypeVars([(Nm,Tp),..Vars],Lc,Env,Ex) :-
    declareTypeVars(Vars,Lc,declareTypeExists(Nm,Tp,some(Lc),Env),Ex).

  private processStmts:(list[ast],tipe,list[canonRule],list[canonRule],list[env],string){}.
  processStmts([],_,Defs,Defs,_,_).
  processStmts([St,..More],ProgramType,Defs,Dx,Env,Path) :-
    processStmt(St,ProgramType,Defs,D0,Env,Path)!,
    processStmts(More,ProgramType,D0,Dx,Env,Path).

  private processStmt:(ast,tipe,list[canonRule],list[canonRule],list[env],string){}.
  processStmt(St,ProgramType,Defs,Defx,E,_) :-
    isBinary(St,"=>",Lc,L,R),
    checkEquation(Lc,L,iden(Lc,"true"),R,ProgramType,Defs,Defx,E).
  processStmt(St,ProgramType,Defs,Defx,E,_) :-
    isBinary(St,":-",Lc,L,G),
    isBinary(L,"=>",_,H,R),
    checkEquation(Lc,H,G,R,ProgramType,Defs,Defx,E).
  processStmt(St,ProgramType,Defs,Defx,E,_) :-
    isBinary(St,":-",Lc,L,G),
    isBinary(L,"=",_,H,R),
    checkDefn(Lc,H,G,R,ProgramType,Defs,Defx,E).
  processStmt(St,ProgramType,Defs,Defx,E,_) :-
    isBinary(St,":-",Lc,L,G),
    isBinary(L,"<=",_,H,R),
    checkClassRule(Lc,H,G,R,ProgramType,Defs,Defx,E).
  processStmt(St,predType(AT),[clause(Lc,Nm,Args,Body),..Defs],Defs,E,_) :-
    isBinary(St,":-",Lc,L,R),
    splitHead(L,Nm,A),
    typeOfTerm(A,AT,pushScope(E),E0,Lc,Args),
    checkCond(R,E1,_,Body).
  processStmt(St,predType(AT),[clause(Lc,Nm,Args,trueCond,..Defs],Defs,E,_) :-
    splitHead(St,Nm,A),
    typeOfTerm(A,AT,pushScope(E),E0,St.loc,Args).
  processStmt(St,Tp,Defs,Dx,Env,_) :-
    isBinary(St,"=",Lc,L,R),
    checkDefn(Lc,L,iden(Lc,"true"),R,Tp,Defs,Dx,Env).
  processStmt(St,ProgramType,Defs,Defx,E,_) :-
    isBinary(St,"<=",Lc,H,R),
    checkClassRule(Lc,H,iden(Lc,"true"),R,ProgramType,Defs,Defx,E).
  processStmt(St,Tp,[clBody(Lc,Nm,tpl([]),Stmts,Others,Types),..Defs],Defs,E,Path) :-
    isBinary(St,"..",Lc,L,R),
    isIden(L,_,Nm),
    subPath(Path,marker(clss),Nm,ClassPath),
    checkClassBody(Tp,R,pushScope(E),Stmts,Others,Types,ClassPath).
  processStmt(St,classType(AT,Tp),[clBody(Lc,Nm,Arg,Stmts,Others,Types),..Defs],Defs,E,Path) :-
    isBinary(St,"..",Lc,L,R),
    splitHead(L,Nm,A),
    typeOfTerm(A,AT,pushScope(E),E1,Arg),
    subPath(Path,marker(clss),Nm,ClassPath),
    checkClassBody(Tp,R,E1,Stmts,Others,Types,_,ClassPath).
  processStmt(St,Tp,Defs,Dx,E,Path) :-
    isBinary(St,"-->",Lc,L,R),
    checkGrammarRule(Lc,L,R,Tp,Defs,Dx,E,Path).
  processStmt(St,Tp,Defs,Defs,_,_) :-
    reportError("Statement $(St) not consistent with expected type $(Tp)",St.loc).

  private splitHead:(ast,string,ast){}.
  splitHead(T,Nm,A) :- isRound(T,_,Nm,A).

  private checkEquation:(location,ast,ast,ast,tipe,list[canonRule],list[canonRule],list[env]){}.
  checkEquation(Lc,H,G,R,funType(AT,RT),[equation(Lc,Nm,Args,Cond,Exp)|Defs],Defs,E) :-
    splitHead(H,Nm,A),
    typeOfTerm(A,AT,pushScope(E),E0,Lc,Args),
    checkCond(G,E0,E1,Cond),
    typeOfTerm(R,RT,E1,_,Exp).
  checkEquation(Lc,_,_,_,ProgramType,Defs,Defs,_) :-
    reportError("equation not consistent with expected type: $(ProgramType)",Lc).

  private checkClassRule:(location,ast,ast,ast,tipe,list[canonRule],list[canonRule],list[env]){}.
  checkClassRule(Lc,H,G,R,classType(AT,_),[clRule(Lc,Nm,Arg,Repl,Cond,SuperFace),..Defs],Defs,E) :-
    isRound(H,_,Nm,A),
    typeOfTerm(A,AT,pushScope(E),E1,Arg),
    SuperTp = newVar("S"),
    checkCond(G,E1,E2,Cond),
    typeOfTerm(R,SuperTp,E2,_,Repl),
    generateClassFace(SuperTp,E1,SuperFace).
  checkClassRule(Lc,H,G,R,Tp,[clRule(Lc,Nm,tpl([]),Repl,Cond,SuperFace),..Defs],Defs,E) :-
    isIden(H,_,Nm),
    SuperTp = newVar("S"),
    checkCond(G,pushScope(E),E2,Cond),
    typeOfTerm(R,SuperTp,E2,_,Repl),
    generateClassFace(SuperTp,E1,SuperFace).

  private generateClassFace:(tipe,list[env],tipe){}.
  generateClassFace(Tp,Env,Face) :-
    freshen(Tp,voidType,Q,Plate),
    (Plate = classType(_,T); T=Plate),
    getTypeFace(T,Env,F),
    freezeType(F,Q,Face),!.

  private checkClassBody:(tipe,ast,list[env],list[canonDef],list[canonOther],list[canonDef],string){}.
  checkClassBody(ClassTp,Body,Env,Defs,Others,Types,BodyDefs,ClassPath) :-
    isBraceTuple(Body,Lc,Els),
    getTypeFace(ClassTp,Env,Face),
    moveConstraints(Face,_,faceType(Fields)),
    declareVar("this",vr("this",Lc,ClassTp),pushScope(Env),ThEnv),
    thetaEnv(ClassPath,nullRepo,Lc,Els,Fields,ThEnv,_OEnv,Defs,Public,_Imports,Others),
    computeExport(Defs,Fields,Public,BodyDefs,Types,[],[]).

  private checkDefn:(location,ast,ast,ast,tipe,list[canonDef],list[canonDef]){}
  checkDefn(Lc,L,C,R,Tp,[defn(Lc,Nm,Cond,Value),..Dx],Dx,E) :-
    isIden(L,_,Nm),
    checkCond(C,pushScope(E),E1,Cond),
    typeOfTerm(R,Tp,E1,_,Value).

  private checkCond:(ast,list[env],list[env],canonCond){}.
  checkCond(Term,Env,Env,trueCond) :-
    isIden(Term,Lc,"true").
  checkCond(Term,Env,Env,falseCond) :-
    isIden(Term,Lc,"false").
  checkCond(Term,Env,Ex,conjCond(Lhs,Rhs)) :-
    isBinary(Term,",",_,L,R),
    checkCond(L,Env,E1,Lhs),
    checkCond(R,E1,Ex,Rhs).
  checkCond(Term,Env,Ex,condCond(Test,Either,Or)) :-
    isBinary(Term,"|",_,L,R),
    isBinary(L,"?",T,Th),
    checkCond(T,Env,E0,Test),
    checkCond(Th,E0,E1,Either),
    checkCond(R,E1,Ex,Or).
  checkCond(Term,Env,Ex,disjCond(Either,Or)) :-
    isBinary(Term,"|",_,L,R),
    checkCond(L,Env,E1,Either),
    checkCond(R,E1,Ex,Or).
  checkCond(Term,Env,Ex,oneCond(Test)) :-
    isUnary(Term,"!",_,N),
    checkCond(N,Env,Ex,Test).
  checkCond(Term,Env,Env,negCond(Test)) :-
    isUnary(Term,"\\+",_,N),
    checkCond(N,Env,_,Test).
  checkCond(Term,Env,Env,forallCond(Gen,Test)) :-
    isBinary(Term,"*>",_,L,R),
    checkCond(L,Env,E0,Gen),
    checkCond(R,E0,_,Test).
  checkCond(Term,Env,Ex,Cond) :-
    isRoundTuple(Term,_,C),
    checkConds(C,Env,Ex,Cond).
  checkCond(Term,Env,Ev,negCond(unifyCond(Lhs,Rhs))) :-
    isBinary(Term,"\\=",_,L,R),
    TV = newVar("_#"),
    typeOfTerm(L,TV,Env,E0,Lhs),
    typeOfTerm(R,TV,E0,Ev,Rhs).
  checkCond(Term,Env,Ev,unifyCond(Lhs,Rhs)) :-
    isBinary(Term,"=",_,L,R),
    TV = newVar("_#"),
    typeOfTerm(L,TV,Env,E0,Lhs),
    typeOfTerm(R,TV,E0,Ev,Rhs).
  checkCond(Term,Env,Ev,phraseCond(Lc,NT,Strm,Rest)) :-
    isBinary(Term,"%%",Lc,L,R),
    isBinary(R,"~",_,S,M),
    StrmTp = newVar("_S"),
    ElTp = newVar("_E"),
    checkGrammarType(Lc,Env,StrmTp,ElTp),
    typeOfTerm(S,StrmTp,Env,E0,Strm),
    typeOfTerm(M,StrmTp,E0,E1,Rest),
    declareVar(streamVar,vr(Lc,v(streamVar),StrmTp),E1,E2),
    checkNonTerminals(L,StrmTp,E2,Ev,NT).
  checkCond(Term,Env,Ev,phraseCond(Lc,NT,Strm,Rest)) :-
    isBinary(Term,"%%",Lc,L,R),
    StrmTp = newVar("_S"),
    ElTp = newVar("_E"),
    checkGrammarType(Lc,Env,StrmTp,ElTp),
    typeOfTerm(S,StrmTp,Env,E0,Strm),
    M = iden(Lc,_str_gen("_")),
    typeOfTerm(M,StrmTp,E0,E1,Rest),
    declareVar("stream_X",vr(Lc,v("stream_X"),StrmTp),E1,E2),
    checkNonTerminals(binary(Lc,",",L,iden(Lc,"eof")),StrmTp,E2,Ev,NT).
  checkCond(Term,Env,Ev,Call) :-
    isRound(Term,Lc,F,A),
    PrTp = newVar("_P"),
    typeOfKnown(F,PrTp,Env,E0,Pred),
    ( deRef(PrTp) = predType(ArgTp) ?
      typeOfTerm(A,ArgTp,E0,Ev,Arg),
      Call = goal(Lc,Pred,Arg) |
      reportError("$(Pred)|=$(Tp) not a predicate",Lc),
      Call = trueCond).
  checkCond(Term,Env,Env,trueCond) :-
    reportError("cannot understand condition $(Term)",Term.loc).

  private checkConds:(list[ast],list[env],list[env],list[canonCond]){}.
  checkConds([],Env,Env,[]).
  checkConds([C,..L],Ev,Env,[Co,..M]) :-
    checkCond(C,Ev,E0,Co),
    checkConds(L,E0,Env,M).

  private typeOfTerm:(ast,tipe,list[env],list[env],canonTerm){}.
  typeOfTerm(V,_,Env,Env,v(_str_gen("_"))) :- isIden(V,_,"_").
  typeOfTerm(V,Tp,Env,Ev,Term) :-
    isIden(V,Lc,Nm),
    ( isVar(Nm,Env,Spec) ?
      typeOfVar(Lc,Spec,Tp,Env,Term), Env=Ev |
      Ev = declareVar(Nm,vr(Lc,v(Nm),Tp),Env), Term=v(Nm)).
  typeOfTerm(intg(Lc,Ix),Tp,Env,Env,int(Ix)) :- 
    checkType(Lc,findType("integer",Lc,Env),Tp,Env).
  typeOfTerm(flot(Lc,Dx),Tp,Env,Env,flt(Ix)) :- 
    checkType(Lc,findType("float",Lc,Env),Tp,Env).
  typeOfTerm(strg(Lc,Sx),Tp,Env,Env,str(Sx)) :- 
    checkType(Lc,findType("string",Lc,Env),Tp,Env).
  typeOfTerm(Term,Tp,Env,Ev,Exp) :-
    isBinary(Term,":",Lc,L,R),
    ( parseType(R,Env,RT) ?
        checkType(Lc,RT,Tp,Env),
        typeOfTerm(L,RT,Env,Ev,Exp) |
        reportError("cannot parse type $(R)",Lc),
        typeOfTerm(L,Tp,Env,Ev,Exp)).  
  typeOfTerm(Term,Tp,Env,Ev,Exp) :-
    isBinary(Term,"::",Lc,L,R),
    typeOfTerm(binary(Lc,":",unary(Lc,"_coerce",L),R),Tp,Env,Ev,Exp).
  typeOfTerm(P,Tp,Env,Ex,whre(Ptn,Cond)) :-
    isBinary(P,"@@",_,L,R),
    typeOfTerm(L,Tp,Env,E0,Ptn),
    checkCond(R,E0,Ex,Cond).
  typeOfTerm(Call,Tp,Env,Ev,whre(V,Cond)) :-
    isUnary(Call,"@",Lc,Test), -- @Test = NV @@ NV.Test where NV is a new name
    isRoundTerm(Test,_,_,_),
    NV = iden(Lc,_str_gen("_")),
    typeOfTerm(NV,Tp,Env,E0,V),
    checkCond(binary(Lc,".",NV,Test),E0,Ev,Cond).
  typeOfTerm(Term,Tp,Env,Ev,Exp) :-
    isBinary(Term,".",Lc,L,F),
    isIden(F,Fld),
    recordAccessExp(Lc,L,Fld,Tp,Env,Ev,Exp).
  typeOfTerm(Term,Tp,Env,Ev,conExp(Lc,Test,Then,Else)) :-
    isBinary(Term,"|",Lc,L,El),
    isBinary(L,"?",_,Tst,Th),
    checkCond(Tst,Env,E0,Test),
    typeOfTerm(Th,Tp,E0,E1,Then),
    typeOfTerm(El,Tp,E1,Ev,Else).
  typeOfTerm(Term,Tp,Env,Ev,Exp) :-
    isSquareTuple(Term,Lc,Els),
    typeExp(_,[ElTp]) = findType("list",Lc,Env),
    checkType(Lc,ListTp,Tp,Env),
    typeOfListTerm(Els,Lc,ElTp,ListTp,classType(tupleType([ElTp,ListTp]),Env,Ev,Exp).
  typeOfTerm(tuple(_,"()",[Inner]),Tp,Env,Ev,Exp) :-  -- a unary round tuple might just be parenthetic expression
    \+ isRoundTuple(Inner,_,_),
    typeOfTerm(Inner,Tp,Env,Ev,Exp).
  typeOfTerm(Term,Tp,Env,Ev,tpl(Els)) :-
    isRoundTuple(Term,Lc,A),
    genTpVars(A,ArgTps),
    checkType(Lc,tupleType(ArgTps),Tp,Env),
    typeOfTerms(A,ArgTps,Env,Ev,Lc,Els).
  typeOfTerm(Term,Tp,Env,Ev,dict(Lc,Entries)) :-
    isBraceTuple(Term,Lc,Els),
    MapTp = findType("map",Lc,Env),
    MapTp = typeExp(_,[KyTp,ElTp]),
    checkType(Lc,MapTp,Tp,Env),
    typeMapEntries(Els,KyTp,ElTp,Env,Ev,Entries).
  typeOfTerm(Term,Tp,Env,Env,Exp) :-
    isUnary(Term,"-",Lc,Arg),         -- handle unary minus
    typeOfTerm(binary(Lc,"-",name(Lc,"zero"),Arg),Tp,Env,Ev,Exp).
  typeOfTerm(Term,Tp,Env,Ev,Exp) :-
    isBinary(Term,"=>",Lc,Lhs,Rhs),
    isRoundTuple(Lhs,_,A),
    ArgTp = tupleType(mkTypes(length(A))),
    ResTp = newVar("_"),
    FunTp = funType(ArgTp,ResTp),
    checkType(Lc,FunTp,Tp,Env),
    E0 = pushScope(Env),
    typeOfTerm(Lhs,ArgTp,E0,E1,Arg),
    typeOfTerm(Rhs,ResTp,E1,E2,Res),
    Exp = lambda(equation(Lc,Arg,Res,trueCond)). -- Have to sort out free variables at some point
  typeOfTerm(Term,Tp,Env,Ev,Exp) :-
    isRound(Term,Lc,F,A),
    FnTp = newVar("F"),
    knownType(F,FnTp,Env,E0,Fun),
    typeOfCall(Lc,Fun,A,deRef(FnTp),Tp,E0,Ev,Exp).
  typeOfTerm(Term,Tp,Env,Ev,Exp) :-
    isSquareTerm(Term,Lc,F,[A]),
    typeOfTerm(binary(Lc,"find",F,A),Tp,Env,Ev,Exp).
  typeOfTerm(Term,Tp,Env,Env,v(_str_gen("_"))) :-
    reportError("illegal expression: $(Term), expecting a $(Tp)",Term.loc).


  private checkNonTerminals:(ast,tipe,tipe,list[env],list[env],canonNT){}.
  checkNonTerminals(Tpl,_,ElTp,E,Env,grTerms(Terms)) :-
    isSquareTuple(Tpl,_,Els),
    checkTerminals(Els,"_hdtl",Terms,ElTp,E,Env).
  checkNonTerminals(strg(Lc,Text),_,ElTp,Env,Env,grTerms(Lc,Terms)) :- !,
    checkTerminals(explodeStringLit(Lc,Text),"_hdtl",Terms,ElTp,Env,_).  -- strings are exploded into code points
  checkNonTerminals(Term,Tp,ElTp,Env,Ex,GrNT) :-
    isRoundTuple(Term,_,[NT]),
    checkNonTerminals(NT,Tp,ElTp,Env,Ex,GrNT).
  checkNonTerminals(Term,Tp,ElTp,Env,Ex,grConj(Lhs,Rhs)) :-
    isBinary(Term,",",Lc,L,R),
    checkNonTerminals(L,Tp,ElTp,Env,E1,Lhs),
    checkNonTerminals(R,Tp,ElTp,E1,Ex,Rhs).
  checkNonTerminals(Term,Tp,ElTp,Env,Ex,grCond(Test,Either,Or)) :-
    isBinary(Term,"|",_,L,R),
    isBinary(L,"?",_,T,Th),!,
    checkNonTerminals(T,Tp,ElTp,Env,E0,Test),
    checkNonTerminals(Th,Tp,ElTp,E0,E1,Either),
    checkNonTerminals(R,Tp,ElTp,E1,Ex,Or).
  checkNonTerminals(Term,Tp,ElTp,Env,Ex,grDisj(Either,Or)) :-
    isBinary(Term,"|",_,L,R),
    \+isBinary(L,"?",_,_,_),
    checkNonTerminals(L,Tp,ElTp,Env,E1,Either),
    checkNonTerminals(R,Tp,ElTp,E1,Ex,Or).
  checkNonTerminals(Term,Tp,ElTp,Env,Ex,grOne(Test)) :-
    isUnary(Term,"!",_,N),
    checkNonTerminals(N,Tp,ElTp,Env,Ex,Test).
  checkNonTerminals(Term,Tp,ElTp,Env,Env,grNeg(Test)) :-
    isUnary(Term,"\\+",Lc,N),
    checkNonTerminals(N,Tp,ElTp,Env,_,Test).
  checkNonTerminals(Term,Tp,ElTp,Env,Env,grAhed(Test)) :-
    isUnary(Term,"+",Lc,N),
    checkNonTerminals(N,Tp,ElTp,Env,_,Test).
  checkNonTerminals(Term,_,_,Env,Ev,grTest(unify(Lc,Lhs,Rhs))) :-
    isBinary(Term,"=",Lc,L,R),
    TV = newVar("_"),
    typeOfTerm(L,TV,Env,E0,Lhs),
    typeOfTerm(R,TV,E0,Ev,Rhs).
  checkNonTerminals(Term,_,_,Env,Ev,grTest(negCond(unify(Lc,Lhs,Rhs)))) :-
    isBinary(Term,"\\=",Lc,L,R),
    TV = newVar("_"),
    typeOfTerm(L,TV,Env,E0,Lhs),
    typeOfTerm(R,TV,E0,Ev,Rhs).
  checkNonTerminals(Term,Tp,_,Env,Ev,dip(v(Lc,NV),Cond)) :-
    isUnary(Term,"@",Lc,Test),
    isRoundTerm(Test,_,Op,Args),
    genstr("_",NV),
    declareVar(NV,vr(NV,Lc,Tp),Env,E0),
    binary(Lc,".",iden(Lc,NV),Op,NOp),
    checkCond(appl(Lc,NOp,tupl(Lc,"()",Args)),E0,Ev,Cond).
  checkNonTerminals(Term,Tp,_,Env,Ev,NT) :-
    isRound(Term,Lc,F,A),
    GrTp = newVar("_G"),
    typeOfKnown(F,GrTp,Env,E0,Op),
    ( deRef(GrTp) = grammarType(ArgTp,StrmTp) ?
      ( checkType(Lc,StrmTp,Tp,Env) ?
        typeOfTerm(A,ArgTp,E0,Ev,Arg),
        NT = grCall(Lc,Op,Arg) |
        reportError("type of $(Op) : $(GrTp) not consistent with stream type $(Tp)"),
        NT = grTerms([]), Ev = E0) |
      reportError("$(F) : $(GrTp) not a grammar"),
      NT = grTerms([]),
      Ev = Env).
  checkNonTerminals(Term,_,_,Env,Env,grTest(EOF)) :-
    isIden(Term,Lc,"eof"),
    checkCond(unary(Lc,"_eof",iden(Lc,streamVar)),Env,_,EOF).
  checkNonTerminals(Term,_,_,Env,Ex,grTest(Cond)) :-
    isBraceTuple(Term,Lc,Els),
    checkConds(Els,Env,Ex,Cond).

  private checkTerminals:(list[ast],string,list[canonNT],tipe,list[env],list[env]){}.
  checkTerminals([],_,[],_,Env,Env).
  checkTerminals([T,..L],V,[(Lc.loc,V,TT),..M],ElTp,Env,Ev) :-
    typeOfTerm(T,ElTp,Env,E0,TT),
    checkTerminals(L,V,M,ElTp,E0,Ev).

  private explodeStringLit:(location,string) => list[ast].
  explodeStringLit(Lc,Str) => makeIntList(explode(Str),Lc).

  private makeIntList:(list[integer],location) => lisst[ast].
  makeIntList([],_) => [].
  makeIntList([Code,..L],Lc) => [intg(Lc,Code),..makeIntList(L,Lc)].

  private streamVar:string.
  streamVar = "stream_X".

  private typeOfVar:(location,vr,tipe,list[env],canonTerm){}.
  typeOfVar(Lc,vr(VLc,VNm,VT),Tp,Env,Term) :-
    manageConstraints(freshen(VT,pickupThisType(Env)),[],VNm,MTp,Term),
    checkType(Lc,MTp,Tp,Env).

  private manageConstraints:(tipe,list[constraint],canonTerm,tipe,canonTerm){}.
  manageConstraints(constrained(T,C),Cons,V,MTp,Exp) :-
    manageConstraints(T,[C,..Cons],V,MTp,Exp).
  manageConstraints(Tp,[],V,Tp,V).
  manageConstraints(Tp,Cons,V,Tp,over(V,Cons)).

  private knownType:(ast,tipe,list[env],list[env],canonTerm){}.
  knownType(V,Tp,Env,Env,Term) :-
    ( isIden(V,Lc,Nm) ?
      ( isVar(Nm,Env,Spec) ?
        typeOfVar(Lc,Spec,Tp,Env,Term), Env=Ev |
        reportError("variable $(V) not declared",Lc),
        Term=v(Nm)) |
      typeOfTerm(V,Tp,Env,Ex,Term)).

  private typeOfCall:(location,canonTerm,canonTerm,tipe,tipe,list[env],list[env],canonTerm){}.
  typeOfCall(Lc,Fun,A,funType(ArgTp,ResTp),Tp,Env,Ev,apply(Lc,Fun,Args)) :-
    checkType(Lc,ResTp,Tp,Env),
    typeOfTerm(A,ArgTp,Env,Ev,Args).
  typeOfCall(Lc,Fun,A,classType(ArgTp,ResTp),Tp,Env,Ev,apply(Lc,Fun,Args)) :-
    checkType(Lc,ResTp,Tp,Env),
    typeOfTerm(A,ArgTp,Env,Ev,Args).
  typeOfCall(Lc,Fun,_,Ftp,_,Env,Env,Fun) :-
    reportError("$(Fun) : $(Ftp) is not a function",Lc).

  private typeOfListTerm:(list[ast],location,tipe,tipe,tipe,list[env],list[env],canonTerm){}.
  typeOfListTerm([],Lc,_,ListTp,_,Env,Ev,Exp) :-
    typeOfTerm(iden(Lc,"[]"),ListTp,Env,Ev,Exp).
  typeOfListTerm([Last],_,ElTp,ListTp,ConTp,Env,Ev,apply(Op,[Hd,Tl])) :-
    isBinary(Last,",..",Lc,L,R),
    typeOfKnown(iden(Lc,",.."),ConTp,Env,E0,Op),
    typeOfTerm(L,ElTp,E0,E1,Hd),
    typeOfTerm(R,ListTp,E1,Ev,Tl).
  typeOfListTerm([El,..More],_,ElTp,ListTp,ConTp,Env,Ev,apply(Lc,Op,tpl([Hd,Tl]))) :-
    Lc = EL.loc,
    typeOfKnown(iden(Lc,",.."),ConTp,Env,E0,Op),
    typeOfTerm(El,ElTp,E0,E1,Hd),
    typeOfListTerm(More,Lc,ElTp,ListTp,ConTp,E1,Ev,Tl).

  private typeMapEntries:(list[ast],tipe,tipe,list[env],list[env],list[(string,canonTerm)]){}.
  typeMapEntries([],_,_,Env,Env,[]).
  typeMapEntries([En,..Els],KyTp,ElTp,Env,Ev,[(Ky,Vl),..Entries]) :-
    isBinary(En,"->",_,Lhs,Rhs),
    typeOfTerm(Lhs,KyTp,Env,E0,Ky),
    typeOfTerm(Rhs,ElTp,E0,E1,Vl),
    typeMapEntries(Els,KyTp,ElTp,E1,Ev,Entries).
  typeMapEntries([En,..Els],KyTp,ElTp,Env,Ev,Entries) :-
    reportError("invalid entry '$(En)' in map",En.loc),
    typeMapEntries(Els,KyTp,ElTp,Env,Ev,Entries).

  private checkType:(location,tipe,tipe,list[env]){}.
  checkType(Lc,Actual,Expected,Env) :-
    ( sameType(Actual,Expected,Env) ? true | reportError("$(Actual) not consistent with $(Expected)",Lc)).

  private checkGrammarType:(location,list[env],tipe,tipe){}.
  checkGrammarType(Lc,Env,Tp,ElTp) :-
    isContract("stream",Env,conDef(_,_,Spec,_,_)),
    freshen(Spec,pickupThisType(Env)) = conTract(_,[Arg],[Dep]),
    checkType(Lc,Arg,Tp,Env),
    checkType(Lc,Dep,ElTp,Env).

  private pickupThisType:(list[env]) => map[string,tipe].
  pickupThisType(Env) => { "this" -> ThisType} :- isVar("this",Env,vr(_,_,ThisType)).
  pickupThisType(_) => {}.

  private findType:(string,location,list[env]) => tipe.
  findType(Nm,_,Env) => freshen(T,pickupThisType(Env)) :-
    findType(Nm,Env,T).
  findType(Nm,Lc,_) => anonType :-
    reportError("type $(Nm) not known",Lc).

  private mkTypes:(integer) => list[tipe].
  mkTypes(0) => [].
  mkTypes(N) => [newVar("_"),..mkTypes(N-1)].

  private computeNewVars:(list[env]) => list[string].
  computeNewVars(Env) => keys(topVars(Env)).

  private pushFace:(list[(string,tipe)],location,list[env]) => list[env].
  pushFace([],_,E) => E.
  pushFace([(N,T),..L],Lc,E) => pushFace(L,Lc,declareVar(N,vr(Lc,v(N),T))).

  computeExport:(list[canonDef],list[(string,tipe)],list[(string,defnKind)],
                  list[canonDef],list[canonDef],list[canonDef],list[canonDef]){}.
  computeExport([],_,_,[],[],[],[]).
  computeExport([Def,..Defs],Fields,Public,Exports,Types,Contracts,Impls) :-
    exportDef(Def,Fields,Public,Exports,Ex,Types,Tx,Contracts,Cx,Impls,Ix)!,
    computeExport(Defs,Fields,Public,Ex,Tx,Cx,Ix).

  exportDef:(canonDef,list[(string,tipe)],list[(string,defnKind)],
          list[(string,tipe)],list[(string,tipe)],
          list[(string,tipe)],list[(string,tipe)],
          list[canonDef],list[canonDef],
          list[canonDef],list[canonDef]){}.
  exportDef(function(_,Nm,Tp,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(predicate(_,Nm,Tp,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(class(_,Nm,Tp,_,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(enum(_,Nm,Tp,_,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(typeDef(_,Nm,_,FaceRule),_,Public,Exports,Exports,[(Nm,FaceRule),..Tx],Tx,Cons,Cons,Impl,Impl) :-
    isPublicType(Nm,Public).
  exportDef(defn(_,Nm,_,Tp,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(grammar(_,Nm,Tp,_,_),Fields,Public,[(Nm,Tp),..Ex],Ex,Types,Types,Cons,Cons,Impl,Impl) :-
    isPublicVar(Nm,Fields,Public).
  exportDef(Con,_,Public,Ex,Ex,Types,Types,[Con,..Cons],Cons,Impl,Impl) :-
    isPublicContract(Con,Public).
  exportDef(impl(_,INm,ImplName,_,Spec,_,_,_,_),_,Public,Ex,Ex,Tps,Tps,Cons,Cons,[imp(ImplName,Spec)|Ix],Ix) :-
    isPublicImplementation(INm,Public)!.
  exportDef(_,_,_,Ex,Ex,Tps,Tps,Cons,Cons,Impls,Impls).

  isPublicVar:(string,list[(string,tipe)],list[(string,defnKind)]){}.
  isPublicVar(Nm,_,Public) :-
    (Nm,valu) in Public.
  isPublicVar(Nm,Fields,_) :-
    (Nm,_) in Fields).

  isPublicType:(string,list[(string,defnKind)]){}.
  isPublicType(Nm,Public) :-
    (Nm,tpe) in Public.

  isPublicContract:(canonDef,list[(string,defnKind)]){}.
  isPublicContract(conDef(_,Nm,_,_),Public) :-
    (Nm,con) in Public.

  isPublicImplementation:(string,list[(string,defnKind)]){}.
  isPublicImplementation(Nm,Public) :-
    (Nm,impl) in Public.

}