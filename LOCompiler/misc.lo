lo.comp.misc{
  import lo.

  public pathSuffix:(string,string) => string.
  pathSuffix(Src,Marker) => After :-  splitString(Src,Marker,Before,After).
  pathSuffix(Src,_) => Src.

  splitString:(string,string,string,string){}.
  splitString(Src,Mrk,Before,After) :-
    _str_find(Src,Mrk,0,Pt),
    _str_split(Src,Pt,Before,Second),
    _str_split(Second,_str_len(Mrk),_,After).

  public subPath:(string,string,string)=>string.
  subPath(Path,Marker,Suffix) => Path+"."+Suffix :-
    splitString(Path,Marker,_,_).
  subPath(Path,Marker,Suffix) => Path+Marker+Suffix.

  public starts_with:(string,string){}.
  starts_with(S,T) :- _sub_str(S,0,size(T)) == T.

  public replace:all x~~(list[x],x,x) => list[x].
  replace([],_,r) => [r].
  replace([e,..l],e,r) => [r,..l].
  replace([e,..l],t,r) => [e,..replace(l,t,r)] :- e\=t.

  public collect:all x ~~ (list[x],(x){},list[x],list[x]){}.
  collect([],_,[],[]).
  collect([e,..l],p,[e,..m],o) :- p(e), collect(l,p,m,o).
  collect([e,..l],p,m,[e,..o]) :- \+ p(e), collect(l,p,m,o).

  -- Not brilliantly fast; but it does not need to be.
  public nextPrime:(integer)=>integer.
  nextPrime(From) => head(sieve(3,From,[3])).

  sieve:(integer,integer,list[integer]) => list[integer].
  sieve(Curr,Max,SoFar) => SoFar :- Curr>Max.
  sieve(Curr,Max,SoFar) => sieve(Nxt,Max,[Nxt,..SoFar]) :-
    filter(Curr+2,Nxt,SoFar).

  filter:(integer,integer,list[integer]){}.
  filter(Ix,Ix,L) :- E in L *> E%Ix \= 0.
  filter(Ix,Nx,L) :- filter(Ix+2,Nx,L).

  public trace:all x ~~ display[x] |: (string,x)=>x.
  trace(M,X) => X :-
    logMsg(M+"\(X)").
}
