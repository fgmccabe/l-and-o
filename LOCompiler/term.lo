lo.comp.term {
  import lo.

  import lo.comp.package.
  import lo.comp.types.

  public type term ::= anon
                   | varbl(string)
                   | intgr(integer)
                   | flot(float)
                   | enum(string)
                   | strct(string,integer)
                   | prg(string,integer)
                   | strng(string)
                   | tuple(list[term])
                   | cons(term,list[term]).

  public type clse ::= clse(list[term],term,list[term],list[pred]).

  public type pred ::= call(term,list[term])
                    | ecall(string,list[term])
                    | ocall(term,term,term)
                    | unfy(term,term)
                    | neck
                    | fail
                    | except(term).

  public type prProg ::= prProg(pkgSpec,list[clse]).

  public type codeSeg ::= codeSeg(term,list[integer],list[term]).

  public type codeMdl ::= codeMdl(pkgSpec,list[codeSeg]).

  public implementation display[prProg] <= {
    disp(Prog) => dispProg(Prog).
  }

  private dispProg:(prProg)=>ss.
  dispProg(prProg(_,Rules)) => ssSeq([ss("compiled rules\n"),..dispRules(Rules)]).

  private dispRules:(list[clse]) => list[ss].
  dispRules([]) => [].
  dispRules([Cl,..Rls]) => [disp(Cl),..dispRules(Rls)].

  public implementation display[clse] <= {
    disp(Cl) => dispClause(Cl).
  }

  private dispClause:(clse) => ss.
  dispClause(clse([],Hd,Args,Body)) => ssSeq([disp(Hd),disp(Args),ss(":-"),ssSeq(dispPreds("","\n    ",Body)),ss(".\n")]).
  dispClause(clse(Q,Hd,Args,Body)) => ssSeq([ss("all "),ssSeq(dispEls(""," ~~\n",Q)),disp(Hd),disp(Args),ss(":-"),ssSeq(dispPreds("","\n    ",Body)),ss(".\n")]).

  public implementation display[term] <= {
    disp(T) => dispTerm(T).
  }

  public dispTerm:(term) => ss.
  dispTerm(anon) => ss("_").
  dispTerm(varbl(Nm)) => ssSeq([ss(Nm),ss("?")]).
  dispTerm(intgr(Ix)) => disp(Ix).
  dispTerm(flot(Dx)) => disp(Dx).
  dispTerm(enum(Nm)) => ss(Nm).
  dispTerm(strct(Nm,Ar)) => ssSeq([ss(Nm),ss("@"),disp(Ar)]).
  dispTerm(prg(Nm,Ar)) => ssSeq([ss(Nm),ss("/"),disp(Ar)]).
  dispTerm(strng(Sx)) => disp(Sx).
  dispTerm(tuple(Els)) => ssSeq([ss("("),..dispEls("",")",Els)]).
  dispTerm(cons(Op,Args)) => ssSeq([disp(Op),ss("("),..dispEls("",")",Args)]).

  private dispEls:(string,string,list[term]) => list[ss].
  dispEls(_,Tail,[]) => [ss(Tail)].
  dispEls(Sep,Tail,[e,..l]) => [ss(Sep),dispTerm(e),..dispEls(", ",Tail,l)].

  public implementation display[pred] <= {
    disp(P) => displayPred(P).
  }

  private displayPred:(pred) => ss.
  displayPred(neck) => ss("!").
  displayPred(call(Op,Args)) => ssSeq([dispTerm(Op),ss("("),..dispEls("",")",Args)]).
  displayPred(ecall(Op,Args)) => ssSeq([disp(Op),ss("("),..dispEls("",")",Args)]).
  displayPred(ocall(Rc,Lb,Th)) => ssSeq([dispTerm(Lb),ss("/"),dispTerm(Th),ss("."),dispTerm(Rc)]).
  displayPred(unfy(L,R)) => ssSeq([dispTerm(L),ss("="),dispTerm(R)]).
  displayPred(fail) => ss("fail").
  displayPred(except(T)) => ssSeq([ss("raise "),disp(T)]).

  private dispPreds:(string,string,list[pred]) => list[ss].
  dispPreds(_,_,[]) => [].
  dispPreds(Sep,Alt,[C,..L]) => [ss(Sep),displayPred(C),..dispPreds(Alt,Alt,L)].

  public predArity:(pred) => integer.
  predArity(neck) => 0.
  predArity(fail) => 0.
  predArity(except(_)) => 1.
  predArity(call(_,Args)) => size(Args).
  predArity(ocall(_,_,_)) => 3.
  predArity(unfy(_,_)) => 2.
  predArity(ecall(_,Args)) => size(Args).

  public implementation equality[term] <= {
    T1 == T2 :- eqTerm(T1,T2).
    hash(T) => hashTerm(T).
  }

  eqTerm:(term,term){}.
  eqTerm(anon,anon).
  eqTerm(varbl(Nm1),varbl(Nm2)) :- Nm1==Nm2.
  eqTerm(intgr(Ix),intgr(Ix)).
  eqTerm(flot(Dx),flot(Dx)).
  eqTerm(enum(N1),enum(N2)) :- N1==N2.
  eqTerm(strct(N1,Ar),strct(N2,Ar)) :- N1==N2.
  eqTerm(prg(N1,Ar),prg(N2,Ar)) :- N1==N2.
  eqTerm(strng(S1),strng(S2)) :- S1==S2.
  eqTerm(tuple(E1),tuple(E2)) :- eqEls(E1,E2).
  eqTerm(cons(O1,E1),cons(O2,E2)) :- eqTerm(O1,O2), eqEls(E1,E2).

  eqEls:(list[term],list[term]){}.
  eqEls([E1,..L1],[E2,..L2]) :- eqTerm(E1,E2), eqEls(L1,L2).

  hashTerm:(term)=>integer.
  hashTerm(anon)=>0.
  hashTerm(varbl(Nm1)) => hash(Nm1).
  hashTerm(intgr(Ix)) => Ix.
  hashTerm(flot(Dx)) => hash(Dx).
  hashTerm(enum(N1)) => hash(N1)*37+hash("enum").
  hashTerm(strct(N1,Ar)) => hash(N1)*37+Ar.
  hashTerm(prg(N1,Ar)) => hash(N1)*41+Ar.
  hashTerm(strng(S1)) => hash(S1).
  hashTerm(tuple(Els)) => foldRight((T,H)=>H*37+hash(T),0,Els).
  hashTerm(cons(O1,Els)) => foldRight((T,H)=>H*37+hash(T),hash(O1),Els).

  public genVr:(string) => term.
  genVr(Nm) => varbl(_str_gen(Nm)).

  public isGroundTerm:(term){}.
  isGroundTerm(intgr(_)).
  isGroundTerm(flot(_)).
  isGroundTerm(enum(_)).
  isGroundTerm(strct(_,_)).
  isGroundTerm(prg(_,_)).
  isGroundTerm(strng(_)).
  isGroundTerm(tuple(Els)) :-
    isGroundTerm(E) *> E in Els.
  isGroundTerm(cons(Op,Els)) :-
    isGroundTerm(Op),
    isGroundTerm(E) *> E in Els.
}
