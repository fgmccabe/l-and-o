lo.comp.term {
  import lo.

  import lo.comp.misc.
  import lo.comp.package.
  import lo.comp.types.

  public term ::= anon
               | varbl(string)
               | intgr(integer)
               | flot(float)
               | enum(string)
               | strct(string,integer)
               | prg(string,integer)
               | strng(string)
               | cons(term,list[term])
               | invoke(option[tloc],term,list[term])
               | escvoke(option[tloc],string,list[term])
               | ovoke(option[tloc],term,term,term)
               | guarded(term,pred).

  public tloc ::= tloc(integer,integer,integer,integer).

  public rel <~ { name:term }.

  public rel:(term,option[tloc],list[clse]) <=> rel.
  rel(Nm,_,_) <= {
    name = Nm.
  }

  public clse ::= clse(list[term],term,list[term],list[pred])
              | eqn(list[term],term,list[term],term).


  public pred ::= call(option[tloc],term,list[term])
                    | ecall(option[tloc],string,list[term])
                    | ocall(option[tloc],term,term,term)
                    | unfy(option[tloc],term,term)
                    | conj(option[tloc],list[pred])
                    | cond(option[tloc],pred,pred,pred)
                    | neck
                    | fail
                    | except(option[tloc],term).

  public prProg ::= prProg(pkgSpec,map[term,rel]).

  public implementation display[prProg] <= {
    disp(Prog) => dispProg(Prog).
  }

  private dispProg:(prProg)=>ss.
  dispProg(prProg(_,Rels)) => ssSeq(values(Rels)//dispRel).

  public implementation display[rel] <= {
    disp(R) => dispRel(R).
  }

  private dispRel:(rel) => ss.
  dispRel(rel(Nm,Lc,Rules)) =>
    ssSeq(Rules//dispClause).

  public implementation display[clse] <= {
    disp(Cl) => dispClause(Cl).
  }

  private dispClause:(clse) => ss.
  dispClause(clse(Q,Hd,Args,Body)) => ssSeq([dispTerm(Hd,Q),dispArgs(Args,Q),ss(":-"),ssSeq(dispPreds("","\n    ",Body,Q)),ss(".\n")]).
  dispClause(eqn(Q,Hd,Args,guarded(Rep,Body))) => ssSeq([dispTerm(Hd,Q),dispArgs(Args,Q),ss("=>"),dispTerm(Rep,Q),ss(":-"),displayPred(Body,Q),ss(".\n")]).
  dispClause(eqn(Q,Hd,Args,Rep)) => ssSeq([dispTerm(Hd,Q),dispArgs(Args,Q),ss("=>"),dispTerm(Rep,Q),ss(".\n")]).

  public implementation display[term] <= {
    disp(T) => dispTerm(T,[]).
  }

  public dispTerm:(term,list[term]) => ss.
  dispTerm(anon,_) => ss("_").
  dispTerm(varbl(Nm),Q) => ssSeq([ss(Nm)]) :- varbl(Nm) in Q.
  dispTerm(varbl(Nm),Q) => ssSeq([ss(Nm),ss("?")]) :- \+ varbl(Nm) in Q.
  dispTerm(intgr(Ix),_) => disp(Ix).
  dispTerm(flot(Dx),_) => disp(Dx).
  dispTerm(enum(Nm),_) => ss(Nm).
  dispTerm(strct(Nm,Ar),_) => ssSeq([ss(Nm),ss(":"),disp(Ar)]).
  dispTerm(prg(Nm,Ar),_) => ssSeq([ss(Nm),ss("/"),disp(Ar)]).
  dispTerm(strng(Sx),_) => disp(Sx).
  dispTerm(cons(Op,Args),Q) => ssSeq([dispTerm(Op,Q),dispArgs(Args,Q)]).
  dispTerm(invoke(_,Op,Args),Q) => ssSeq([ss("<"),dispTerm(Op,Q),ss(">"),dispArgs(Args,Q)]).
  dispTerm(escvoke(_,Op,Args),Q) => ssSeq([ss(Op),dispArgs(Args,Q)]).
  dispTerm(ovoke(_,Call,Lbl,Ths),Q) => ssSeq([dispTerm(Lbl,Q),ss(":"),dispTerm(Ths,Q),ss("."),dispTerm(Call,Q)]).
  dispTerm(guarded(T,C),Q) => ssSeq([dispTerm(T,Q),ss("::"),displayPred(C,Q)]).

  dispGuard:(list[pred],string,list[term]) => list[ss].
  dispGuard([],_,_) => [].
  dispGuard(G,M,V) => dispPreds(M,", ",G,V).

  dispArgs:(list[term],list[term]) => ss.
  dispArgs(Args,Q) => ssSeq([ss("("),..dispEls("",")",Args,Q)]).

  private dispEls:(string,string,list[term],list[term]) => list[ss].
  dispEls(_,Tail,[],_) => [ss(Tail)].
  dispEls(Sep,Tail,[e,..l],Q) => [ss(Sep),dispTerm(e,Q),..dispEls(", ",Tail,l,Q)].

  public implementation display[pred] <= {
    disp(P) => displayPred(P,[]).
  }

  private displayPred:(pred,list[term]) => ss.
  displayPred(neck,_) => ss("!").
  displayPred(call(_,Op,Args),Q) => ssSeq([dispTerm(Op,Q),dispArgs(Args,Q)]).
  displayPred(ecall(_,Op,Args),Q) => ssSeq([ss(Op),dispArgs(Args,Q)]).
  displayPred(ocall(_,Rc,Lb,Th),Q) => ssSeq([dispTerm(Lb,Q),ss("."),dispTerm(Rc,Q)]).
  displayPred(unfy(_,L,R),Q) => ssSeq([dispTerm(L,Q),ss("="),dispTerm(R,Q)]).
  displayPred(conj(_,L),Q) => ssSeq(dispPreds("",", ",L,Q)).
  displayPred(cond(_,T,L,R),Q) => ssSeq([ss("("),displayPred(T,Q),ss("?"),displayPred(L,Q),ss("|"),displayPred(R,Q),ss(")")]).
  displayPred(fail,_) => ss("fail").
  displayPred(except(_,T),Q) => ssSeq([ss("raise "),dispTerm(T,Q)]).

  private dispPreds:(string,string,list[pred],list[term]) => list[ss].
  dispPreds(_,_,[],_) => [].
  dispPreds(Sep,Alt,[C,..L],Q) => [ss(Sep),displayPred(C,Q),..dispPreds(Alt,Alt,L,Q)].

  public predLoc:(pred) => option[tloc].
  predLoc(neck) => none.
  predLoc(fail) => none.
  predLoc(except(Lc,_)) => Lc.
  predLoc(call(Lc,_,_)) => Lc.
  predLoc(ocall(Lc,_,_,_)) => Lc.
  predLoc(ecall(Lc,_,_)) => Lc.
  predLoc(unfy(Lc,_,_)) => Lc.
  predLoc(cond(Lc,_,_,_)) => Lc.

  public implementation equality[term] <= {
    T1 == T2 :- eqTerm(T1,T2).
    hash(T) => hashTerm(T).
  }

  eqTerm:(term,term){}.
  eqTerm(anon,anon).
  eqTerm(varbl(Nm1),varbl(Nm2)) :- Nm1==Nm2.
  eqTerm(intgr(Ix),intgr(Ix)).
  eqTerm(flot(Dx),flot(Dx)).
  eqTerm(enum(N1),enum(N2)) :- N1==N2.
  eqTerm(strct(N1,Ar),strct(N2,Ar)) :- N1==N2.
  eqTerm(prg(N1,Ar),prg(N2,Ar)) :- N1==N2.
  eqTerm(strng(S1),strng(S2)) :- S1==S2.
  eqTerm(cons(O1,E1),cons(O2,E2)) :- eqTerm(O1,O2), eqEls(E1,E2).

  eqEls:(list[term],list[term]){}.
  eqEls([],[]).
  eqEls([E1,..L1],[E2,..L2]) :- eqTerm(E1,E2), eqEls(L1,L2).

  hashTerm:(term)=>integer.
  hashTerm(anon)=>0.
  hashTerm(varbl(Nm1)) => hash(Nm1).
  hashTerm(intgr(Ix)) => Ix.
  hashTerm(flot(Dx)) => hash(Dx).
  hashTerm(enum(N1)) => hashTerm(strct(N1,0)).
  hashTerm(strct(N1,Ar)) => (hash(N1)*37+Ar)%18446744073709551616. -- 'cos of swi-prolog :('
  hashTerm(prg(N1,Ar)) => (hash(N1)*37+Ar)%18446744073709551616.
  hashTerm(strng(S1)) => hash(S1).
  hashTerm(cons(O1,Els)) => foldRight((T,H)=>H*37+hash(T),hash(O1),Els)%18446744073709551616.

  public genVarbl:(string,term){}.
  genVarbl(Prefix,varbl(_str_gen(Prefix))).

  public isGroundTerm:(term){}.
  isGroundTerm(intgr(_)).
  isGroundTerm(flot(_)).
  isGroundTerm(enum(_)).
  isGroundTerm(strct(_,_)).
  isGroundTerm(prg(_,_)).
  isGroundTerm(strng(_)).
  isGroundTerm(cons(Op,Els)) :-
    isGroundTerm(Op),
    E in Els *> isGroundTerm(E).

  public tupleSig:(integer) => term.
  tupleSig(Ar) => strct("()\(Ar)",Ar).

  public isTupleSig:(term,integer){}.
  isTupleSig(strct(Nm,Ar),Ar) :- Nm="()\(Ar)".

  public mkTpl:(list[term]) => term.
  mkTpl(Els) => cons(tupleSig(size(Els)),Els).

  public clName:(clse) => term.
  clName(clse(_,Nm,_,_)) => Nm.
  clName(eqn(_,Nm,_,_)) => Nm.

  public clArgs:(clse) => list[term].
  clArgs(clse(_,_,Args,_)) => Args.
  clArgs(eqn(_,_,Args,_)) => Args.

  public simplifyGuard:(term) => term.
  simplifyGuard(guarded(T,conj(_,[]))) => simplifyGuard(T).
  simplifyGuard(T) => T.

  public simplifyCond:(pred) => pred.
  simplifyCond(conj(_,[P])) => simplifyCond(P).
  simplifyCond(P) => P.

  -- Finding variables
  public findVarsInClse:(clse) => list[term].
  findVarsInClse(clse(_,_,A,B)) => findVarsInPreds(B,findVarsInTerms(A,[])).
  findVarsInClse(eqn(_,_,A,R)) => findVarsInTerm(R,findVarsInTerms(A,[])).

  public findVarsInTerm:(term,list[term]) => list[term].
  findVarsInTerm(varbl(Nm),V) => mergeEl(V,varbl(Nm)).
  findVarsInTerm(T,V) => V :- isGroundTerm(T).
  findVarsInTerm(anon,V) => V.
  findVarsInTerm(cons(_,A),V) => findVarsInTerms(A,V).
  findVarsInTerm(invoke(_,O,A),V) => findVarsInTerms(A,findVarsInTerm(O,V)).
  findVarsInTerm(escvoke(_,O,A),V) => findVarsInTerms(A,V).
  findVarsInTerm(ovoke(_,C,L,T),V) => findVarsInTerm(C,findVarsInTerm(L,findVarsInTerm(T,V))).
  findVarsInTerm(guarded(T,G),V) => findVarsInTerm(T,findVarsInPred(G,V)).

  public findVarsInTerms:(list[term],list[term]) => list[term].
  findVarsInTerms([],V) => V.
  findVarsInTerms([T,..L],V) => findVarsInTerms(L,findVarsInTerm(T,V)).

  findVarsInPred:(pred,list[term]) => list[term].
  findVarsInPred(call(_,_,A),V) => findVarsInTerms(A,V).
  findVarsInPred(ecall(_,_,A),V) => findVarsInTerms(A,V).
  findVarsInPred(ocall(_,C,L,T),V) => findVarsInTerm(C,findVarsInTerm(L,findVarsInTerm(T,V))).
  findVarsInPred(unfy(_,L,T),V) => findVarsInTerm(L,findVarsInTerm(T,V)).
  findVarsInPred(except(_,E),V) => findVarsInTerm(E,V).
  findVarsInPred(fail,V) => V.
  findVarsInPred(neck,V) => V.
  findVarsInPred(conj(_,L),V) => findVarsInPreds(L,V).
  findVarsInPred(cond(_,T,L,R),V) => findVarsInPred(R,findVarsInPred(L,findVarsInPred(T,V))).

  findVarsInPreds:(list[pred],list[term]) => list[term].
  findVarsInPreds(Ps,V) => foldLeft(findVarsInPred,V,Ps).
}
