lo.comp.decode{
  import lo.
  import lo.resources.

  import lo.comp.package.
  import lo.comp.term.
  import lo.comp.types.
  import lo.comp.parseutils.
  import lo.comp.base64.

  public decodeValue:(string) => term.
  decodeValue(Txt) => Term :- decodeTerm(Term) %% explode(Txt).

  public decodeMdl:(string) => prProg.
  decodeMdl(Txt) => prProg(Spec,Code) :-
    (decodePkgSpec(Spec), decodeRels([],Code)) %% explode(Txt).

  decodePkgSpec:(pkgSpec) --> list[integer].
  decodePkgSpec(unwrapSpec(S)) --> decodeTerm(S).

  public unwrapSpec:(term) => pkgSpec.
  unwrapSpec(cons(_,[Pk,cons(_,Is),Ex,Tp,cons(_,C),cons(_,Co),cons(_,Im)])) =>
      pkgSpec(decodePkg(Pk),Fields,Types,Enums,Contracts,Impls,decodeImports(Is)) :-
    faceType(Fields) = decodeSignature(Ex),
    faceType(Types) = decodeSignature(Tp),
    pickupEnums(C,Enums,[]),
    findContracts(Co,Contracts,[]),
    pickupImplementations(Im,Impls,[]).

  decodePkg:(term)=>pkg.
  decodePkg(cons(strct("pkg",2),[strng(Pk),V]))=> pkg(Pk,decodeVers(V)).

  decodeVers:(term)=>version.
  decodeVers(enum("*"))=>defltVersion.
  decodeVers(strng(V)) => vers(V).

  findContracts:(list[term],list[conEntry],list[conEntry]){}.
  findContracts([],C,C).
  findContracts([cons(_,[strng(Nm),strng(ConNm),strng(ConSig),FaceSig]),..M],[conEntry(Nm,ConNm,Con,decodeSignature(FaceSig)),..C],Cx) :-
    decodeConstraint(ConSig,Con),
    findContracts(M,C,Cx).

  pickupImplementations:(list[term],list[implEntry],list[implEntry]){}.
  pickupImplementations([],I,I).
  pickupImplementations([cons(_,[strng(Nm),strng(Sig)]),..M],[implEntry(Nm,Spec),..I],RI) :-
    decodeConstraint(Sig,Spec),
    pickupImplementations(M,I,RI).

  decodeSignature:(term) => tipe.
  decodeSignature(strng(S)) => T :- decodeType(T) %% explode(S).

  decodeImports:(list[term]) => list[(visibility,pkg)].
  decodeImports([]) => [].
  decodeImports([cons(strct("import",2),[Vz,Pk]),..Is]) => [(decodeViz(Vz),decodePkg(Pk)),..decodeImports(Is)].

  decodeViz:(term)=>visibility.
  decodeViz(enum("public")) => pUblic.
  decodeViz(enum("private")) => priVate.

  pickupEnums:(list[term],list[string],list[string]){}.
  pickupEnums([],Cls,Cls).
  pickupEnums([strng(Nm),..Rest],[Nm,..More],Cls):-
    pickupEnums(Rest,More,Cls).

  decodeRels:(map[term,rel],map[term,rel]) --> list[integer].
  decodeRels(M,M) --> eof.
  decodeRels(M,Mx) --> decodeRel(Prg,Rl),decodeRels(M[Prg->Rl],Mx).

  decodeRel:(term,rel) --> list[integer].
  decodeRel(Prg,rel(Prg,TLc,Clses)) --> "R", decodeTerm(Prg), decodeOptional(decodeTloc,TLc), decodeClauses(Clses).

  decodeClause:(clse) --> list[integer].
  decodeClause(clse(Q,Nm,Args,Body)) --> "C",
      decodeTerm(Nm),
      decodeSequence(decodeTerm,Q),
      decodeSequence(decodeTerm,Args),
      decodeSequence(decodePred,Body).
  decodeClause(eqn(Q,Nm,Args,Rep)) --> ">",
      decodeTerm(Nm),
      decodeSequence(decodeTerm,Q),
      decodeSequence(decodeTerm,Args),
      decodeTerm(Rep).

  decodePred:(pred) --> list[integer].
  decodePred(call(TLc,Op,Args)) --> "P", decodeOptional(decodeTloc,TLc), decodeTerm(Op), decodeSequence(decodeTerm,Args).
  decodePred(ecall(TLc,Op,Args)) --> "E", decodeOptional(decodeTloc,TLc), decodeName(Op), decodeSequence(decodeTerm,Args).
  decodePred(ocall(TLc,O,S,I)) --> "O", decodeOptional(decodeTloc,TLc), decodeTerm(O), decodeTerm(S), decodeTerm(I).
  decodePred(unfy(TLc,L,R)) --> "=", decodeOptional(decodeTloc,TLc), decodeTerm(L), decodeTerm(R).
  decodePred(dfne(TLc,L,R)) --> "$", decodeOptional(decodeTloc,TLc), decodeTerm(L), decodeTerm(R).
  decodePred(next) --> "!".
  decodePred(fail) --> "#".
  decodePred(succ) --> "+".
  decodePred(conj(Lc,L)) --> "&", decodeOptional(decodeTloc,Lc),decodeSequence(decodePred,L).
  decodePred(cond(Lc,T,L,R)) --> "?",decodeOptional(decodeTloc,Lc),decodePred(T),decodePred(L),decodePred(R).

  decodeOptional:all t ~~ (((t)-->list[integer]),option[t]) --> list[integer].
  decodeOptional(_,none) --> "N".
  decodeOptional(I,some(O)) --> "@", I(O).

  decodeSequence:all t ~~ (((t)-->list[integer]),list[t]) --> list[integer].
  decodeSequence(I,L) --> "L", decInt(Count), decodeSeq(I,L,Count).

  decodeSeq:all t ~~ (((t)-->list[integer]),list[t],integer) --> list[integer].
  decodeSeq(_,[],0) --> [].
  decodeSeq(I,[E,..L],Cx) --> {Cx>0}, I(E), decodeSeq(I,L,Cx-1).

  decodeTloc:(tloc) --> list[integer].
  decodeTloc(tloc(Line,Off,Col,Len)) --> "T", decInt(Line), decInt(Off), decInt(Col), decInt(Len).

  decodeClauses:(list[clse]) --> list[integer].
  decodeClauses(Clses) --> decodeSequence(decodeClause,Clses).

  public decodeTuple:(string) => list[term].
  decodeTuple(Txt) => Els :- decodeTerm(cons(_,Els)) %% explode(Txt).

  private decodeTerm:(term) --> list[integer].
  decodeTerm(anon) --> "a".
  decodeTerm(intgr(Ix)) --> "x", decInt(Ix).
  decodeTerm(flot(Dx)) --> "d", decFloat(Dx).
  decodeTerm(enum(Nm)) --> "e", decodeName(Nm).
  decodeTerm(strng(Sx)) --> "s", decodeText(Chrs), { Sx = implode(Chrs)}.
  decodeTerm(strct(Nm,Ar)) --> "o", decInt(Ar), decodeName(Nm).
  decodeTerm(prg(Nm,Ar)) --> "p", decInt(Ar), decodeName(Nm).
  decodeTerm(cons(Op,Args)) --> "n", decInt(Len), decodeTerm(Op), decTerms(Len,Args).
  decodeTerm(invoke(Lc,Op,Args)) --> "V", decodeOptional(decodeTloc,Lc), decodeTerm(Op), decodeSequence(decodeTerm,Args).
  decodeTerm(escvoke(Lc,Op,Args)) --> "E", decodeOptional(decodeTloc,Lc), decodeName(Op), decodeSequence(decodeTerm,Args).
  decodeTerm(ovoke(TLc,O,S,I)) --> "O", decodeOptional(decodeTloc,TLc), decodeTerm(O), decodeTerm(S), decodeTerm(I).
  decodeTerm(guarded(T,C)) --> "g", decodeTerm(T), decodePred(C).

  private decTerms:(integer,list[term]) --> list[integer].
  decTerms(0,[]) --> [].
  decTerms(N,[T,..L]) --> decodeTerm(T), decTerms(N-1,L).

  private decInt:(integer) --> list[integer].
  decInt(-Ix) --> "-", decInt(Ix).
  decInt(Ix) --> digits(0,Ix).

  private digits:(integer,integer) --> list[integer].
  digits(SoFar,Ix) --> digit(D), { digitVal(D,Dv) }, digits(SoFar*10+Dv,Ix).
  digits(Ix,Ix) --> \+ digit(_).

  private decFloat:(float) --> list[integer].
  decFloat(Sx::float) --> decodeName(Sx). -- This needs to be fixed in final implementation

  private decodeText:(list[integer]) --> list[integer].
  decodeText(Chrs) --> [C], collectQuoted(C,Chrs).

  private collectQuoted:(integer,list[integer]) --> list[integer].
  collectQuoted(C,[]) --> [C].
  collectQuoted(C,[Ch,..L]) --> [0c\\, Ch], collectQuoted(C,L).
  collectQuoted(C,[Ch,..L]) --> [Ch], collectQuoted(C,L).

  private decodeName:(string) --> list[integer].
  decodeName(implode(Text)) --> [C], collectQuoted(C,Text).

  public decodeType:(tipe) --> list[integer].
  decodeType(anonType) --> "_".
  decodeType(voidType) --> "v".
  decodeType(thisType) --> "h".
  decodeType(tipe("lo.core*integer")) --> "i".
  decodeType(tipe("lo.core*float")) --> "f".
  decodeType(tipe("lo.core*string")) --> "S".
  decodeType(tipe("lo.core*logical")) --> "l".
  decodeType(kVar(Nm)) --> "k", decodeName(Nm).
  decodeType(kFun(Nm,Ar)) --> "K", typeLen(Ar), decodeName(Nm).
  decodeType(tipe(Nm)) --> "t", decodeName(Nm).
  decodeType(tpFun(Nm,Ar)) --> "z", typeLen(Ar), decodeName(Nm).
  decodeType(typeExp(tpFun("lo.core*list",1),[ElTp])) --> "L", decodeType(ElTp).
  decodeType(typeExp(Nm,ArgTypes)) --> "U", decodeType(Nm), typeLen(Ln), decodeTypes(Ln,ArgTypes).
  decodeType(univType(TV,Tp)) --> ":", decodeType(TV), decodeType(Tp).
  decodeType(constrained(Tp,Con)) --> "|", decodeType(Tp), decConstraint(Con).
  decodeType(faceType(Fields)) --> "I", typeLen(Ln),decodeFields(Ln,Fields).
  decodeType(funType(A,T)) --> "F", decodeType(A), decodeType(T).
  decodeType(grammarType(A,T)) --> "G", decodeType(A), decodeType(T).
  decodeType(predType(A)) --> "P", decodeType(A).
  decodeType(classType(A,T)) --> "C", decodeType(A), decodeType(T).
  decodeType(tupleType(Tps)) --> "T", typeLen(Ln),decodeTypes(Ln,Tps).
  decodeType(typeRule(L,R)) --> "Y", decodeType(L), decodeType(R).
  decodeType(tpLambda(A,R)) --> "Z", typeLen(Ln),decodeTypes(Ln,A), decodeType(R).

  private typeLen:(integer) --> list[integer].
  typeLen(Ix) --> digits(0,Ix).

  private decodeTypes:(integer,list[tipe]) --> list[integer].
  decodeTypes(0,[]) --> [].
  decodeTypes(Ix,[T,..L]) --> decodeType(T), decodeTypes(Ix-1,L).

  private decodeFields:(integer,list[(string,tipe)]) --> list[integer].
  decodeFields(0,[]) --> [].
  decodeFields(Ix,[(Nm,T),..L]) --> decodeName(Nm),decodeType(T), decodeFields(Ix-1,L).

  public decodeConstraint:(string,constraint){}.
  decodeConstraint(Txt,Con) :- decConstraint(Con) %% explode(Txt).

  private decConstraint:(constraint) --> list[integer].
  decConstraint(conCon(Con,Extra)) --> "|", decConstraint(Con), decConstraint(Extra).
  decConstraint(conTract(Nm,Args,Deps)) --> "c", decodeName(Nm), decodeType(tupleType(Args)), decodeType(tupleType(Deps)).
  decConstraint(implementsFace(Tp,Face)) --> "a", decodeType(Tp), decodeType(faceType(Face)).
  decConstraint(univCon(TV,Con)) --> ":", decodeType(TV), decConstraint(Con).
}
