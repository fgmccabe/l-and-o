test.modsec{
  -- Test of L&O by parsing modsecurity rules.

  import lo.
  import lo.uri.
  import lo.resources.
  import lo.json.

  type modSecRule ::= modSecRule(list[string],string,list[msAct]).

  type msAct ::= single(string) | id(string) | tag(string) | other(string,string).

  -- Hint to the run-time:
  main:(list[string]){}.
  main(Args) :-
    processFiles(parseArgs(Args),cwd()).

  parseArgs:(list[string]) => list[uri].
  parseArgs([]) => [].
  parseArgs([f,..l]) => [parseUri(f),..parseArgs(l)].

  processFiles:(list[uri],uri){}.
  processFiles([],_).
  processFiles([u,..l],c) :-
    procFile(resolveUri(c,u),L),
    processFiles(l,c).

  procFile:(uri,list[modSecRule]){}.
  procFile(U,Rls) :-
    lines(Lns) %% getResource(U),
    Tks = tokenize(Lns),
    Rls = secRules(Tks),
    _logmsg("Rules are $(Rls::list[json])").

  implementation display[modSecRule] .. {
    disp(modSecRule(Tgt,Ptn,A)) => ssSeq([ss("SecRule:"),disp(Tgt),ss(" "),ss(Ptn),ss("-->"),dispActions(A)]). 
  }

  implementation coercion[modSecRule,json] .. {
    _coerce(modSecRule(Tgt,Ptn,[])) =>  jColl({"SecRule" -> jColl({"target" -> jSeq(jStrings(Tgt)). "pattern"->jTxt(Ptn)})}).
    _coerce(modSecRule(Tgt,Ptn,Action)) => jColl({"SecRule" -> jColl({"target" -> jSeq(jStrings(Tgt)). "pattern"->jTxt(Ptn). "action"->jSeq(jActions(Action))})}).
  }

  jActions:(list[msAct]) => list[json].
  jActions([]) => [].
  jActions([S,..L]) => [S::json,..jActions(L)].

  implementation coercion[msAct,json] .. {
    _coerce(single(A)) => jTxt(A).
    _coerce(id(I)) => jColl({"id" -> jTxt(I)}).
    _coerce(tag(T)) => jColl({"tag"->jTxt(T)}).
    _coerce(other(V,A)) => jColl({"verb"->jTxt(V). "arg"->jTxt(A)}).
  }

  jStrings:(list[string]) => list[json].
  jStrings([]) => [].
  jStrings([S,..L]) => [jTxt(S),..jStrings(L)].

  secRules:(list[list[secTkn]]) => list[modSecRule].
  secRules([]) => [].
  secRules([Ln,..L]) => [Rl,..secRules(L)] :- rule(Rl) %% Ln.

  -- Parse a line as a mod security rule
  rule:(modSecRule) --> list[secTkn].
  rule(modSecRule(Tgt,Ptn,Action)) --> [secRule], target(Tgt), pattern(Ptn), actions(Action).

  target:(list[string]) --> list[secTkn].
  target(T) --> [idn(S)], { idenSeq(T) %% S}.

  idenSeq:(list[string]) --> list[integer].
  idenSeq([]) --> eof.
  idenSeq([implode(I),..L]) --> frag(I,0c|), moreIdens(L).

  moreIdens:(list[string]) --> list[integer].
  moreIdens([]) --> eof.
  moreIdens(L) --> "|", idenSeq(L).

  pattern:(string) --> list[secTkn].
  pattern(P) --> [strg(S)], {P = implode(S)}.

  actions:(list[string]) --> list[secTkn].
  actions(A) --> [strg(S)], {spaces(), actionSeq(A) %% S}.
  actions([]) --> eof.

  actionSeq:(list[string]) --> list[integer].
  actionSeq([]) --> eof.
  actionSeq([implode(I),..L]) --> action(I), spaces(), moreActions(L).

  moreActions:(list[string]) --> list[integer].
  moreActions([]) --> eof.
  moreActions(L) --> ",", spaces(), actionSeq(L).

  action:(msAct) --> list[integer].
  action(id(I)) --> "id:", spaces(), arg(I).
  action(tag(T)) --> "tag:", spaces(), arg(T).
  action(other(implode(V),A)) --> frag(V,0c:), ":", spaces(), arg(A).
  action(single(implode(A))) --> iden(A).

  arg:(string) --> list[integer].
  arg(implode(A)) --> "'", frag(A,0c').

  -- Absorb the \eol markers into a sequence of lines.

  lines:(list[list[integer]]) --> list[integer].
  lines(Lns) --> line(Ln)!, {glue(Lns,Ln,Rest)}, lines(Rest).
  lines([]) --> eof.

  line:(list[integer]) --> list[integer].
  line([]) --> "\n".
  line([]) --> "#", eol().
  line(Ln) --> "\\\n", line(Ln).
  line([C,..L]) --> [C],line(L).

  eol:()-->list[integer].
  eol() --> "\n".
  eol() --> [C], { C \= 0c\n}, eol().
  eol() --> eof.

  private glue:all t ~~ (list[list[t]],list[t],list[list[t]]){}.
  glue(Text,[],Text).
  glue([Ln,..Rest],Ln,Rest) :- Ln\=[].

  -- Tokenization of modsecurity source

  private type secTkn ::= secRule | secAction | secDefaultAction | secMarker | secRuleUpdate
   | idn(list[integer]) | strg(list[integer]).

  implementation display[secTkn] .. {
    disp(secAction) => ss("SecAction").
    disp(secRule) => ss("SecRule").
    disp(secMarker) => ss("SecMarker").
    disp(secDefaultAction) => ss("SecDefaultAction").
    disp(secRuleUpdate) => ss("SecRuleUpdate").
    disp(strg(Seq)) => ssSeq([ss("\""), ss(implode(Seq)), ss("\"")]).
    disp(idn(Text)) => ssSeq([ss("'"), ss(implode(Text)), ss("'")]).
  }

  tokenize:(list[list[integer]]) => list[list[secTkn]].
  tokenize([]) => [].
  tokenize([l,..ll]) => [tks,..tokenize(ll)] :- tokens(tks) %% l.

  tokens:(list[secTkn]) --> list[integer].
  tokens(Toks) --> spaces(), moreToks(Toks).

  spaces:()-->list[integer].
  spaces() --> space(), spaces().
  spaces() --> \+ space().

  space:()-->list[integer].
  space() --> ([0c ] | [0c\t])!.

  moreToks:(list[secTkn]) --> list[integer].
  moreToks([]) --> eof.
  moreToks([Tok,..More]) --> token(Tok), tokens(More).

  token:(secTkn) --> list[integer].
  token(secRule) --> "SecRule".
  token(secAction) --> "SecAction".
  token(secMarker) --> "SecMarker".
  token(strg(Seq)) --> "\"", stringText(Seq), "\"".
  token(idn(Text)) --> iden(Text).

  iden:(list[integer]) --> list[integer].
  iden(L) --> frag(L,0c ).

  frag:(list[integer],integer) --> list[integer].
  frag([],_) --> eof.
  frag([],Dl) --> [Dl]+.
  frag([C,..L],Dl) --> [C], frag(L,Dl).

  stringText:(list[integer]) --> list[integer].
  stringText([]) --> [].
  stringText(T) --> "\\\n", stringText(T).
  stringText([C,..More]) --> "\\", quote(C), stringText(More).
  stringText([C,..More]) --> [C], { C \= 0c" }, stringText(More).

  quote:(integer) --> list[integer].
  quote(0c\n) --> "n".
  quote(0c") --> "\"".
  quote(0c') --> "'".
  quote(0c\t) --> "t".
  quote(C) --> [C].

}