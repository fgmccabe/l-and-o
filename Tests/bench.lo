/*
   benchmark, adapted from  BENCH.PL : The classic Prolog benchmark

	Supplied by Quintus Computer Systems, Inc.
	April 30th 1984

  Modified to run in L&O using monads to sequentialize things properly
*/
test.bench{
  import lo.
  import lo.monad.
  import lo.action.

  get_cpu_time:()=>float.
  get_cpu_time() => _ticks().

  nrev:all t ~~ (list[t],list[t]){}.
  nrev([],[]).
  nrev([X,..Rest],Ans) :- nrev(Rest,L), append(L,[X],Ans).

  append:all t ~~ (list[t],list[t],list[t]){}.
  append([],L,L).
  append([X,..L1],L2,[X,..L3]) :- append(L1,L2,L3).

  data:(list[integer]){}.
  data([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,
        21,22,23,24,25,26,27,28,29,30]).

  lots:(){}.
  lots() :-
      eg_count(Count),
      bench(Count),
      false.
  lots().

  eg_count:(integer){}.
  eg_count(100).
  eg_count(200).
  eg_count(500).
  eg_count(1000).
  eg_count(2000).
  eg_count(5000).
  eg_count(10000).

  bench:(integer){}.
  bench(Count) :-
      T0 = get_cpu_time(),
      dodummy(Count),
      T1 = get_cpu_time(),
      dobench(Count),
      T2 = get_cpu_time(),
      report(Count,T0,T1,T2).

  benchTest:(integer)=>(action[float],action[float]).
  benchTest(Count) => (timeTest((():-dodummy(Count))),timeTest((():-dobench(Count)))).

  timeTest:((){}) => action[float].
  timeTest(F) => return get_cpu_time() >>= runTest(F).

  runTest:((){}) => ((float)=>action[float]).
  runTest(T) => ((St)=>delta(St) :- T()).

  delta:(float) => action[float].
  delta(St) => return (get_cpu_time()-St).

  dobench:(integer){}.
  dobench(Count) :-
      data(List),
      repeat(Count),
      nrev(List,_),
      false.
  dobench(_).

  dodummy:(integer){}.
  dodummy(Count) :-
      data(List),
      repeat(Count),
      dummy(List,_),
      false.
  dodummy(_).

  dummy:all t ~~ (t,t){}.
  dummy(_,_).

  repeat:(integer){}.
  repeat(_).
  repeat(N) :- N > 1, repeat(N-1).

  report:(integer,float,float,float){}.
  report(Count,T0,T1,T2) :-
      Time1 = T1-T0,
      Time2 = T2-T1,
      Time  = Time2-Time1,		/* Time spent on nreving lists */
      calculate_lips(Count,Time,Lips,Units),
      _logmsg("\(Lips)\(Units) lips for \(Count) iterations, taking \(Time) seconds").

  calculate_lips:(integer,float,float,string){}.
  calculate_lips(Count,Time,Sp,Units) :- megaLip((496*Count)::float/Time,Sp,Units).

  megaLip:(float,float,string){}.
  megaLip(0.0,0.0,"").
  megaLip(L,L,"") :- L<1000.0.
  megaLip(L,L/1000.0,"K") :- L>=1000.0,L<1000000.0.
  megaLip(L,L/1000000.0,"M") :- L>=1000000.0.

  assert lots().
}
