lo.doc.parse{
  import lo.
  import lo.uri.
  import lo.resources.

  import lo.comp.abstract.
  import lo.comp.ast.
  import lo.comp.errors.
  import lo.comp.grammar.
  import lo.comp.location.


  public docSpec ::= varSpec(string,ast,option[string])
         | typeSpec(string,ast,option[string])
         | contractSpec(string,ast,option[string],map[string,docSpec])
         | implSpec(string,ast,option[string])
         | pkgSpec(string,option[string],map[string,docSpec]).

  public genPkgDoc:(ast) => docSpec.
  genPkgDoc(P) => pkgSpec(PkgNm,findDescription(M,PkgNm),processStmts(Els,id,M,[])) :-
    isBraceTerm(P,_,Pk,Els),
    PkgNm = packageName(Pk),
    M = collectDescriptions(Els,PkgNm,[]).

  collectDescriptions:(list[ast],string,map[string,string])=>map[string,string].
  collectDescriptions([],_,M)=>M.
  collectDescriptions([El,..L],Deflt,M) => collectDescriptions(L,Deflt,M[Deflt->Desc]) :-
      isUnary(El,"@",_,E), isDescription(E,Desc).
  collectDescriptions([El,..L],Deflt,M) => collectDescriptions(L,Deflt,M[Nm->Desc]) :-
      isBinary(El,"@",_,N,E),
      isIden(N,_,Nm),
      isDescription(E,Desc).
  collectDescriptions([_,..L],Deflt,M) => collectDescriptions(L,Deflt,M).

  findDescription:(map[string,string],string) => option[string].
  findDescription(D,Ky) => some(Txt) :- present(D,Ky,Txt).
  findDescription(_,_) => none.

  isDescription:(ast,string){}.
  isDescription(A,Txt) :-
    isRoundTerm(A,_,Op,[T]),
    isIden(Op,_,"description"),
    isString(T,_,Txt).

  processStmts:(list[ast],(ast)=>ast,map[string,string],map[string,docSpec]) => map[string,docSpec].
  processStmts([],_,_,M) => M.
  processStmts([El,..L],F,D,M) => processStmts(L,F,D,processStmt(El,F,D,M)).

  processStmt:(ast,(ast)=>ast,map[string,string],map[string,docSpec]) => map[string,docSpec].
  processStmt(St,TF,Descs,M) => M[Nm->varSpec(Nm,TF(TpSpec),findDescription(Descs,Nm))] :-
    isTypeAnnotation(St,_,Nm,Spec).
  processStmt(St,TF,Descs,M) => M[Nm->typeSpec(Nm,St,findDescription(Descs,Nm))] :-
    isAlgebraicTypeDef(St,_,_,_,Hd,_),
    typeName(Hd,Nm).
  processStmt(St,TF,Descs,M) => M[Nm->contractSpec(Nm,TF(wrapQuants(Q,Lc,wrapConstraints(C,Lc,Con))),
        findDescription(Descs,Nm),
        processStmts(Els,(Tp)=>TF(wrapQuants(Q,Lc,wrapConstraints(C,Lc,Tp))),ConDescs,[]))] :-
    isContractSpec(St,Lc,Q,C,Con,Els),
    typeName(Con,Nm),
    ConDescs = collectDescriptions(Els,Nm,[]).
  processStmt(St,TF,Descs,M) => M[Nm->implSpec(Nm,TF(Con),findDescription(Descs,Nm))] :-
    isImplementation(St,_,Con,_).
  processStmt(_,_,_,M) => M.

  typeName:(ast,string){}.
  typeName(St,Nm) :- isIden(St,_,Nm).
  typeName(St,Nm) :- isSquareTerm(St,_,O,_), isIden(O,_,Nm).

  isPublic:(ast,ast){}.
  isPublic(St,Inn) :-
    isUnary(St,"public",_,Inn).

}
